/**
 * Generated by Apache Royale Compiler from mx/collections/XMLListAdapter.as
 * mx.collections.XMLListAdapter
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.collections.XMLListAdapter');
/* Royale Dependency List: XML,XMLList,mx.events.CollectionEvent,mx.events.CollectionEventKind,mx.events.PropertyChangeEvent,mx.events.PropertyChangeEventKind,mx.utils.XMLNotifier,org.apache.royale.reflection.getQualifiedClassName,org.apache.royale.utils.UIDUtil,org.apache.royale.utils.Language*/

goog.require('org.apache.royale.events.EventDispatcher');
goog.require('mx.collections.IList');
goog.require('mx.utils.IXMLNotifiable');



/**
 *  Construct a new XMLListAdapter using the specified XMLList as its source.
 *  If no source is specified an empty XMLList will be used.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @constructor
 * @extends {org.apache.royale.events.EventDispatcher}
 * @implements {mx.collections.IList}
 * @implements {mx.utils.IXMLNotifiable}
 * @param {XMLList=} source
 */
mx.collections.XMLListAdapter = function(source) {
  source = typeof source !== 'undefined' ? source : null;
  mx.collections.XMLListAdapter.base(this, 'constructor');
  this.disableEvents();
  this.source = source;
  this.enableEvents();
};
goog.inherits(mx.collections.XMLListAdapter, org.apache.royale.events.EventDispatcher);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.collections.XMLListAdapter', mx.collections.XMLListAdapter);


/**
 * @private
 * @type {XMLList}
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter__source;


/**
 *  Add the specified item to the end of the list.
 *  Equivalent to addItemAt(item, length);
 *  @asparam item the item to add
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 */
mx.collections.XMLListAdapter.prototype.addItem = function(item) {
  this.addItemAt(item, this.length);
};


/**
 *  Add the item at the specified index.  Any item that was after
 *  this index is moved out by one.  If the list is shorter than 
 *  the specified index it will grow to accomodate the new item.
 * 
 *  @asparam item the item to place at the index
 *  @asparam index the index at which to place the item
 *  @throws RangeError if index is less than 0     
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 * @param {number} index
 */
mx.collections.XMLListAdapter.prototype.addItemAt = function(item, index) {
  var /** @type {string} */ message;
  this.mx_collections_XMLListAdapter_setBusy();
  if (this.length > 0) {
    var /** @type {number} */ localLength = (this.source.length()) >>> 0;
    for (var /** @type {number} */ i = localLength; i > index; i--) {
      this.source[i] = this.source[i - 1];
    }
  }
  this.source[index] = item;
  this.startTrackUpdates(item, this.mx_collections_XMLListAdapter_seedUID + this.mx_collections_XMLListAdapter_uidCounter.toString());
  this.mx_collections_XMLListAdapter_uidCounter++;
  if (this.mx_collections_XMLListAdapter__dispatchEvents == 0) {
    var /** @type {mx.events.CollectionEvent} */ event = new mx.events.CollectionEvent(mx.events.CollectionEvent.COLLECTION_CHANGE);
    event.kind = mx.events.CollectionEventKind.ADD;
    event.items.push(item);
    event.location = index;
    this.dispatchEvent(event);
  }
  this.mx_collections_XMLListAdapter_clearBusy();
};


/**
 *  Get the item at the specified index.
 * 
 *  @asparam index the index in the list from which to retrieve the item
 *  @asparam	prefetch int indicating both the direction and amount of items
 *			to fetch during the request should the item not be local.
 *  @asreturn the item at that index, null if there is none
 *  @throws ItemPendingError if the data for that index needs to be 
 *                          loaded from a remote location
 *  @throws RangeError if the index < 0 or index >= length
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {number} index
 * @param {number=} prefetch
 * @return {Object}
 */
mx.collections.XMLListAdapter.prototype.getItemAt = function(index, prefetch) {
  prefetch = typeof prefetch !== 'undefined' ? prefetch : 0;
  return this.source[index];
};


/**
 *  Return the index of the item if it is in the list such that
 *  getItemAt(index) == item.  Note: unlike IViewCursor.findXXX
 *  <code>getItemIndex</code> cannot take a representative object, it is
 *  searching for an exact match.
 * 
 *  @asparam item the item to find
 *  @asreturn the index of the item, -1 if the item is not in the list.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 * @return {number}
 */
mx.collections.XMLListAdapter.prototype.getItemIndex = function(item) {
  if (org.apache.royale.utils.Language.is(item, XML) && this.source.contains(XML.conversion(item))) {
    var /** @type {number} */ len = this.length;
    for (var /** @type {number} */ i = 0; i < len; i++) {
      var /** @type {Object} */ search = this.source[i];
      if (search === item) {
        return i;
      }
    }
  }
  return -1;
};


/**
 *  Notify the view that an item has been updated.  This is useful if the
 *  contents of the view do not implement <code>IEventDispatcher</code> 
 *  and dispatches a <code>PropertyChangeEvent</code>.  If a property
 *  is specified the view may be able to optimize its notification mechanism.
 *  Otherwise it may choose to simply refresh the whole view.
 *
 *  @asparam item The item within the view that was updated.
 *
 *  @asparam property A String, QName, or int
 *  specifying the property that was updated.
 *
 *  @asparam oldValue The old value of that property.
 *  (If property was null, this can be the old value of the item.)
 *
 *  @asparam newValue The new value of that property.
 *  (If property was null, there's no need to specify this
 *  as the item is assumed to be the new value.)
 *
 *  @see mx.events.CollectionEvent
 *  @see mx.core.IPropertyChangeNotifier
 *  @see mx.events.PropertyChangeEvent
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 * @param {Object=} property
 * @param {Object=} oldValue
 * @param {Object=} newValue
 */
mx.collections.XMLListAdapter.prototype.itemUpdated = function(item, property, oldValue, newValue) {
  property = typeof property !== 'undefined' ? property : null;
  oldValue = typeof oldValue !== 'undefined' ? oldValue : null;
  newValue = typeof newValue !== 'undefined' ? newValue : null;
  var /** @type {mx.events.PropertyChangeEvent} */ event = new mx.events.PropertyChangeEvent(mx.events.PropertyChangeEvent.PROPERTY_CHANGE);
  event.kind = mx.events.PropertyChangeEventKind.UPDATE;
  event.source = item;
  event.property = property;
  event.oldValue = oldValue;
  event.newValue = newValue;
  this.itemUpdateHandler(event);
};


/** 
 * Remove all items from the list.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 */
mx.collections.XMLListAdapter.prototype.removeAll = function() {
  if (this.length > 0) {
    for (var /** @type {number} */ i = (this.length - 1) >> 0; i >= 0; i--) {
      this.stopTrackUpdates(this.source[i]);
      this.source.removeChild(i);
    }
    if (this.mx_collections_XMLListAdapter__dispatchEvents == 0) {
      var /** @type {mx.events.CollectionEvent} */ event = new mx.events.CollectionEvent(mx.events.CollectionEvent.COLLECTION_CHANGE);
      event.kind = mx.events.CollectionEventKind.RESET;
      this.dispatchEvent(event);
    }
  }
};


/**
 *  Removes the specified item from this list, should it exist.
 *  Relies on ArrayList implementation
 *
 *  @asparam  item Object reference to the item that should be removed.
 *  @asreturn Boolean indicating if the item was removed.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Apache Flex 4.10
 * @export
 * @param {Object} item
 * @return {boolean}
 */
mx.collections.XMLListAdapter.prototype.removeItem = function(item) {
  var /** @type {Object} */ _item = this.removeItemAt(this.getItemIndex(item));
  return _item != null;
};


/**
 *  Remove the item at the specified index and return it.  Any items
 *  that were after this index are now one index earlier.
 *
 *  @asparam index the index from which to remove the item
 *  @asreturn the item that was removed
 *  @throws RangeError is index is less than 0 or greater than length     
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {number} index
 * @return {Object}
 */
mx.collections.XMLListAdapter.prototype.removeItemAt = function(index) {
  this.mx_collections_XMLListAdapter_setBusy();
  var /** @type {Object} */ removed = this.source[index];
  this.source.removeChild(index);
  this.stopTrackUpdates(removed);
  if (this.mx_collections_XMLListAdapter__dispatchEvents == 0) {
    var /** @type {mx.events.CollectionEvent} */ event = new mx.events.CollectionEvent(mx.events.CollectionEvent.COLLECTION_CHANGE);
    event.kind = mx.events.CollectionEventKind.REMOVE;
    event.location = index;
    event.items.push(removed);
    this.dispatchEvent(event);
  }
  this.mx_collections_XMLListAdapter_clearBusy();
  return removed;
};


/**
 *  Place the item at the specified index.  If an item was already
 *  at that index the new item will replace it and it will be returned.
 *  If the list is shorter than the specified index it will grow to 
 *  to accomodate the new item.
 *
 *  @asparam item the new value for the index
 *  @asparam index the index at which to place the item
 *  @asreturn the item that was replaced, null if none
 *  @throws RangeError if index is less than 0     
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 * @param {number} index
 * @return {Object}
 */
mx.collections.XMLListAdapter.prototype.setItemAt = function(item, index) {
  var /** @type {Object} */ oldItem = this.source[index];
  this.source[index] = item;
  this.stopTrackUpdates(oldItem);
  this.startTrackUpdates(item, this.mx_collections_XMLListAdapter_seedUID + this.mx_collections_XMLListAdapter_uidCounter.toString());
  this.mx_collections_XMLListAdapter_uidCounter++;
  if (this.mx_collections_XMLListAdapter__dispatchEvents == 0) {
    var /** @type {mx.events.CollectionEvent} */ event = new mx.events.CollectionEvent(mx.events.CollectionEvent.COLLECTION_CHANGE);
    event.kind = mx.events.CollectionEventKind.REPLACE;
    var /** @type {mx.events.PropertyChangeEvent} */ updateInfo = new mx.events.PropertyChangeEvent(mx.events.PropertyChangeEvent.PROPERTY_CHANGE);
    updateInfo.kind = mx.events.PropertyChangeEventKind.UPDATE;
    updateInfo.oldValue = oldItem;
    updateInfo.newValue = item;
    event.location = index;
    event.items.push(updateInfo);
    this.dispatchEvent(event);
  }
  return oldItem;
};


/**
 *  Return an Array that is populated in the same order as the IList
 *  implementation.  
 * 
 *  @throws ItemPendingError if the data is not yet completely loaded
 *  from a remote location
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @return {Array}
 */
mx.collections.XMLListAdapter.prototype.toArray = function() {
  var /** @type {XMLList} */ s = this.source;
  var /** @type {number} */ len = s.length();
  var /** @type {Array} */ ret = [];
  for (var /** @type {number} */ i = 0; i < len; i++) {
    ret[i] = s[i];
  }
  return ret;
};


/**
 *  Pretty prints the contents of this XMLListAdapter to a string and returns it.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @override
 */
mx.collections.XMLListAdapter.prototype.toString = function() {
  if (this.source)
    return this.source.toString();
  else
    return org.apache.royale.reflection.getQualifiedClassName(this);
};


/**
 *  True if we're processing a addItem or removeItem call
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @return {boolean}
 */
mx.collections.XMLListAdapter.prototype.busy = function() {
  return (this.mx_collections_XMLListAdapter__busy != 0);
};


/**
 *  Enables event dispatch for this list.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 */
mx.collections.XMLListAdapter.prototype.enableEvents = function() {
  this.mx_collections_XMLListAdapter__dispatchEvents++;
  if (this.mx_collections_XMLListAdapter__dispatchEvents > 0)
    this.mx_collections_XMLListAdapter__dispatchEvents = 0;
};


/**
 *  Disables event dispatch for this list.
 *  To re-enable events call enableEvents(), enableEvents() must be called
 *  a matching number of times as disableEvents().
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 */
mx.collections.XMLListAdapter.prototype.disableEvents = function() {
  this.mx_collections_XMLListAdapter__dispatchEvents--;
};


/**
 *  clears busy flag
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter_clearBusy = function() {
  this.mx_collections_XMLListAdapter__busy++;
  if (this.mx_collections_XMLListAdapter__busy > 0)
    this.mx_collections_XMLListAdapter__busy = 0;
};


/**
 *  Sets busy flag.  Tree DP's check it so they
 *  know whether to fake events for it or not.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter_setBusy = function() {
  this.mx_collections_XMLListAdapter__busy--;
};


/**
 *  Called whenever any of the contained items in the list fires a
 *  <code>PropertyChangeEvent</code>.
 *  Wraps it in a CollectionEventKind.UPDATE.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {mx.events.PropertyChangeEvent} event
 */
mx.collections.XMLListAdapter.prototype.itemUpdateHandler = function(event) {
  if (this.mx_collections_XMLListAdapter__dispatchEvents == 0) {
    var /** @type {mx.events.CollectionEvent} */ updateEvent = new mx.events.CollectionEvent(mx.events.CollectionEvent.COLLECTION_CHANGE);
    updateEvent.kind = mx.events.CollectionEventKind.UPDATE;
    updateEvent.items.push(event);
    this.dispatchEvent(updateEvent);
  }
};


/**
 * Called whenever an XML object contained in our list is updated
 * in some way.  The initial implementation stab is very lenient,
 * any changeType will cause an update no matter how much further down
 * in a hierarchy.  
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} currentTarget
 * @param {string} type
 * @param {Object} target
 * @param {Object} value
 * @param {Object} detail
 */
mx.collections.XMLListAdapter.prototype.xmlNotification = function(currentTarget, type, target, value, detail) {
  var /** @type {string} */ prop;
  var /** @type {Object} */ oldValue;
  var /** @type {Object} */ newValue;
  if (currentTarget === target) {
    switch (type) {
      case "attributeAdded":
        prop = "@" + String(value);
        newValue = detail;
        break;
      case "attributeChanged":
        prop = "@" + String(value);
        oldValue = detail;
        newValue = target[prop];
        break;
      case "attributeRemoved":
        prop = "@" + String(value);
        oldValue = detail;
        break;
      case "nodeAdded":
        prop = org.apache.royale.utils.Language.string(value.localName());
        newValue = value;
        break;
      case "nodeChanged":
        prop = org.apache.royale.utils.Language.string(value.localName());
        oldValue = detail;
        newValue = value;
        break;
      case "nodeRemoved":
        prop = org.apache.royale.utils.Language.string(value.localName());
        oldValue = value;
        break;
      case "textSet":
        prop = String(value);
        newValue = String(target[prop]);
        oldValue = detail;
        break;
      default:
        break;
    }
  } else if (type == "textSet") {
    var /** @type {*} */ par = target.parent();
    if (par != undefined) {
      var /** @type {*} */ gpar = par.parent();
      if (gpar === currentTarget) {
        prop = par.name().toString();
        newValue = value;
        oldValue = detail;
      }
    }
  }
  this.itemUpdated(currentTarget, prop, oldValue, newValue);
};


/** 
 *  This is called by addItemAt and when the source is initially
 *  assigned.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 * @param {string} uid
 */
mx.collections.XMLListAdapter.prototype.startTrackUpdates = function(item, uid) {
  mx.utils.XMLNotifier.getInstance().watchXML(item, this, uid);
};


/** 
 *  This is called by removeItemAt, removeAll, and before a new
 *  source is assigned.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} item
 */
mx.collections.XMLListAdapter.prototype.stopTrackUpdates = function(item) {
  mx.utils.XMLNotifier.getInstance().unwatchXML(item, this);
};


/**
 * @private
 * @type {number}
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter__dispatchEvents = 0;


/**
 * @private
 * @type {number}
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter__busy = 0;


/**
 * @private
 * @type {string}
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter_seedUID;


/**
 * @private
 * @type {number}
 */
mx.collections.XMLListAdapter.prototype.mx_collections_XMLListAdapter_uidCounter = 0;


mx.collections.XMLListAdapter.prototype.get__length = function() {
  return this.source.length();
};


mx.collections.XMLListAdapter.prototype.get__source = function() {
  return this.mx_collections_XMLListAdapter__source;
};


mx.collections.XMLListAdapter.prototype.set__source = function(s) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  if (this.mx_collections_XMLListAdapter__source && this.mx_collections_XMLListAdapter__source.length()) {
    len = this.mx_collections_XMLListAdapter__source.length();
    for (i = 0; i < len; i++) {
      this.stopTrackUpdates(this.mx_collections_XMLListAdapter__source[i]);
    }
  }
  this.mx_collections_XMLListAdapter__source = s ? s : new XMLList();
  this.mx_collections_XMLListAdapter_seedUID = org.apache.royale.utils.UIDUtil.createUID();
  this.mx_collections_XMLListAdapter_uidCounter = 0;
  len = this.mx_collections_XMLListAdapter__source.length();
  for (i = 0; i < len; i++) {
    this.startTrackUpdates(this.mx_collections_XMLListAdapter__source[i], this.mx_collections_XMLListAdapter_seedUID + this.mx_collections_XMLListAdapter_uidCounter.toString());
    this.mx_collections_XMLListAdapter_uidCounter++;
  }
  if (this.mx_collections_XMLListAdapter__dispatchEvents == 0) {
    var /** @type {mx.events.CollectionEvent} */ event = new mx.events.CollectionEvent(mx.events.CollectionEvent.COLLECTION_CHANGE);
    event.kind = mx.events.CollectionEventKind.RESET;
    this.dispatchEvent(event);
  }
};


Object.defineProperties(mx.collections.XMLListAdapter.prototype, /** @lends {mx.collections.XMLListAdapter.prototype} */ {
/**
  * @export
  * @type {number} */
length: {
get: mx.collections.XMLListAdapter.prototype.get__length},
/**
  * @export
  * @type {XMLList} */
source: {
get: mx.collections.XMLListAdapter.prototype.get__source,
set: mx.collections.XMLListAdapter.prototype.set__source}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.collections.XMLListAdapter.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'XMLListAdapter', qName: 'mx.collections.XMLListAdapter', kind: 'class' }], interfaces: [mx.collections.IList, mx.utils.IXMLNotifiable] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.collections.XMLListAdapter.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'length': { type: 'int', access: 'readonly', declaredBy: 'mx.collections.XMLListAdapter'},
        'source': { type: 'XMLList', access: 'readwrite', declaredBy: 'mx.collections.XMLListAdapter'}
      };
    },
    methods: function () {
      return {
        'XMLListAdapter': { type: '', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'XMLList', true ]; }},
        'addItem': { type: 'void', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ]; }},
        'addItemAt': { type: 'void', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ,'int', false ]; }},
        'getItemAt': { type: 'Object', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'int', false ,'int', true ]; }},
        'getItemIndex': { type: 'int', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ]; }},
        'itemUpdated': { type: 'void', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ,'Object', true ,'Object', true ,'Object', true ]; }},
        'removeAll': { type: 'void', declaredBy: 'mx.collections.XMLListAdapter'},
        'removeItem': { type: 'Boolean', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ]; }},
        'removeItemAt': { type: 'Object', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'int', false ]; }},
        'setItemAt': { type: 'Object', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ,'int', false ]; }},
        'toArray': { type: 'Array', declaredBy: 'mx.collections.XMLListAdapter'},
        'toString': { type: 'String', declaredBy: 'mx.collections.XMLListAdapter'},
        'busy': { type: 'Boolean', declaredBy: 'mx.collections.XMLListAdapter'},
        'xmlNotification': { type: 'void', declaredBy: 'mx.collections.XMLListAdapter', parameters: function () { return [ 'Object', false ,'String', false ,'Object', false ,'Object', false ,'Object', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.collections.XMLListAdapter.prototype.ROYALE_COMPILE_FLAGS = 26;
