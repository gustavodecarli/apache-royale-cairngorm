/**
 * Generated by Apache Royale Compiler from mx/rpc/xml/XMLEncoder.as
 * mx.rpc.xml.XMLEncoder
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.xml.XMLEncoder');
/* Royale Dependency List: Namespace,QName,XML,XMLList,mx.collections.IList,mx.messaging.config.LoaderConfig,mx.rpc.xml.IXMLSchemaInstance,mx.rpc.xml.TypeIterator,mx.utils.ObjectProxy,mx.utils.ObjectUtil,mx.utils.object_proxy,org.apache.royale.utils.Language*/

goog.require('mx.rpc.xml.SchemaProcessor');
goog.require('mx.rpc.xml.IXMLEncoder');



/**
 * @constructor
 * @extends {mx.rpc.xml.SchemaProcessor}
 * @implements {mx.rpc.xml.IXMLEncoder}
 */
mx.rpc.xml.XMLEncoder = function() {
  
  this.mx_rpc_xml_XMLEncoder__xmlSpecialCharsFilter = org.apache.royale.utils.Language.closure(this.mx_rpc_xml_XMLEncoder_escapeXML, this, 'escapeXML');
  mx.rpc.xml.XMLEncoder.base(this, 'constructor');
  if (mx.messaging.config.LoaderConfig["swfVersion"] >= 10) {
    this.mx_rpc_xml_XMLEncoder__escapeXMLChars = false;
  }
};
goog.inherits(mx.rpc.xml.XMLEncoder, mx.rpc.xml.SchemaProcessor);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.xml.XMLEncoder', mx.rpc.xml.XMLEncoder);


/**
 * Encodes an ActionScript value as XML.
 * 
 * @asparam value The ActionScript value to encode as XML.
 * @asparam name The QName of an XML Schema <code>element</code> that
 * describes how to encode the value, or the name to be used for the
 * encoded XML node when a type parameter is also specified.
 * @asparam type The QName of an XML Schema <code>simpleType</code> or
 * <code>complexType</code> definition that describes how to encode the
 * @asparam definition If neither a top level element nor type exists in the
 * schema to describe how to encode this value, a custom element definition
 * can be provided.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} value
 * @param {QName=} name
 * @param {QName=} type
 * @param {XML=} definition
 * @return {XMLList}
 */
mx.rpc.xml.XMLEncoder.prototype.encode = function(value, name, type, definition) {
  name = typeof name !== 'undefined' ? name : null;
  type = typeof type !== 'undefined' ? type : null;
  definition = typeof definition !== 'undefined' ? definition : null;
  var /** @type {XMLList} */ result = new XMLList();
  var /** @type {XML} */ content;
  if (name == null)
    name = new QName("", "root");
  if (type != null) {
    content = this.encodeXSINil(null, name, value);
    if (content == null) {
      content = this.createElement(name);
      if (value == null)
        this.setValue(content, null);
      else
        this.encodeType(type, content, name, value);
    }
  } else {
    var /** @type {XML} */ elementDefinition = definition;
    var /** @type {boolean} */ mustReleaseScope = false;
    if (elementDefinition == null) {
      elementDefinition = this.schemaManager.getNamedDefinition(name, this.constants.elementTypeQName);
      if (elementDefinition != null)
        mustReleaseScope = true;
    }
    content = this.encodeElementTopLevel(elementDefinition, name, value);
    if (mustReleaseScope)
      this.schemaManager.releaseScope();
  }
  if (content != null)
    result = result.plus(content);
  return result;
};


/**
 * All content:
 *     (annotation?, (element | any)*)
 * 
 * FIXME: This needs work, right now it treats all as a sequence.
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XMLList} parent
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeAll = function(definition, parent, name, value, isRequired) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  return this.encodeSequence(definition, parent, name, value, isRequired);
};


/**
 * Encodes any complex object values as attributes using the XML schema
 * rules for attribute wildcards.
 * 
 * FIXME: This needs further investigation of the XML schema spec for
 * wildcard rules and constraints.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*=} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeAnyAttribute = function(definition, parent, name, value, restriction) {
  value = typeof value !== 'undefined' ? value : undefined;
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  if (value !== undefined) {
    if (!this.isSimpleValue(value) && !org.apache.royale.utils.Language.is(value, Array)) {
      for (var /** @type {Object} */ propertyName in this.getProperties(value)) {
        if (!this.hasAttribute(value, propertyName) && !this.hasValue(value, propertyName)) {
          var /** @type {*} */ attributeValue = this.getAttribute(value, propertyName);
          if (attributeValue != null)
            this.setAttribute(parent, propertyName, attributeValue);
        }
      }
    }
  }
};


/**
 * Encodes elements based on wildcard rules.
 * 
 * Any content:
 *    (annotation?)
 * @asprivate
 * 
 * @export
 * @param {XML} definition
 * @param {XMLList} siblings
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @param {Array=} encodedVals
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeAnyElement = function(definition, siblings, name, value, isRequired, encodedVals) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  encodedVals = typeof encodedVals !== 'undefined' ? encodedVals : null;
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (this.isSimpleValue(value)) {
    var /** @type {XML} */ item = this.createElement(name);
    this.setValue(item, value);
    this.appendValue(siblings, item);
  } else if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList)) {
    this.appendValue(siblings, value);
  } else {
    if (encodedVals == null)
      encodedVals = [];
    if (!org.apache.royale.utils.Language.is(value, QName)) {
      if (encodedVals.indexOf(value) != -1)
        throw new Error("Cannot encode complex structure. Cyclic references detected.");
      encodedVals.push(value);
    }
    if (org.apache.royale.utils.Language.is(value, Array) || org.apache.royale.utils.Language.is(value, mx.collections.IList)) {
      if (org.apache.royale.utils.Language.is(value, mx.collections.IList))
        value = org.apache.royale.utils.Language.as(value, mx.collections.IList, true).toArray();
      var foreachiter0_target = org.apache.royale.utils.Language.as(value, Array);
      for (var foreachiter0 in foreachiter0_target) 
      {
      var arrValue = foreachiter0_target[foreachiter0];
      {
        var /** @type {*} */ arrayItem = this.createElement(name);
        if (arrValue == null) {
          this.setValue(arrayItem, null);
        } else if (arrValue != null) {
          var /** @type {XMLList} */ arrayChildren = new XMLList();
          this.encodeAnyElement(definition, arrayChildren, name, arrValue, isRequired, encodedVals);
          if (this.isSimpleValue(arrValue)) {
            arrayItem = arrayChildren[0];
          } else {
            this.setValue(arrayItem, arrayChildren);
          }
        }
        this.appendValue(siblings, arrayItem);
      }}
      
    } else {
      var foreachiter1_target = this.getProperties(value);
      for (var foreachiter1 in foreachiter1_target) 
      {
      var objProperty = foreachiter1_target[foreachiter1];
      {
        var /** @type {*} */ propValue = this.getValue(value, objProperty);
        var /** @type {QName} */ propQName = new QName(name.uri, objProperty);
        if (!this.containsNodeByName(siblings, propQName)) {
          var /** @type {XML} */ propItem = this.encodeXSINil(definition, propQName, propValue);
          if (propItem != null) {
            this.appendValue(siblings, propItem);
          } else if (propValue != null) {
            var /** @type {XMLList} */ propChildren = new XMLList();
            this.encodeAnyElement(definition, propChildren, propQName, propValue, isRequired, encodedVals);
            this.appendValue(siblings, propChildren);
          }
        }
      }}
      
    }
    var /** @type {number} */ index = (encodedVals.indexOf(value)) >> 0;
    if (index != -1)
      encodedVals.splice(index, 1);
  }
  return true;
};


/**
 * An attribute must be based on a simple type and thus will have simple
 * content encoded as a String.
 *
 * This function is used to encode an <code>attribute</code> that may be
 * named and registered as a top-level <code>schema</code> definition or
 * in-line from a <code>complexType</code>, <code>extension</code> or
 * <restriction> of either a <code>complexType</code> or
 * <code>simpleType</code>, or <code>attributeGroup</code>
 * definition in any aforementioned parent component.
 * 
 * If the <code>attribute</code> points to a named definition using a 
 * <code>ref</code> attribute, the reference is resolved to provide the
 * real definition of the attribute. If the reference cannot be resolved,
 * an error is thrown.
 * 
 * If the attribute defines a <code>fixed</code> constraint then any value
 * provided is ignored and the fixed value is used instead. If a value is
 * not provided and the attribute defines a <code>default</code>, the
 * default is used for the encoded attribute. Otherwise if an attribute is
 * marked as <code>optional</code> and a value is not provided it will be
 * skipped.
 *
 * @asparam parent The parent instance to which these attributes will be added.
 * @asparam definition The XML schema definition of the attribute.
 * @asparam value An object with a property name that matches the resolved
 * attribute name. The property value will be used as the encoded attribute
 * value.
 * 
 * FIXME: Attributes are expected to be simple values and must be ultimately
 * representable as a String. If a complex value is passed to this method
 * should we assume that we're always looking for a property with the same
 * name as the attribute? We may need to because if we have a ref then the
 * name is not known immediately...
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*=} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeAttribute = function(definition, parent, name, value, restriction) {
  value = typeof value !== 'undefined' ? value : undefined;
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.attributeQName);
    if (definition == null)
      throw new Error("Cannot resolve attribute definition for '" + ref + "'");
  }
  var /** @type {string} */ attributeNameString = definition.attribute('name').toString();
  var /** @type {string} */ attributeUse = definition.attribute("use").toString();
  if (attributeUse != "prohibited") {
    var /** @type {QName} */ attributeName = this.schemaManager.getQNameForAttribute(attributeNameString, this.getAttributeFromNode("form", definition));
    var /** @type {string} */ attributeFixed = this.getAttributeFromNode("fixed", definition);
    if (attributeFixed != null) {
      value = attributeFixed;
    } else {
      value = this.getValue(value, attributeName);
      if (value === undefined) {
        var /** @type {string} */ attributeDefault = this.getAttributeFromNode("default", definition);
        if (attributeDefault != null)
          value = attributeDefault;
      }
    }
    var /** @type {*} */ tempElement;
    var /** @type {boolean} */ attributeFound;
    if (value !== undefined) {
      var /** @type {XML} */ typeDefinition;
      tempElement = new XML( '<temp/>');
      var /** @type {string} */ typeName = this.getAttributeFromNode("type", definition);
      var /** @type {QName} */ attributeType;
      if (typeName != null)
        attributeType = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('type')), definition);
      else
        attributeType = this.schemaManager.schemaDatatypes.anySimpleTypeQName;
      if (attributeType != null) {
        if (this.isBuiltInType(attributeType)) {
          tempElement.appendChild(this.schemaManager.marshall(value, attributeType, restriction));
        } else {
          typeDefinition = this.schemaManager.getNamedDefinition(attributeType, this.constants.simpleTypeQName);
          if (typeDefinition != null)
            this.encodeSimpleType(typeDefinition, tempElement, attributeName, value, restriction);
          else
            throw new Error("Cannot find simpleType " + attributeType + " for attribute " + attributeName);
          this.schemaManager.releaseScope();
        }
      } else {
        typeDefinition = this.getSingleElementFromNode(definition, this.constants.simpleTypeQName);
        if (typeDefinition != null) {
          this.encodeSimpleType(typeDefinition, tempElement, attributeName, value, restriction);
        } else if (value != null) {
          tempElement.appendChild(value.toString());
        }
      }
    }
    if (tempElement !== undefined) {
      this.setAttribute(parent, attributeName, tempElement);
    }
  }
  if (ref != null)
    this.schemaManager.releaseScope();
};


/**
 * An <code>attributeGroup</code> definition may include a number of
 * <code>attribute</code> or <code>attributeGroup</code> children, all of
 * which ultimately combine to form a flat group of attributes for some
 * type. It may also specify <code>anyAttribute</code> which expands
 * the definition to accept attributes based on more general criteria
 * (such excluding or including attributes on namespace).
 *
 * This function is used to encode an <code>attributeGroup</code> that may 
 * be named and registered as a top-level <code>schema</code> definition or
 * in-line from a <code>complexType</code>, <code>extension</code> or
 * <restriction> of either a <code>complexType</code> or
 * <code>simpleType</code>, or even another <code>attributeGroup</code>
 * definition in any aforementioned parent component.
 * 
 * If the <code>attributeGroup</code> points to a named definition using a
 * ref attribute, the reference is resolved to provide the real definition
 * of the attributeGroup. If the reference cannot be resolved, an error is
 * thrown.
 * 
 * @asparam parent The parent instance to which these attributes will be added.
 * @asparam definition The XML schema definition of the attributeGroup.
 * @asparam value An object with property names that match the resolved
 * attribute names in the group. The property values will be used as the
 * encoded attribute values. This argument may be omitted if each attribute
 * in the group has a fixed or default value.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*=} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeAttributeGroup = function(definition, parent, name, value, restriction) {
  value = typeof value !== 'undefined' ? value : undefined;
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.attributeGroupQName);
    if (definition == null)
      throw new Error("Cannot resolve attributeGroup definition for '" + ref + "'");
  }
  var /** @type {XMLList} */ attributes = definition.elements(this.constants.attributeQName);
  var foreachiter2_target = attributes;
  for (var foreachiter2 in foreachiter2_target.elementNames()) 
  {
  var attributeDefinition = foreachiter2_target[foreachiter2];
  {
    this.encodeAttribute(attributeDefinition, parent, name, value, restriction);
  }}
  
  var /** @type {XMLList} */ attributeGroups = definition.elements(this.constants.attributeGroupQName);
  var foreachiter3_target = attributeGroups;
  for (var foreachiter3 in foreachiter3_target.elementNames()) 
  {
  var attributeGroup = foreachiter3_target[foreachiter3];
  {
    this.encodeAttributeGroup(attributeGroup, parent, name, value, restriction);
  }}
  
  var /** @type {XML} */ anyAttribute = this.getSingleElementFromNode(definition, this.constants.anyAttributeQName);
  if (anyAttribute != null) {
    this.encodeAnyAttribute(anyAttribute, parent, name, value, restriction);
  }
  if (ref != null)
    this.schemaManager.releaseScope();
};


/**
 * choice:
 *    (annotation?, (element | group | choice | sequence | any)*)
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XMLList} parent
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeChoice = function(definition, parent, name, value, isRequired) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {number} */ choiceOccurs = 0;
  var /** @type {number} */ lastIndex = 0;
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (maxOccurs == 0)
    return false;
  if (value == null && minOccurs == 0)
    return true;
  var /** @type {XMLList} */ choiceElements = definition.elements();
  var /** @type {boolean} */ choiceSatisfied = true;
  //var /** @type {number} */ lastIndex = 0;
  //var /** @type {number} */ choiceOccurs = 0;
  if (choiceElements.length() > 0)
    choiceSatisfied = false;
  var foreachiter4_target = choiceElements;
  for (var foreachiter4 in foreachiter4_target.elementNames()) 
  {
  var childDefinition = foreachiter4_target[foreachiter4];
  {
    if (QName.equality(childDefinition.name(),this.constants.elementTypeQName)) {
      choiceSatisfied = this.encodeGroupElement(childDefinition, parent, name, value, false) || choiceSatisfied;
    } else if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      choiceSatisfied = this.encodeSequence(childDefinition, parent, name, value, false) || choiceSatisfied;
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      choiceSatisfied = this.encodeGroupReference(childDefinition, parent, name, value, false) || choiceSatisfied;
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      choiceSatisfied = this.encodeChoice(childDefinition, parent, name, value, false) || choiceSatisfied;
    } else if (QName.equality(childDefinition.name(),this.constants.anyQName)) {
      choiceSatisfied = this.encodeAnyElement(childDefinition, parent, name, value, false) || choiceSatisfied;
    }
  }}
  
  return choiceSatisfied;
};


/**
 * Derivation by restriction takes an existing type as the base and creates
 * a new type by limiting its allowed content to a subset of that allowed
 * by the base type. Derivation by extension takes an existing type as the
 * base and creates a new type by adding to its allowed content.
 * 
 * complexContent:
 * (annotation?, (restriction | extension))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.encodeComplexContent = function(definition, parent, name, value) {
  var /** @type {XML} */ childDefinition = this.getSingleElementFromNode(definition, this.constants.extensionQName, this.constants.restrictionQName);
  if (QName.equality(childDefinition.name(),this.constants.extensionQName)) {
    this.encodeComplexExtension(childDefinition, parent, name, value);
  } else if (QName.equality(childDefinition.name(),this.constants.restrictionQName)) {
    this.encodeComplexRestriction(childDefinition, parent, name, value);
  }
};


/**    
 * complexContent:
 *   extension:
 *     (annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), (assert | report)*))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.encodeComplexExtension = function(definition, parent, name, value) {
  var /** @type {string} */ baseName = this.getAttributeFromNode("base", definition);
  if (baseName == null)
    throw new Error("A complexContent extension must declare a base type.");
  var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, definition);
  var /** @type {XML} */ baseDefinition = this.schemaManager.getNamedDefinition(baseType, this.constants.complexTypeQName);
  if (baseDefinition == null)
    throw new Error("Cannot find base type definition '" + baseType + "'");
  this.encodeComplexType(baseDefinition, parent, name, value);
  this.schemaManager.releaseScope();
  var /** @type {XMLList} */ childDefinitions = definition.elements();
  var /** @type {XMLList} */ extChildren = new XMLList();
  var foreachiter5_target = childDefinitions;
  for (var foreachiter5 in foreachiter5_target.elementNames()) 
  {
  var childDefinition = foreachiter5_target[foreachiter5];
  {
    if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      this.encodeSequence(childDefinition, extChildren, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      this.encodeGroupReference(childDefinition, extChildren, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      this.encodeAll(childDefinition, extChildren, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      this.encodeChoice(childDefinition, extChildren, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeQName)) {
      this.encodeAttribute(childDefinition, parent, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeGroupQName)) {
      this.encodeAttributeGroup(childDefinition, parent, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.anyAttributeQName)) {
      this.encodeAnyAttribute(childDefinition, parent, name, value);
    }
  }}
  
  var foreachiter6_target = extChildren;
  for (var foreachiter6 in foreachiter6_target.elementNames()) 
  {
  var extension = foreachiter6_target[foreachiter6];
  {
    parent.removeChild(extension.name());
    parent.removeChild(new QName("", extension.name().localName));
    parent.removeChild(new QName(null, extension.name().localName));
  }}
  
  this.setValue(parent, extChildren);
};


/**    
 * complexContent:
 *   restriction:
 *     (annotation?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), (assert | report)*)
 * 
 * @asprivate
 * @export
 * @param {XML} restriction
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.encodeComplexRestriction = function(restriction, parent, name, value) {
  var /** @type {string} */ baseName = this.getAttributeFromNode("base", restriction);
  if (baseName == null)
    throw new Error("A complexContent restriction must declare a base type.");
  var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, restriction);
  var /** @type {XMLList} */ childDefinitions = restriction.elements();
  var /** @type {XMLList} */ children = parent.elements();
  var foreachiter7_target = childDefinitions;
  for (var foreachiter7 in foreachiter7_target.elementNames()) 
  {
  var childDefinition = foreachiter7_target[foreachiter7];
  {
    if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      this.encodeSequence(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      this.encodeGroupReference(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      this.encodeAll(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      this.encodeChoice(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeQName)) {
      this.encodeAttribute(childDefinition, parent, name, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeGroupQName)) {
      this.encodeAttributeGroup(childDefinition, parent, name, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.anyAttributeQName)) {
      this.encodeAnyAttribute(childDefinition, parent, name, value, restriction);
    }
  }}
  
  parent.setChildren(children);
};


/**
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeComplexType = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {XMLList} */ childElements = definition.elements();
  var /** @type {XMLList} */ children = new XMLList();
  var foreachiter8_target = childElements;
  for (var foreachiter8 in foreachiter8_target.elementNames()) 
  {
  var childDefinition = foreachiter8_target[foreachiter8];
  {
    if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      this.encodeSequence(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.simpleContentQName)) {
      this.encodeSimpleContent(childDefinition, parent, name, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.complexContentQName)) {
      this.encodeComplexContent(childDefinition, parent, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      this.encodeGroupReference(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      this.encodeAll(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      this.encodeChoice(childDefinition, children, name, value);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeQName)) {
      this.encodeAttribute(childDefinition, parent, name, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeGroupQName)) {
      this.encodeAttributeGroup(childDefinition, parent, name, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.anyAttributeQName)) {
      this.encodeAnyAttribute(childDefinition, parent, name, value, restriction);
    }
  }}
  
  this.setValue(parent, children);
};


/**
 * Used to encode a local element definition (inside a model group).
 * Handles restrictions on omittability and occurence counts in the
 * context of the parent model group.
 * Delegates actual encoding to encodeElementTopLevel once all the
 * context around the element is known.
 * 
 * @asparam definition The XML Schema definition of the local element.
 * @asparam parent The XMLList of values encoded in the current level. The
 * new encoded node should be appended to this XMLList.
 * @asparam name The QName to be used for the encoded XML node.
 * @asparam value The ActionScript value to encode as XML.
 * @asparam isRequired A flag indicating wether the element should meet
 * its local occurence bounds. For example, the local element may have
 * minOccurs=1, but be only one of many elements in a choice group, in
 * which case it is valid not to satisfy the minOccurs requirement.
 * 
 * @asreturn Wether or not the value provided 
 * 
 * FIXME: Support substitutionGroup, block and redefine?
 * FIXME: Do we care about abstract or final?
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XMLList} siblings
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeGroupElement = function(definition, siblings, name, value, isRequired) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (maxOccurs == 0)
    return true;
  isRequired = isRequired && minOccurs > 0;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.elementTypeQName);
    if (definition == null)
      throw new Error("Cannot resolve element definition for ref '" + ref + "'");
  }
  var /** @type {string} */ elementName = definition.attribute('name').toString();
  var /** @type {QName} */ elementQName = this.schemaManager.getQNameForElement(elementName, this.getAttributeFromNode("form", definition));
  var /** @type {*} */ elementValue = this.getValue(value, elementQName);
  var /** @type {XML} */ encodedElement;
  if (elementValue == null) {
    encodedElement = this.encodeElementTopLevel(definition, elementQName, elementValue);
    if (encodedElement != null)
      this.appendValue(siblings, encodedElement);
    if (ref != null)
      this.schemaManager.releaseScope();
    if (isRequired && encodedElement == null)
      return false;
    return true;
  }
  if (maxOccurs == 1) {
    encodedElement = this.encodeElementTopLevel(definition, elementQName, elementValue);
    if (encodedElement != null) {
      this.appendValue(siblings, encodedElement);
    }
  } else if (maxOccurs > 1) {
    var /** @type {number} */ valueOccurence = this.getValueOccurence(elementValue);
    if (valueOccurence < minOccurs) {
      throw new Error("Value supplied for element '" + elementQName + "' occurs " + valueOccurence + " times which falls short of minOccurs " + minOccurs + ".");
    }
    if (valueOccurence > maxOccurs) {
      throw new Error("Value supplied for element of type '" + elementQName + "' occurs " + valueOccurence + " times which exceeds maxOccurs " + maxOccurs + ".");
    }
    if (!mx.rpc.xml.TypeIterator.isIterable(elementValue))
      elementValue = [elementValue];
    var /** @type {mx.rpc.xml.TypeIterator} */ iter = new mx.rpc.xml.TypeIterator(elementValue);
    for (var /** @type {number} */ i = 0; i < maxOccurs && i < valueOccurence; i++) {
      var /** @type {*} */ item;
      if (iter.hasNext()) {
        item = iter.next();
      } else if (i > minOccurs) {
        break;
      }
      encodedElement = this.encodeElementTopLevel(definition, elementQName, item);
      if (encodedElement == null) {
        encodedElement = this.createElement(elementQName);
        this.setValue(encodedElement, null);
      }
      this.appendValue(siblings, encodedElement);
    }
  }
  if (ref != null)
    this.schemaManager.releaseScope();
  return true;
};


/**
 * Element content:
 * (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {QName} elementQName
 * @param {*} value
 * @return {XML}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeElementTopLevel = function(definition, elementQName, value) {
  var /** @type {XML} */ element = this.encodeXSINil(definition, elementQName, value);
  if (element != null)
    return element;
  else if (value == null)
    return null;
  element = this.createElement(elementQName);
  var /** @type {string} */ typeAttribute = this.getAttributeFromNode("type", definition);
  if (typeAttribute != null) {
    var /** @type {QName} */ typeQName = this.schemaManager.getQNameForPrefixedName(typeAttribute, definition);
    this.encodeType(typeQName, element, elementQName, value);
  } else if (definition != null && definition.hasComplexContent()) {
    var /** @type {XML} */ typeDefinition = this.getSingleElementFromNode(definition, this.constants.complexTypeQName, this.constants.simpleTypeQName);
    if (QName.equality(typeDefinition.name(),this.constants.complexTypeQName)) {
      this.encodeComplexType(typeDefinition, element, elementQName, value);
    } else if (QName.equality(typeDefinition.name(),this.constants.simpleTypeQName)) {
      this.encodeSimpleType(typeDefinition, element, elementQName, value);
    }
  } else {
    this.encodeType(this.constants.anyTypeQName, element, elementQName, value);
  }
  return element;
};


/**
 * The <code>group</code> element allows partial (or complete) content
 * models to be reused in complex types. When used inside a choice,
 * sequence, complexType, extension or restriction element, it must 
 * have a ref attribute, specifying the name of a global definition
 * of a named model group.
 * 
 * group:
 * (annotation?, (all | choice | sequence)?)
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XMLList} parent
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeGroupReference = function(definition, parent, name, value, isRequired) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.groupQName);
    if (definition == null)
      throw new Error("Cannot resolve group definition for '" + ref + "'");
  } else {
    throw new Error("A group reference element must have the ref attribute");
  }
  var /** @type {XMLList} */ groupElements = definition.elements();
  var /** @type {boolean} */ groupSatisfied = false;
  var foreachiter9_target = groupElements;
  for (var foreachiter9 in foreachiter9_target.elementNames()) 
  {
  var childDefinition = foreachiter9_target[foreachiter9];
  {
    if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      groupSatisfied = this.encodeSequence(childDefinition, parent, name, value, isRequired);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      groupSatisfied = this.encodeAll(childDefinition, parent, name, value, isRequired);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      groupSatisfied = this.encodeChoice(childDefinition, parent, name, value, isRequired);
    }
  }}
  
  this.schemaManager.releaseScope();
  return groupSatisfied;
};


/**
 * sequence:
 *    (annotation?, (element | group | choice | sequence | any)*)
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XMLList} siblings
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeSequence = function(definition, siblings, name, value, isRequired) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (maxOccurs == 0)
    return true;
  if (value == null && minOccurs == 0)
    return true;
  var /** @type {XMLList} */ sequenceElements = definition.elements();
  var /** @type {boolean} */ requireChild = isRequired && minOccurs > 0;
  var /** @type {boolean} */ sequenceSatisfied = true;
  var foreachiter10_target = sequenceElements;
  for (var foreachiter10 in foreachiter10_target.elementNames()) 
  {
  var childDefinition = foreachiter10_target[foreachiter10];
  {
    sequenceSatisfied = false;
    if (QName.equality(childDefinition.name(),this.constants.elementTypeQName)) {
      if (!this.encodeGroupElement(childDefinition, siblings, name, value, isRequired))
        break;
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      if (!this.encodeGroupReference(childDefinition, siblings, name, value, isRequired))
        break;
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      if (!this.encodeChoice(childDefinition, siblings, name, value, isRequired))
        break;
    } else if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      if (!this.encodeSequence(childDefinition, siblings, name, value, isRequired))
        break;
    } else if (QName.equality(childDefinition.name(),this.constants.anyQName)) {
      if (!this.encodeAnyElement(childDefinition, siblings, name, value, isRequired))
        break;
    }
    sequenceSatisfied = true;
  }}
  
  return sequenceSatisfied || !isRequired;
};


/**
 * <code>simpleContent</code> specifies that the content will be simple text
 * only, that is it conforms to a simple type and will not contain elements,
 * although it may also define attributes.
 * 
 * A simpleContent must be defined with an extension or a restriction. An
 * extension specifies the attribute definitions that are to be added to the
 * type and the base attribute specifies from which simple data type this
 * custom type is defined. A restriction for simpleContent is less common,
 * although it may be used to prohibit attributes in derived types also
 * with simpleContent.
 * 
 * simpleContent
 *     (annotation?, (restriction | extension))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeSimpleContent = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {XML} */ childDefinition = this.getSingleElementFromNode(definition, this.constants.extensionQName, this.constants.restrictionQName);
  if (childDefinition != null) {
    var /** @type {string} */ baseName = this.getAttributeFromNode("base", childDefinition);
    if (baseName == null)
      throw new Error("A simpleContent extension or restriction must declare a base type.");
    var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, childDefinition);
    if (!this.isBuiltInType(baseType)) {
      var /** @type {XML} */ baseDefinition = this.schemaManager.getNamedDefinition(baseType, this.constants.complexTypeQName, this.constants.simpleTypeQName);
      if (baseDefinition == null)
        throw new Error("Cannot find base type definition '" + baseType + "'");
      this.schemaManager.releaseScope();
    }
    var /** @type {*} */ simpleValue;
    if (QName.equality(childDefinition.name(),this.constants.extensionQName)) {
      if (this.isBuiltInType(baseType)) {
        simpleValue = this.getSimpleValue(value, name);
        this.setValue(parent, this.schemaManager.marshall(simpleValue, baseType, restriction));
      } else {
        this.encodeType(baseType, parent, value, restriction);
      }
      var /** @type {XMLList} */ extensions = childDefinition.elements();
      var foreachiter11_target = extensions;
      for (var foreachiter11 in foreachiter11_target.elementNames()) 
      {
      var extensionChild = foreachiter11_target[foreachiter11];
      {
        if (QName.equality(extensionChild.name(),this.constants.attributeQName)) {
          this.encodeAttribute(extensionChild, parent, name, value, restriction);
        } else if (QName.equality(extensionChild.name(),this.constants.attributeGroupQName)) {
          this.encodeAttributeGroup(extensionChild, parent, name, value, restriction);
        } else if (QName.equality(extensionChild.name(),this.constants.anyAttributeQName)) {
          this.encodeAnyAttribute(extensionChild, parent, name, value, restriction);
        }
      }}
      
    } else if (QName.equality(childDefinition.name(),this.constants.restrictionQName)) {
      simpleValue = this.getSimpleValue(value, name);
      this.encodeSimpleRestriction(childDefinition, parent, name, simpleValue);
    }
  }
};


/**
 * A <code>simpleType</code> may declare a list of space separated
 * simple content for a single value.
 * 
 * <list
 *     id = ID
 *     itemType = QName >
 *     Content: (annotation?, simpleType?)
 * </list>
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeSimpleList = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {string} */ itemTypeAttribute = org.apache.royale.utils.Language.string(definition.attribute('itemType'));
  var /** @type {QName} */ itemTypeQName;
  var /** @type {XML} */ itemDefinition;
  if (itemTypeAttribute != "")
    itemTypeQName = this.schemaManager.getQNameForPrefixedName(itemTypeAttribute, definition);
  else
    itemDefinition = this.getSingleElementFromNode(definition, this.constants.simpleTypeQName);
  var /** @type {string} */ listValue = "";
  if (!mx.rpc.xml.TypeIterator.isIterable(value))
    value = [value];
  var /** @type {mx.rpc.xml.TypeIterator} */ iter = new mx.rpc.xml.TypeIterator(value);
  while (iter.hasNext()) {
    var /** @type {*} */ item = iter.next();
    var /** @type {*} */ tempElement = new XML( '<temp/>');
    if (item == null)
      continue;
    if (itemTypeQName != null)
      this.encodeType(itemTypeQName, tempElement, name, item, restriction);
    else
      this.encodeSimpleType(itemDefinition, tempElement, name, item, restriction);
    listValue = listValue.concat(tempElement.toString());
    if (iter.hasNext())
      listValue = listValue.concat(" ");
  }
  this.setValue(parent, listValue);
};


/**
 * simpleType:
 *   restriction: (annotation?, (simpleType?,
 *       (minExclusive | minInclusive | maxExclusive | maxInclusive |
 *       totalDigits | fractionDigits | maxScale | minScale | length |
 *       minLength | maxLength | enumeration | whiteSpace | pattern)*))
 * 
 * @asprivate
 * @export
 * @param {XML} restriction
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.encodeSimpleRestriction = function(restriction, parent, name, value) {
  var /** @type {XML} */ simpleTypeDefinition = this.getSingleElementFromNode(restriction, this.constants.simpleTypeQName);
  if (simpleTypeDefinition != null) {
    this.encodeSimpleType(simpleTypeDefinition, parent, name, value, restriction);
  } else {
    var /** @type {string} */ baseName = this.getAttributeFromNode("base", restriction);
    var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, restriction);
    this.encodeType(baseType, parent, name, value, restriction);
  }
};


/**
 * <simpleType
 *     final = (#all | List of (list | union | restriction | extension))
 *     id = ID
 *     name = NCName>
 *     Content: (annotation?, (restriction | list | union))
 * </simpleType>
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeSimpleType = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {XML} */ definitionChild = this.getSingleElementFromNode(definition, this.constants.restrictionQName, this.constants.listQName, this.constants.unionQName);
  if (QName.equality(definitionChild.name(),this.constants.restrictionQName)) {
    this.encodeSimpleRestriction(definitionChild, parent, name, value);
  } else if (QName.equality(definitionChild.name(),this.constants.listQName)) {
    this.encodeSimpleList(definitionChild, parent, name, value, restriction);
  } else if (QName.equality(definitionChild.name(),this.constants.unionQName)) {
    this.encodeSimpleUnion(definitionChild, parent, name, value, restriction);
  }
};


/**
 * <union
 *     id = ID
 *     memberTypes = List of QName >
 *     Content: (annotation?, simpleType*)
 * </union>
 * 
 * FIXME: This needs a lot of work.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeSimpleUnion = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {string} */ memberList = this.getAttributeFromNode("memberTypes", definition);
  var /** @type {Array} */ memberArray = memberList.split(" ");
  var /** @type {QName} */ type;
  var /** @type {*} */ args;
  for (var /** @type {number} */ i = 0; i < memberArray.length; i++) {
    var /** @type {string} */ prefixedName = org.apache.royale.utils.Language.string(memberArray[i]);
    var /** @type {QName} */ simpleType = this.schemaManager.getQNameForPrefixedName(prefixedName, definition);
    if (!this.isBuiltInType(simpleType)) {
      args = this.getValue(value, simpleType);
      if (args !== undefined) {
        type = simpleType;
        break;
      }
    }
  }
  if (!type) {
    type = this.schemaManager.schemaDatatypes.stringQName;
  }
  this.setValue(parent, this.schemaManager.marshall(value, type, restriction));
};


/**
 * Allow instance specific overrides for concrete type information as
 * abstract complexTypes may require a concrete xsi:type definition.
 * 
 * @asparam parent A reference to the parent XML. Must not be null.
 *
 * @asprivate
 * @export
 * @param {QName} type
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLEncoder.prototype.encodeType = function(type, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {QName} */ xsiType = this.getXSIType(value);
  if (xsiType != null)
    type = xsiType;
  var /** @type {XML} */ definition = this.schemaManager.getNamedDefinition(type, this.constants.complexTypeQName, this.constants.simpleTypeQName);
  if (this.isBuiltInType(type)) {
    if (QName.equality(type,this.constants.anyTypeQName) && !this.isSimpleValue(value)) {
      var /** @type {XMLList} */ children = new XMLList();
      this.encodeAnyElement(definition, children, name, value);
      this.setValue(parent, children);
    } else {
      this.setValue(parent, this.schemaManager.marshall(value, type, restriction));
    }
    this.deriveXSIType(parent, type, value);
  } else {
    if (definition == null)
      throw new Error("Cannot find definition for type '" + type + "'");
    var /** @type {QName} */ definitionType = org.apache.royale.utils.Language.as(definition.name(), QName);
    if (QName.equality(definitionType,this.constants.complexTypeQName)) {
      this.encodeComplexType(definition, parent, name, value, restriction);
    } else if (QName.equality(definitionType,this.constants.simpleTypeQName)) {
      this.encodeSimpleType(definition, parent, name, value, restriction);
    } else {
      throw new Error("Invalid type definition " + definitionType);
    }
  }
  if (definition != null)
    this.schemaManager.releaseScope();
};


/**
 * Sets the xsi:nil attribute when necessary
 * 
 * @asparam definition The Schema definition of the expected type. If
 * nillable is strictly enforced, this definition must explicitly
 * specify nillable=true.
 * 
 * @asparam name The name of the element to be created
 * 
 * @asparam value The value to check
 * 
 * @asreturn content The element where xsi:nil was set, or null if xsi:nil was
 * not set.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {XML} definition
 * @param {QName} name
 * @param {*} value
 * @param {boolean=} isRequired
 * @return {XML}
 */
mx.rpc.xml.XMLEncoder.prototype.encodeXSINil = function(definition, name, value, isRequired) {
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {boolean} */ nillable = true;
  if (this.strictNillability) {
    if (definition != null)
      nillable = definition.attribute('nillable').toString() == "true" ? true : false;
    else
      nillable = false;
  }
  var /** @type {XML} */ item;
  var /** @type {string} */ fixedValue = this.getAttributeFromNode("fixed", definition);
  if (!(this.strictNillability && nillable) && fixedValue != null) {
    item = this.createElement(name);
    this.setValue(item, this.schemaManager.marshall(fixedValue, this.schemaManager.schemaDatatypes.stringQName));
    return item;
  }
  if (value != null)
    return null;
  var /** @type {string} */ defaultValue = this.getAttributeFromNode("default", definition);
  if (value == null && defaultValue != null) {
    item = this.createElement(name);
    this.setValue(item, this.schemaManager.marshall(defaultValue, this.schemaManager.schemaDatatypes.stringQName));
    return item;
  }
  if (nillable && value === null && isRequired == true) {
    item = this.createElement(name);
    this.setValue(item, null);
    return item;
  }
  return null;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {*}
 */
mx.rpc.xml.XMLEncoder.prototype.getAttribute = function(parent, name) {
  return this.getValue(parent, name);
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.hasAttribute = function(parent, name) {
  return (this.getAttribute(parent, name) !== undefined);
};


/**
 * @asprivate
 * @export
 * @param {XML} parent
 * @param {*} name
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.setAttribute = function(parent, name, value) {
  if (value != null)
    parent.setAttribute(name, value.toString());
};


/**
 * @asprivate
 * @export
 * @param {*} value
 * @return {Array}
 */
mx.rpc.xml.XMLEncoder.prototype.getProperties = function(value) {
  var /** @type {Object} */ classInfo = mx.utils.ObjectUtil.getClassInfo(org.apache.royale.utils.Language.as(value, Object), null, {includeReadOnly:false});
  return classInfo.properties;
};


/**
 * Returns a single XML node with the given name
 * 
 * @asprivate
 * @export
 * @param {*} name
 * @return {XML}
 */
mx.rpc.xml.XMLEncoder.prototype.createElement = function(name) {
  var /** @type {XML} */ element;
  var /** @type {QName} */ elementName;
  if (org.apache.royale.utils.Language.is(name, QName))
    elementName = org.apache.royale.utils.Language.as(name, QName);
  else
    elementName = new QName("", name.toString());
  element = new XML( '<' + elementName.localName + ' />');
  if (elementName.uri != null && elementName.uri.length > 0) {
    var /** @type {string} */ prefix = this.schemaManager.getOrCreatePrefix(elementName.uri);
    var /** @type {Namespace} */ ns = new Namespace(prefix, elementName.uri);
    element.setNamespace(ns);
  }
  return element;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {*}
 */
mx.rpc.xml.XMLEncoder.prototype.getSimpleValue = function(parent, name) {
  var /** @type {*} */ simpleValue = this.getValue(parent, name);
  if (simpleValue === undefined)
    simpleValue = this.getValue(parent, "_value");
  return simpleValue;
};


/**
 * Determines whether a value should be representable as a single, simple
 * value, otherwise the object is regarded as "complex" and contains
 * child values referenced by index or name.
 * 
 * @asprivate
 * @export
 * @param {*} value
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.isSimpleValue = function(value) {
  if (org.apache.royale.utils.Language.is(value, String) || org.apache.royale.utils.Language.is(value, Number) || org.apache.royale.utils.Language.is(value, Boolean) || org.apache.royale.utils.Language.is(value, Date) || org.apache.royale.utils.Language.is(value, org.apache.royale.utils.Language.synthType('int')) || org.apache.royale.utils.Language.is(value, org.apache.royale.utils.Language.synthType('uint'))) {
    return true;
  }
  return false;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {*}
 */
mx.rpc.xml.XMLEncoder.prototype.getValue = function(parent, name) {
  var /** @type {*} */ value;
  if (org.apache.royale.utils.Language.is(parent, XML) || org.apache.royale.utils.Language.is(parent, XMLList)) {
    var /** @type {XMLList} */ node = parent[name];
    if (node.length() > 0)
      value = node;
  } else if (mx.rpc.xml.TypeIterator.isIterable(parent)) {
    if (parent.hasOwnProperty(name) && parent[name] !== undefined) {
      value = this.resolveNamedProperty(parent, name);
    } else {
      value = parent;
    }
  } else if (!this.isSimpleValue(parent)) {
    if (org.apache.royale.utils.Language.is(name, QName))
      name = org.apache.royale.utils.Language.as(name, QName, true).localName;
    value = this.resolveNamedProperty(parent, name);
  } else {
    value = parent;
  }
  return value;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.hasValue = function(parent, name) {
  return (this.getValue(parent, name) !== undefined);
};


/**
 * @asprivate
 * @export
 * @param {XMLList} list
 * @param {QName} name
 * @param {boolean=} strict
 * @return {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.containsNodeByName = function(list, name, strict) {
  strict = typeof strict !== 'undefined' ? strict : false;
  var /** @type {string} */ currentURI = this.schemaManager.currentSchema.targetNamespace.uri;
  var foreachiter12_target = list;
  for (var foreachiter12 in foreachiter12_target.elementNames()) 
  {
  var node = foreachiter12_target[foreachiter12];
  {
    if (strict || (name.uri != "" && name.uri != null)) {
      if (node.name().uri == "" && currentURI == name.uri) {
        if (node.name().localName == name.localName)
          return true;
      } else if (QName.equality(node.name(),name)) {
        return true;
      }
    } else {
      if (node.name().localName == name.localName)
        return true;
    }
  }}
  
  return false;
};


/**
 * Looks up value by name on a complex parent object, considering that the
 * name might have to be prepended with an underscore.
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {*}
 */
mx.rpc.xml.XMLEncoder.prototype.resolveNamedProperty = function(parent, name) {
  var /** @type {*} */ value;
  var /** @type {string} */ fallbackName = null;
  if (!this.isSimpleValue(parent)) {
    try {
      value = parent[name];
      if (value === undefined)
        fallbackName = "_" + name.toString();
    } catch (e) {
      fallbackName = "_" + name.toString();
    }
    if (fallbackName != null && parent.hasOwnProperty(fallbackName))
      value = parent[fallbackName];
  }
  return value;
};


/**
 * Assigns value to an XML node.
 * 
 * @asparam parent The node to assign to. Must be either XML or XMLList.
 * If XMLList, it must contain at least one XML element. The value is
 * assigned on the last element in the list. If XML, the value is assigned
 * directly on parent.
 * @asparam value The value to assign on the parent. If null, the xsi:nil
 * attribute is set on the parent. If XML or XMLList, the value is appended
 * as child node(s) on the parent. Otherwise the string representation of the
 * value is appended as a text node. A value that is explicitly undefined is
 * skipped.
 * 
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.setValue = function(parent, value) {
  if (value !== undefined) {
    var /** @type {XML} */ currentChild;
    if (org.apache.royale.utils.Language.is(parent, XML))
      currentChild = org.apache.royale.utils.Language.as(parent, XML);
    else if (org.apache.royale.utils.Language.is(parent, XMLList) && parent.length() > 0)
      currentChild = parent[parent.length() - 1];
    if (currentChild != null) {
      if (value === null) {
        currentChild.setAttribute(this.schemaManager.schemaConstants.nilQName, "true");
        currentChild.addNamespace(this.constants.xsiNamespace);
      } else if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList)) {
        currentChild.appendChild(value);
      } else if (value !== undefined) {
        currentChild.appendChild(this.xmlSpecialCharsFilter(org.apache.royale.utils.Language.resolveUncertain(Object(value))));
      }
    }
  }
};


/**
 * Appends a value (or list of values) directly as
 * members of the parent XMLList. Effectively merges
 * two XMLLists.
 * 
 * @asprivate
 * @export
 * @param {XMLList} parent
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.appendValue = function(parent, value) {
  parent[parent.length()] = value;
};


/**
 * Checks to see whether a value defines a custom XSI type to be used
 * during encoding, otherwise the default type is returned.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} value
 * @return {QName}
 */
mx.rpc.xml.XMLEncoder.prototype.getXSIType = function(value) {
  var /** @type {QName} */ xsiType;
  if (value != null) {
    if (org.apache.royale.utils.Language.is(value, mx.utils.ObjectProxy) && value[new QName(mx.utils.object_proxy, 'type').objectAccessFormat()] != null) {
      xsiType = value[new QName(mx.utils.object_proxy, 'type').objectAccessFormat()];
    } else if (org.apache.royale.utils.Language.is(value, mx.rpc.xml.IXMLSchemaInstance) && org.apache.royale.utils.Language.as(value, mx.rpc.xml.IXMLSchemaInstance, true).xsiType != null) {
      xsiType = org.apache.royale.utils.Language.as(value, mx.rpc.xml.IXMLSchemaInstance, true).xsiType;
    }
  }
  return xsiType;
};


/**
 * Record custom XSI type information for this XML node by adding an
 * xsi:type attribute with the value set to the qualified type name.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {XML} parent
 * @param {QName} type
 */
mx.rpc.xml.XMLEncoder.prototype.setXSIType = function(parent, type) {
  var /** @type {string} */ namespaceURI = type.uri;
  var /** @type {string} */ prefix = this.schemaManager.getOrCreatePrefix(namespaceURI);
  var /** @type {Namespace} */ prefixNamespace = new Namespace(prefix, namespaceURI);
  parent.addNamespace(prefixNamespace);
  parent.setAttribute(this.constants.getXSIToken(this.constants.typeAttrQName), prefix + ":" + type.localName);
};


/**
 * @asprivate
 * @export
 * @param {XML} parent
 * @param {QName} type
 * @param {*} value
 */
mx.rpc.xml.XMLEncoder.prototype.deriveXSIType = function(parent, type, value) {
};


/**
 * @asprivate
 * Default implementation of xmlSpecialCharsFilter. Escapes "&" and "<".
 * @private
 * @param {Object} value
 * @return {string}
 */
mx.rpc.xml.XMLEncoder.prototype.mx_rpc_xml_XMLEncoder_escapeXML = function(value) {
  var /** @type {string} */ str = value.toString();
  if (this.mx_rpc_xml_XMLEncoder__escapeXMLChars) {
    str = str.replace(/&/g, "&amp;").replace(/</g, "&lt;");
  }
  return str;
};


/**
 * @private
 * @type {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.mx_rpc_xml_XMLEncoder__strictNillability = false;


/**
 * @private
 * @type {Function}
 */
mx.rpc.xml.XMLEncoder.prototype.mx_rpc_xml_XMLEncoder__xmlSpecialCharsFilter;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.xml.XMLEncoder.prototype.mx_rpc_xml_XMLEncoder__escapeXMLChars = true;


mx.rpc.xml.XMLEncoder.prototype.get__strictNillability = function() {
  return this.mx_rpc_xml_XMLEncoder__strictNillability;
};


mx.rpc.xml.XMLEncoder.prototype.set__strictNillability = function(strict) {
  this.mx_rpc_xml_XMLEncoder__strictNillability = strict;
};


mx.rpc.xml.XMLEncoder.prototype.get__xmlSpecialCharsFilter = function() {
  return this.mx_rpc_xml_XMLEncoder__xmlSpecialCharsFilter;
};


mx.rpc.xml.XMLEncoder.prototype.set__xmlSpecialCharsFilter = function(func) {
  if (func != null)
    this.mx_rpc_xml_XMLEncoder__xmlSpecialCharsFilter = func;
  else
    this.mx_rpc_xml_XMLEncoder__xmlSpecialCharsFilter = org.apache.royale.utils.Language.closure(this.mx_rpc_xml_XMLEncoder_escapeXML, this, 'escapeXML');
};


Object.defineProperties(mx.rpc.xml.XMLEncoder.prototype, /** @lends {mx.rpc.xml.XMLEncoder.prototype} */ {
/**
  * @export
  * @type {boolean} */
strictNillability: {
get: mx.rpc.xml.XMLEncoder.prototype.get__strictNillability,
set: mx.rpc.xml.XMLEncoder.prototype.set__strictNillability},
/**
  * @export
  * @type {Function} */
xmlSpecialCharsFilter: {
get: mx.rpc.xml.XMLEncoder.prototype.get__xmlSpecialCharsFilter,
set: mx.rpc.xml.XMLEncoder.prototype.set__xmlSpecialCharsFilter}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.xml.XMLEncoder.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'XMLEncoder', qName: 'mx.rpc.xml.XMLEncoder', kind: 'class' }], interfaces: [mx.rpc.xml.IXMLEncoder] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.xml.XMLEncoder.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'strictNillability': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.rpc.xml.XMLEncoder'},
        'xmlSpecialCharsFilter': { type: 'Function', access: 'readwrite', declaredBy: 'mx.rpc.xml.XMLEncoder'}
      };
    },
    methods: function () {
      return {
        'XMLEncoder': { type: '', declaredBy: 'mx.rpc.xml.XMLEncoder'},
        'encode': { type: 'XMLList', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'QName', true ,'QName', true ,'XML', true ]; }},
        'encodeAll': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XMLList', false ,'QName', false ,'*', false ,'Boolean', true ]; }},
        'encodeAnyAttribute': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', true ,'XML', true ]; }},
        'encodeAnyElement': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XMLList', false ,'QName', false ,'*', false ,'Boolean', true ,'Array', true ]; }},
        'encodeAttribute': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', true ,'XML', true ]; }},
        'encodeAttributeGroup': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', true ,'XML', true ]; }},
        'encodeChoice': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XMLList', false ,'QName', false ,'*', false ,'Boolean', true ]; }},
        'encodeComplexContent': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ]; }},
        'encodeComplexExtension': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ]; }},
        'encodeComplexRestriction': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ]; }},
        'encodeComplexType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeGroupElement': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XMLList', false ,'QName', false ,'*', false ,'Boolean', true ]; }},
        'encodeElementTopLevel': { type: 'XML', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'QName', false ,'*', false ]; }},
        'encodeGroupReference': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XMLList', false ,'QName', false ,'*', false ,'Boolean', true ]; }},
        'encodeSequence': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XMLList', false ,'QName', false ,'*', false ,'Boolean', true ]; }},
        'encodeSimpleContent': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeSimpleList': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeSimpleRestriction': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ]; }},
        'encodeSimpleType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeSimpleUnion': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'QName', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeXSINil': { type: 'XML', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'QName', false ,'*', false ,'Boolean', true ]; }},
        'getAttribute': { type: '*', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'hasAttribute': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'setAttribute': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XML', false ,'*', false ,'*', false ]; }},
        'getProperties': { type: 'Array', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ]; }},
        'createElement': { type: 'XML', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ]; }},
        'getSimpleValue': { type: '*', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'isSimpleValue': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ]; }},
        'getValue': { type: '*', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'hasValue': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'containsNodeByName': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XMLList', false ,'QName', false ,'Boolean', true ]; }},
        'resolveNamedProperty': { type: '*', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'setValue': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'appendValue': { type: 'void', declaredBy: 'mx.rpc.xml.XMLEncoder', parameters: function () { return [ 'XMLList', false ,'*', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.xml.XMLEncoder.prototype.ROYALE_COMPILE_FLAGS = 26;
