/**
 * Generated by Apache Royale Compiler from mx/rpc/xml/XMLDecoder.as
 * mx.rpc.xml.XMLDecoder
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.xml.XMLDecoder');
/* Royale Dependency List: QName,XML,XMLList,mx.collections.ArrayCollection,mx.logging.ILogger,mx.logging.Log,mx.messaging.errors.ArgumentError,mx.rpc.xml.ContentProxy,mx.rpc.xml.DecodingContext,mx.rpc.xml.IXMLSchemaInstance,mx.rpc.xml.SchemaTypeRegistry,mx.rpc.xml.SimpleContent,mx.rpc.xml.TypeIterator,mx.utils.ObjectProxy,mx.utils.URLUtil,mx.utils.XMLUtil,mx.utils.object_proxy,org.apache.royale.reflection.AccessorDefinition,org.apache.royale.reflection.TypeDefinition,org.apache.royale.reflection.describeType,org.apache.royale.reflection.getQualifiedClassName,org.apache.royale.utils.Language*/

goog.require('mx.rpc.xml.SchemaProcessor');
goog.require('mx.rpc.xml.IXMLDecoder');



/**
 * @constructor
 * @extends {mx.rpc.xml.SchemaProcessor}
 * @implements {mx.rpc.xml.IXMLDecoder}
 */
mx.rpc.xml.XMLDecoder = function() {
  mx.rpc.xml.XMLDecoder.base(this, 'constructor');
  this.mx_rpc_xml_XMLDecoder_log = mx.logging.Log.getLogger("mx.rpc.xml.XMLDecoder");
  this.typeRegistry = mx.rpc.xml.SchemaTypeRegistry.getInstance();
};
goog.inherits(mx.rpc.xml.XMLDecoder, mx.rpc.xml.SchemaProcessor);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.xml.XMLDecoder', mx.rpc.xml.XMLDecoder);


/**
 * Decodes an XML document to an ActionScript object.
 * 
 * @asparam xml The XML instance to decode to an ActionScript object. 
 * This may be an XML instance, an XMLList of length 1 or a String that is
 * valid XML.
 * @asparam name The QName of an XML Schema <code>element</code> that
 * describes how to decode the value, or the name to be used for the
 * decoded value when a type parameter is also specified.
 * @asparam type The QName of an XML Schema <code>simpleType</code> or
 * <code>complexType</code> definition that describes how to decode the
 * value.
 * @asparam definition If neither a top level element nor type exists in the
 * schema to describe how to decode this value, a custom element definition
 * can be provided.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} xml
 * @param {QName=} name
 * @param {QName=} type
 * @param {XML=} definition
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.decode = function(xml, name, type, definition) {
  name = typeof name !== 'undefined' ? name : null;
  type = typeof type !== 'undefined' ? type : null;
  definition = typeof definition !== 'undefined' ? definition : null;
  if (!org.apache.royale.utils.Language.is(xml, XML) && !org.apache.royale.utils.Language.is(xml, XMLList) && !org.apache.royale.utils.Language.is(xml, String))
    throw new mx.messaging.errors.ArgumentError("The xml argument must be of type XML, XMLList or String.");
  if (org.apache.royale.utils.Language.is(xml, XML)) {
    this.document = xml;
  } else if (org.apache.royale.utils.Language.is(xml, XMLList)) {
    if (XMLList.conversion(xml).length() != 1)
      throw new mx.messaging.errors.ArgumentError("The xml argument must have a length of 1 when passed as an XMLList.");
    this.document = XMLList.conversion(xml)[0];
  } else if (org.apache.royale.utils.Language.is(xml, String)) {
    try {
      this.document = new XML(xml);
    } catch (e) {
      throw new mx.messaging.errors.ArgumentError("The xml argument does not contain valid xml. " + xml);
    }
  }
  this.preProcessXML(this.document);
  var /** @type {*} */ content;
  if (type != null) {
    content = this.createContent(type);
    this.decodeType(type, content, name, this.document);
  } else {
    var /** @type {XML} */ elementDefinition = definition;
    if (elementDefinition == null) {
      elementDefinition = this.schemaManager.getNamedDefinition(name, this.constants.elementTypeQName);
    }
    if (elementDefinition == null) {
      content = this.createContent(type);
      this.decodeType(this.constants.anyTypeQName, content, name, this.document);
    } else {
      content = this.decodeElementTopLevel(elementDefinition, name, this.document);
      if (definition == null)
        this.schemaManager.releaseScope();
    }
  }
  if (org.apache.royale.utils.Language.is(content, mx.rpc.xml.ContentProxy))
    content = org.apache.royale.utils.Language.as(content, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
  return content;
};


/**
 * All content:
 *     (annotation?, (element | any)*)
 * 
 * <ul>
 * <li>maxOccurs for 'all' itself must be 1, minOccurs can be 0 or 1</li>
 * <li>maxOccurs for element declarations must be 1, minOccurs can be
 * 0 or 1</li>
 * <li>'all' does not contain other groups and it must not appear in other
 * structure groups - it must be at the top level of a complexType.</li>
 * </ul>
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {XMLList} valueElements
 * @param {mx.rpc.xml.DecodingContext=} context
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeAll = function(definition, parent, name, valueElements, context, isRequired) {
  context = typeof context !== 'undefined' ? context : null;
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  if (context == null)
    context = new mx.rpc.xml.DecodingContext();
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  var /** @type {XMLList} */ allElements = definition.elements();
  var /** @type {boolean} */ hasSiblings = allElements.length() > 1 || context.hasContextSiblings;
  var /** @type {boolean} */ requireChild = isRequired && minOccurs > 0;
  var /** @type {boolean} */ groupSatisfied = !requireChild;
  var foreachiter0_target = allElements;
  for (var foreachiter0 in foreachiter0_target.elementNames()) 
  {
  var childDefinition = foreachiter0_target[foreachiter0];
  {
    context.index = 0;
    context.anyIndex = 0;
    if (QName.equality(childDefinition.name(),this.constants.annotationQName)) {
      groupSatisfied = true;
    } else if (QName.equality(childDefinition.name(),this.constants.elementTypeQName)) {
      if (!this.decodeGroupElement(childDefinition, parent, valueElements, context, requireChild, hasSiblings))
        break;
    } else if (QName.equality(childDefinition.name(),this.constants.anyQName)) {
      if (!this.decodeAnyElement(childDefinition, parent, name, valueElements, context, requireChild))
        break;
    }
    groupSatisfied = true;
  }}
  
  return groupSatisfied;
};


/**
 * @export
 * @param {*} parent
 * @param {QName} name
 * @param {XMLList} valueElements
 */
mx.rpc.xml.XMLDecoder.prototype.decodeAnyType = function(parent, name, valueElements) {
  var foreachiter1_target = valueElements;
  for (var foreachiter1 in foreachiter1_target.elementNames()) 
  {
  var elementVal = foreachiter1_target[foreachiter1];
  {
    var /** @type {QName} */ propertyName = org.apache.royale.utils.Language.as(elementVal.name(), QName);
    var /** @type {*} */ propertyVal;
    var /** @type {QName} */ xsiType = this.getXSIType(elementVal);
    if (xsiType != null) {
      propertyVal = this.createContent();
      this.decodeType(this.schemaManager.schemaDatatypes.anyTypeQName, propertyVal, propertyName, elementVal);
    } else {
      propertyVal = this.marshallBuiltInType(this.schemaManager.schemaDatatypes.anyTypeQName, parent, propertyName, elementVal);
    }
    this.setValue(parent, propertyName, propertyVal, xsiType);
  }}
  
};


/**
 * Decodes <any> elements from the context of a model group. The valueElements
 * list contains all top-level values for all elements in the current model
 * group. This method picks up the first undecoded value and 
 * 
 * Any content:
 *    (annotation?)
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {XMLList} valueElements
 * @param {mx.rpc.xml.DecodingContext=} context
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeAnyElement = function(definition, parent, name, valueElements, context, isRequired) {
  context = typeof context !== 'undefined' ? context : null;
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  if (context == null)
    context = new mx.rpc.xml.DecodingContext();
  var /** @type {Array} */ includedNamespaces;
  var /** @type {boolean} */ allowTargetNamespace = true;
  var /** @type {string} */ targetNamespace;
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (definition != null) {
    var /** @type {string} */ processContents = org.apache.royale.utils.Language.string(definition.attribute("processContents"));
    var /** @type {string} */ namespacesString = org.apache.royale.utils.Language.string(definition.attribute("namespace"));
    if (namespacesString != "" && namespacesString != "##any") {
      if (this.schemaManager.currentSchema != null && this.schemaManager.currentSchema.targetNamespace != null)
        targetNamespace = this.schemaManager.currentSchema.targetNamespace.uri;
      if (namespacesString == "##other") {
        allowTargetNamespace = false;
      } else {
        if (namespacesString.indexOf("##targetNamespace") >= 0)
          namespacesString = namespacesString.replace("##targetNamespace", targetNamespace);
        includedNamespaces = namespacesString.split(" ");
      }
    }
  }
  var /** @type {XMLList} */ applicableValues = this.getApplicableValues(parent, valueElements, null, context, maxOccurs);
  var foreachiter2_target = applicableValues;
  for (var foreachiter2 in foreachiter2_target.elementNames()) 
  {
  var element = foreachiter2_target[foreachiter2];
  {
    var /** @type {QName} */ propertyName = org.apache.royale.utils.Language.as(element.name(), QName);
    if (!allowTargetNamespace && mx.utils.URLUtil.urisEqual(propertyName.uri, targetNamespace)) {
      break;
    }
    if (this.includeNamespace(propertyName.uri, includedNamespaces)) {
      var /** @type {*} */ any;
      var /** @type {*} */ elementVal;
      if (processContents == "skip")
        elementVal = element.toXMLString();
      else
        elementVal = element;
      this.decodeAnyType(parent, propertyName, new XMLList(elementVal));
      if (context.anyIndex < 0)
        context.anyIndex = (context.index + 0) >> 0;
      context.index++;
    }
  }}
  
  return true;
};


/**
 * Decodes any attributes using the XML schema rules for attribute
 * wildcards.
 * 
 * FIXME: This needs further investigation of the XML schema spec for
 * wildcard rules and constraints.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {*=} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeAnyAttribute = function(definition, parent, value, restriction) {
  value = typeof value !== 'undefined' ? value : undefined;
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  if (value !== undefined && org.apache.royale.utils.Language.is(value, XML)) {
    var /** @type {XML} */ xml = org.apache.royale.utils.Language.as(value, XML);
    var /** @type {Array} */ includedNamespaces;
    var /** @type {boolean} */ allowTargetNamespace = true;
    var /** @type {string} */ targetNamespace;
    var /** @type {string} */ namespacesString = org.apache.royale.utils.Language.string(definition.attribute("namespace"));
    if (namespacesString != "" && namespacesString != "##any") {
      if (this.schemaManager.currentSchema != null && this.schemaManager.currentSchema.targetNamespace != null)
        targetNamespace = this.schemaManager.currentSchema.targetNamespace.uri;
      if (namespacesString == "##other") {
        allowTargetNamespace = false;
      } else {
        if (namespacesString.indexOf("##targetNamespace") >= 0)
          namespacesString = namespacesString.replace("##targetNamespace", targetNamespace);
        includedNamespaces = namespacesString.split(" ");
      }
    }
    var /** @type {XMLList} */ attributes = xml.attributes();
    var foreachiter3_target = attributes;
    for (var foreachiter3 in foreachiter3_target.elementNames()) 
    {
    var attribute = foreachiter3_target[foreachiter3];
    {
      var /** @type {QName} */ attributeName = org.apache.royale.utils.Language.as(attribute.name(), QName);
      if (!allowTargetNamespace && mx.utils.URLUtil.urisEqual(attributeName.uri, targetNamespace))
        continue;
      if (this.includeNamespace(attributeName.uri, includedNamespaces)) {
        var /** @type {*} */ attributeValue = this.getAttribute(value, attributeName);
        if (attributeValue != null)
          this.setAttribute(parent, attributeName, attributeValue);
      }
    }}
    
  }
};


/**
 * An attribute must be based on a simple type and thus will have simple
 * content encoded as a String.
 *
 * This function is used to encode an <code>attribute</code> that may be
 * named and registered as a top-level <code>schema</code> definition or
 * in-line from a <code>complexType</code>, <code>extension</code> or
 * <restriction> of either a <code>complexType</code> or
 * <code>simpleType</code>, or <code>attributeGroup</code>
 * definition in any aforementioned parent component.
 * 
 * If the <code>attribute</code> points to a named definition using a 
 * <code>ref</code> attribute, the reference is resolved to provide the
 * real definition of the attribute. If the reference cannot be resolved,
 * an error is thrown.
 * 
 * If the attribute defines a <code>fixed</code> constraint then any value
 * provided is ignored and the fixed value is used instead. If a value is
 * not provided and the attribute defines a <code>default</code>, the
 * default is used for the encoded attribute. Otherwise if an attribute is
 * marked as <code>optional</code> and a value is not provided it will be
 * skipped.
 *
 * @asparam parent The parent instance to which these attributes will be added.
 * @asparam definition The XML schema definition of the attribute.
 * @asparam value An object with a property name that matches the resolved
 * attribute name. The property value will be used as the encoded attribute
 * value.
 * 
 * FIXME: Attributes are expected to be simple values and must be ultimately
 * representable as a String. If a complex value is passed to this method
 * should we assume that we're always looking for a property with the same
 * name as the attribute? We may need to because if we have a ref then the
 * name is not known immediately...
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {*=} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeAttribute = function(definition, parent, value, restriction) {
  value = typeof value !== 'undefined' ? value : undefined;
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.attributeQName);
    if (definition == null)
      throw new Error("Cannot resolve attribute definition for '" + ref + "'");
  }
  var /** @type {string} */ attributeNameString = definition.attribute('name').toString();
  var /** @type {string} */ attributeUse = definition.attribute("use").toString();
  if (attributeUse != "prohibited") {
    var /** @type {QName} */ attributeName = this.schemaManager.getQNameForAttribute(attributeNameString, this.getAttributeFromNode("form", definition));
    var /** @type {string} */ attributeFixed = this.getAttributeFromNode("fixed", definition);
    if (attributeFixed != null) {
      value = attributeFixed;
    } else {
      value = this.getAttribute(value, attributeName);
      if (value === undefined) {
        var /** @type {string} */ attributeDefault = this.getAttributeFromNode("default", definition);
        if (attributeDefault != null)
          value = attributeDefault;
      }
    }
    var /** @type {*} */ attributeValue;
    if (value !== undefined) {
      var /** @type {XML} */ typeDefinition;
      attributeValue = this.createContent();
      var /** @type {string} */ typeName = this.getAttributeFromNode("type", definition);
      var /** @type {QName} */ attributeType;
      if (typeName != null)
        attributeType = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('type')), definition);
      else
        attributeType = this.schemaManager.schemaDatatypes.anySimpleTypeQName;
      if (attributeType != null) {
        if (this.isBuiltInType(attributeType)) {
          var /** @type {*} */ result = this.marshallBuiltInType(attributeType, attributeValue, attributeName, value, restriction);
          this.setValue(attributeValue, attributeName, result);
        } else {
          typeDefinition = this.schemaManager.getNamedDefinition(attributeType, this.constants.simpleTypeQName);
          if (typeDefinition != null)
            this.decodeSimpleType(typeDefinition, attributeValue, attributeName, value, restriction);
          else
            throw new Error("Cannot find simpleType " + attributeType + " for attribute " + attributeName);
          this.schemaManager.releaseScope();
        }
      } else {
        typeDefinition = this.getSingleElementFromNode(definition, this.constants.simpleTypeQName);
        if (typeDefinition != null) {
          this.decodeSimpleType(typeDefinition, attributeValue, attributeName, value, restriction);
        } else if (value != null) {
          attributeValue = value;
        }
      }
    }
    if (attributeValue != null) {
      this.setAttribute(parent, attributeName, attributeValue);
    }
  }
  if (ref != null)
    this.schemaManager.releaseScope();
};


/**
 * An <code>attributeGroup</code> definition may include a number of
 * <code>attribute</code> or <code>attributeGroup</code> children, all of
 * which ultimately combine to form a flat group of attributes for some
 * type. It may also specify <code>anyAttribute</code> which expands
 * the definition to accept attributes based on more general criteria
 * (such excluding or including attributes on namespace).
 *
 * This function is used to encode an <code>attributeGroup</code> that may 
 * be named and registered as a top-level <code>schema</code> definition or
 * in-line from a <code>complexType</code>, <code>extension</code> or
 * <restriction> of either a <code>complexType</code> or
 * <code>simpleType</code>, or even another <code>attributeGroup</code>
 * definition in any aforementioned parent component.
 * 
 * If the <code>attributeGroup</code> points to a named definition using a
 * ref attribute, the reference is resolved to provide the real definition
 * of the attributeGroup. If the reference cannot be resolved, an error is
 * thrown.
 * 
 * @asparam parent The parent instance to which these attributes will be added.
 * @asparam definition The XML schema definition of the attributeGroup.
 * @asparam value An object with property names that match the resolved
 * attribute names in the group. The property values will be used as the
 * encoded attribute values. This argument may be omitted if each attribute
 * in the group has a fixed or default value.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {*=} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeAttributeGroup = function(definition, parent, value, restriction) {
  value = typeof value !== 'undefined' ? value : undefined;
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.attributeGroupQName);
    if (definition == null)
      throw new Error("Cannot resolve attributeGroup definition for '" + ref + "'");
  }
  var /** @type {XMLList} */ attributes = definition.elements(this.constants.attributeQName);
  var foreachiter4_target = attributes;
  for (var foreachiter4 in foreachiter4_target.elementNames()) 
  {
  var attribute = foreachiter4_target[foreachiter4];
  {
    this.decodeAttribute(attribute, parent, value, restriction);
  }}
  
  var /** @type {XMLList} */ attributeGroups = definition.elements(this.constants.attributeGroupQName);
  var foreachiter5_target = attributeGroups;
  for (var foreachiter5 in foreachiter5_target.elementNames()) 
  {
  var attributeGroup = foreachiter5_target[foreachiter5];
  {
    this.decodeAttributeGroup(attributeGroup, parent, value, restriction);
  }}
  
  var /** @type {XML} */ anyAttribute = this.getSingleElementFromNode(definition, this.constants.anyAttributeQName);
  if (anyAttribute != null) {
    this.decodeAnyAttribute(anyAttribute, parent, value, restriction);
  }
  if (ref != null)
    this.schemaManager.releaseScope();
};


/**
 * choice:
 *    (annotation?, (element | group | choice | sequence | any)*)
 * 
 * @asparam context A DecodingContext instance. Used to keep track
 * of the index of the element being processed in the current model
 * group.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {XMLList} valueElements
 * @param {mx.rpc.xml.DecodingContext=} context
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeChoice = function(definition, parent, name, valueElements, context, isRequired) {
  context = typeof context !== 'undefined' ? context : null;
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {number} */ choiceOccurs = 0;
  var /** @type {number} */ lastIndex = 0;
  if (context == null)
    context = new mx.rpc.xml.DecodingContext();
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (maxOccurs == 0)
    return false;
  if (valueElements == null && minOccurs == 0)
    return true;
  var /** @type {XMLList} */ choiceElements = definition.elements();
  if (choiceElements.length() == 0)
    return true;
  var /** @type {boolean} */ choiceSatisfied;
  //var /** @type {number} */ lastIndex = 0;
  //var /** @type {number} */ choiceOccurs = 0;
  for (choiceOccurs = 0; choiceOccurs < maxOccurs; choiceOccurs++) {
    lastIndex = (context.index + 0) >>> 0;
    choiceSatisfied = false;
    var foreachiter6_target = choiceElements;
    for (var foreachiter6 in foreachiter6_target.elementNames()) 
    {
    var childDefinition = foreachiter6_target[foreachiter6];
    {
      if (QName.equality(childDefinition.name(),this.constants.elementTypeQName)) {
        choiceSatisfied = choiceSatisfied || this.decodeGroupElement(childDefinition, parent, valueElements, context, false);
        if (context.index > lastIndex)
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
        choiceSatisfied = choiceSatisfied || this.decodeSequence(childDefinition, parent, name, valueElements, context, false);
        if (context.index > lastIndex)
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
        choiceSatisfied = choiceSatisfied || this.decodeGroupReference(childDefinition, parent, name, valueElements, context, false);
        if (context.index > lastIndex)
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
        choiceSatisfied = choiceSatisfied || this.decodeChoice(childDefinition, parent, name, valueElements, context, false);
        if (context.index > lastIndex)
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.anyQName)) {
        choiceSatisfied = choiceSatisfied || this.decodeAnyElement(childDefinition, parent, name, valueElements, context, false);
        if (context.index > lastIndex)
          break;
      }
    }}
    
    if (!choiceSatisfied) {
      break;
    }
  }
  if (choiceOccurs < minOccurs) {
    if (isRequired && this.strictOccurenceBounds)
      throw new Error("Value supplied for choice " + name.toString() + " occurs " + choiceOccurs + " times which falls short of minOccurs " + minOccurs + ".");
    else
      return false;
  }
  return true;
};


/**
 * Derivation by restriction takes an existing type as the base and creates
 * a new type by limiting its allowed content to a subset of that allowed
 * by the base type. Derivation by extension takes an existing type as the
 * base and creates a new type by adding to its allowed content.
 * 
 * complexContent:
 * (annotation?, (restriction | extension))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {mx.rpc.xml.DecodingContext} context
 */
mx.rpc.xml.XMLDecoder.prototype.decodeComplexContent = function(definition, parent, name, value, context) {
  var /** @type {XML} */ childDefinition = this.getSingleElementFromNode(definition, this.constants.extensionQName, this.constants.restrictionQName);
  if (QName.equality(childDefinition.name(),this.constants.extensionQName)) {
    this.decodeComplexExtension(childDefinition, parent, name, value, context);
  } else if (QName.equality(childDefinition.name(),this.constants.restrictionQName)) {
    this.decodeComplexRestriction(childDefinition, parent, name, value);
  }
};


/**    
 * complexContent:
 *   extension:
 *     (annotation?, ((group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), (assert | report)*))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {mx.rpc.xml.DecodingContext=} context
 */
mx.rpc.xml.XMLDecoder.prototype.decodeComplexExtension = function(definition, parent, name, value, context) {
  context = typeof context !== 'undefined' ? context : null;
  if (context == null)
    context = new mx.rpc.xml.DecodingContext();
  context.hasContextSiblings = true;
  var /** @type {string} */ baseName = this.getAttributeFromNode("base", definition);
  if (baseName == null)
    throw new Error("A complexContent extension must declare a base type.");
  var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, definition);
  var /** @type {XML} */ baseDefinition = this.schemaManager.getNamedDefinition(baseType, this.constants.complexTypeQName);
  if (baseDefinition == null)
    throw new Error("Cannot find base type definition '" + baseType + "'");
  var /** @type {boolean} */ originalLaxSequence = context.laxSequence;
  context.laxSequence = true;
  this.decodeComplexType(baseDefinition, parent, name, value, null, context);
  this.schemaManager.releaseScope();
  var /** @type {XMLList} */ childElements = definition.elements();
  var /** @type {XMLList} */ valueElements = new XMLList();
  if (org.apache.royale.utils.Language.is(value, XML))
    valueElements = org.apache.royale.utils.Language.as(value, XML).elements();
  else if (org.apache.royale.utils.Language.is(value, XMLList))
    valueElements = value;
  var foreachiter7_target = childElements;
  for (var foreachiter7 in foreachiter7_target.elementNames()) 
  {
  var childDefinition = foreachiter7_target[foreachiter7];
  {
    if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      this.decodeSequence(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      this.decodeGroupReference(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      this.decodeAll(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      this.decodeChoice(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeQName)) {
      this.decodeAttribute(childDefinition, parent, value);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeGroupQName)) {
      this.decodeAttributeGroup(childDefinition, parent, value);
    } else if (QName.equality(childDefinition.name(),this.constants.anyAttributeQName)) {
      this.decodeAnyAttribute(childDefinition, parent, value);
    }
  }}
  
  context.laxSequence = originalLaxSequence;
};


/**    
 * complexContent:
 *   restriction:
 *     (annotation?, (group | all | choice | sequence)?, ((attribute | attributeGroup)*, anyAttribute?), (assert | report)*)
 * 
 * @asprivate
 * @export
 * @param {XML} restriction
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 */
mx.rpc.xml.XMLDecoder.prototype.decodeComplexRestriction = function(restriction, parent, name, value) {
  var /** @type {string} */ baseName = this.getAttributeFromNode("base", restriction);
  if (baseName == null)
    throw new Error("A complexContent restriction must declare a base type.");
  var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, restriction);
  var /** @type {XMLList} */ childElements = restriction.elements();
  var /** @type {XMLList} */ valueElements = new XMLList();
  if (org.apache.royale.utils.Language.is(value, XML))
    valueElements = org.apache.royale.utils.Language.as(value, XML).elements();
  else if (org.apache.royale.utils.Language.is(value, XMLList))
    valueElements = value;
  var foreachiter8_target = childElements;
  for (var foreachiter8 in foreachiter8_target.elementNames()) 
  {
  var childDefinition = foreachiter8_target[foreachiter8];
  {
    if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      this.decodeSequence(childDefinition, parent, name, valueElements);
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      this.decodeGroupReference(childDefinition, parent, name, valueElements);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      this.decodeAll(childDefinition, parent, name, valueElements);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      this.decodeChoice(childDefinition, parent, name, valueElements);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeQName)) {
      this.decodeAttribute(childDefinition, parent, value);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeGroupQName)) {
      this.decodeAttributeGroup(childDefinition, parent, value);
    } else if (QName.equality(childDefinition.name(),this.constants.anyAttributeQName)) {
      this.decodeAnyAttribute(childDefinition, parent, value);
    }
  }}
  
};


/**
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 * @param {mx.rpc.xml.DecodingContext=} context
 */
mx.rpc.xml.XMLDecoder.prototype.decodeComplexType = function(definition, parent, name, value, restriction, context) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  context = typeof context !== 'undefined' ? context : null;
  if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy))
    org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple = false;
  var /** @type {XMLList} */ childElements = definition.elements();
  var /** @type {XMLList} */ valueElements = new XMLList();
  if (org.apache.royale.utils.Language.is(value, XML))
    valueElements = org.apache.royale.utils.Language.as(value, XML).elements();
  else if (org.apache.royale.utils.Language.is(value, XMLList))
    valueElements = value;
  var foreachiter9_target = childElements;
  for (var foreachiter9 in foreachiter9_target.elementNames()) 
  {
  var childDefinition = foreachiter9_target[foreachiter9];
  {
    if (QName.equality(childDefinition.name(),this.constants.simpleContentQName)) {
      this.decodeSimpleContent(childDefinition, parent, name, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.complexContentQName)) {
      this.decodeComplexContent(childDefinition, parent, name, value, context);
    } else if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      this.decodeSequence(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
      this.decodeGroupReference(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      this.decodeAll(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      this.decodeChoice(childDefinition, parent, name, valueElements, context);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeQName)) {
      this.decodeAttribute(childDefinition, parent, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.attributeGroupQName)) {
      this.decodeAttributeGroup(childDefinition, parent, value, restriction);
    } else if (QName.equality(childDefinition.name(),this.constants.anyAttributeQName)) {
      this.decodeAnyAttribute(childDefinition, parent, value, restriction);
    }
  }}
  
};


/**
 * Used to decode a local element definition. This element may also simply
 * refer to a top level element.
 * 
 * Element content:
 * (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))
 * 
 * FIXME: Support substitutionGroup, block and redefine?
 * FIXME: Do we care about abstract or final?
 * 
 * FIXME: Remove isRequired if not necessary...
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {XMLList} valueElements
 * @param {mx.rpc.xml.DecodingContext=} context
 * @param {boolean=} isRequired
 * @param {boolean=} hasSiblings
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeGroupElement = function(definition, parent, valueElements, context, isRequired, hasSiblings) {
  context = typeof context !== 'undefined' ? context : null;
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  hasSiblings = typeof hasSiblings !== 'undefined' ? hasSiblings : true;
  var /** @type {number} */ elementOccurs = 0;
  if (context == null)
    context = new mx.rpc.xml.DecodingContext();
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (maxOccurs == 0)
    return true;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.elementTypeQName);
    if (definition == null)
      throw new Error("Cannot resolve element definition for ref '" + ref + "'");
  }
  var /** @type {string} */ elementName = definition.attribute('name').toString();
  var /** @type {QName} */ elementQName = this.schemaManager.getQNameForElement(elementName, this.getAttributeFromNode("form", definition));
  var /** @type {XMLList} */ applicableValues = this.getApplicableValues(parent, valueElements, elementQName, context, maxOccurs);
  if (applicableValues.length() == 1 && this.isXSINil(applicableValues[0])) {
    this.setValue(parent, elementQName, null);
    context.index++;
    if (ref != null)
      this.schemaManager.releaseScope();
    return true;
  }
  if (maxOccurs > 1) {
    var /** @type {string} */ typeAttribute = this.getAttributeFromNode("type", definition);
    var /** @type {QName} */ typeQName;
    if (typeAttribute != null) {
      typeQName = this.schemaManager.getQNameForPrefixedName(typeAttribute, definition);
    }
    var /** @type {*} */ emptyArray = this.createIterableValue(typeQName);
    if (hasSiblings) {
      this.setValue(parent, elementQName, emptyArray, typeQName);
    } else {
      if (!(org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy) && parent[new QName(mx.utils.object_proxy, 'content').objectAccessFormat()] != undefined)) {
        this.setValue(parent, null, emptyArray, typeQName);
      }
    }
  }
  if (applicableValues.length() == 0) {
    if (ref != null)
      this.schemaManager.releaseScope();
    if (minOccurs == 0)
      return true;
    else
      return false;
  }
  var /** @type {*} */ element;
  if (maxOccurs == 1) {
    element = this.decodeElementTopLevel(definition, elementQName, this.parseValue(elementQName, applicableValues));
    this.setValue(parent, elementQName, element);
    context.index++;
  } else if (maxOccurs > 1) {
    if (applicableValues.length() < minOccurs) {
      if (ref != null)
        this.schemaManager.releaseScope();
      if (this.strictOccurenceBounds)
        throw new Error("Value supplied for element '" + elementQName + "' occurs " + applicableValues.length() + " times which falls short of minOccurs " + minOccurs + ".");
      else
        return false;
    }
    if (applicableValues.length() > maxOccurs) {
      if (ref != null)
        this.schemaManager.releaseScope();
      if (this.strictOccurenceBounds)
        throw new Error("Value supplied for element of type '" + elementQName + "' occurs " + applicableValues.length() + " times which exceeds maxOccurs " + maxOccurs + ".");
      else
        return false;
    }
    //var /** @type {number} */ elementOccurs = 0;
    for (elementOccurs = 0; elementOccurs < maxOccurs && elementOccurs < applicableValues.length(); elementOccurs++) {
      var /** @type {XML} */ item = applicableValues[elementOccurs];
      element = this.decodeElementTopLevel(definition, elementQName, item);
      this.setValue(parent, elementQName, element);
      context.index++;
    }
  }
  if (ref != null)
    this.schemaManager.releaseScope();
  return true;
};


/**
 * Element content:
 * (annotation?, ((simpleType | complexType)?, (unique | key | keyref)*))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {QName} elementQName
 * @param {*} value
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeElementTopLevel = function(definition, elementQName, value) {
  var /** @type {*} */ content;
  var /** @type {boolean} */ nillable = definition.attribute('nillable').toString() == "true" ? true : false;
  if (nillable && value == null) {
    return value;
  }
  var /** @type {string} */ fixedValue = this.getAttributeFromNode("fixed", definition);
  if (fixedValue != null)
    value = fixedValue;
  var /** @type {string} */ defaultValue = this.getAttributeFromNode("default", definition);
  if (!nillable && value == null)
    value = defaultValue;
  if (value == null) {
    return value;
  }
  var /** @type {*} */ processedElement;
  var /** @type {string} */ attributeValue = this.getAttributeFromNode("type", definition);
  if (attributeValue != null) {
    var /** @type {QName} */ typeQName = this.schemaManager.getQNameForPrefixedName(attributeValue, definition);
    var /** @type {QName} */ xsiType = this.getXSIType(value);
    if (xsiType != null)
      typeQName = xsiType;
    content = this.createContent(typeQName);
    this.decodeType(typeQName, content, elementQName, value);
    return content;
  } else if (definition.hasComplexContent()) {
    var /** @type {XML} */ typeDefinition = this.getSingleElementFromNode(definition, this.constants.complexTypeQName, this.constants.simpleTypeQName);
    content = this.createContent();
    if (QName.equality(typeDefinition.name(),this.constants.complexTypeQName)) {
      this.decodeComplexType(typeDefinition, content, elementQName, value);
    } else if (QName.equality(typeDefinition.name(),this.constants.simpleTypeQName)) {
      this.decodeSimpleType(typeDefinition, content, elementQName, value);
    }
    return content;
  } else {
    var /** @type {QName} */ typeQName2;
    if (fixedValue != null || defaultValue != null)
      typeQName2 = this.schemaManager.schemaDatatypes.stringQName;
    else
      typeQName2 = this.constants.anyTypeQName;
    content = this.createContent(typeQName2);
    this.decodeType(typeQName2, content, elementQName, value);
    return content;
  }
};


/**
 * The <code>group</code> element allows partial (or complete) content
 * models to be reused in complex types.
 * 
 * group:
 * (annotation?, (all | choice | sequence)?)
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {XMLList} valueElements
 * @param {mx.rpc.xml.DecodingContext=} context
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeGroupReference = function(definition, parent, name, valueElements, context, isRequired) {
  context = typeof context !== 'undefined' ? context : null;
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {QName} */ ref;
  if (definition.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(definition.attribute('ref')), definition, true);
    definition = this.schemaManager.getNamedDefinition(ref, this.constants.groupQName);
    if (definition == null)
      throw new Error("Cannot resolve group definition for '" + ref + "'");
  } else {
    throw new Error("A group reference element must have the ref attribute.");
  }
  var /** @type {XMLList} */ groupElements = definition.elements();
  var /** @type {boolean} */ groupSatisfied = false;
  var foreachiter10_target = groupElements;
  for (var foreachiter10 in foreachiter10_target.elementNames()) 
  {
  var childDefinition = foreachiter10_target[foreachiter10];
  {
    if (QName.equality(childDefinition.name(),this.constants.allQName)) {
      groupSatisfied = this.decodeAll(childDefinition, parent, name, valueElements, context, isRequired);
    } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
      groupSatisfied = this.decodeChoice(childDefinition, parent, name, valueElements, context, isRequired);
    } else if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
      groupSatisfied = this.decodeSequence(childDefinition, parent, name, valueElements, context, isRequired);
    }
  }}
  
  this.schemaManager.releaseScope();
  return groupSatisfied;
};


/**
 * sequence:
 *    (annotation?, (element | group | choice | sequence | any)*)
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {XMLList} valueElements
 * @param {mx.rpc.xml.DecodingContext=} context
 * @param {boolean=} isRequired
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.decodeSequence = function(definition, parent, name, valueElements, context, isRequired) {
  context = typeof context !== 'undefined' ? context : null;
  isRequired = typeof isRequired !== 'undefined' ? isRequired : true;
  var /** @type {number} */ sequenceOccurs = 0;
  if (context == null)
    context = new mx.rpc.xml.DecodingContext();
  var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
  var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
  if (maxOccurs == 0)
    return false;
  if ((valueElements == null || valueElements.length() == 0) && minOccurs == 0)
    return true;
  var /** @type {XMLList} */ sequenceElements = definition.elements();
  //var /** @type {number} */ sequenceOccurs = 0;
  var /** @type {boolean} */ hasSiblings = sequenceElements.length() > 1 || context.hasContextSiblings;
  if (sequenceElements.length() == 0)
    return true;
  for (sequenceOccurs = 0; sequenceOccurs < maxOccurs; sequenceOccurs++) {
    var /** @type {boolean} */ requireChild = isRequired && sequenceOccurs < minOccurs;
    var /** @type {boolean} */ sequenceSatisfied = true;
    var /** @type {number} */ lastIndex = (context.index + 0) >>> 0;
    var foreachiter11_target = sequenceElements;
    for (var foreachiter11 in foreachiter11_target.elementNames()) 
    {
    var childDefinition = foreachiter11_target[foreachiter11];
    {
      sequenceSatisfied = false;
      if (QName.equality(childDefinition.name(),this.constants.annotationQName)) {
        sequenceSatisfied = true;
      }
      if (QName.equality(childDefinition.name(),this.constants.elementTypeQName)) {
        if (!this.decodeGroupElement(childDefinition, parent, valueElements, context, requireChild, hasSiblings))
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.groupQName)) {
        if (!this.decodeGroupReference(childDefinition, parent, name, valueElements, context, requireChild))
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.choiceQName)) {
        if (!this.decodeChoice(childDefinition, parent, name, valueElements, context, requireChild))
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.sequenceQName)) {
        if (!this.decodeSequence(childDefinition, parent, name, valueElements, context, requireChild))
          break;
      } else if (QName.equality(childDefinition.name(),this.constants.anyQName)) {
        if (!this.decodeAnyElement(childDefinition, parent, name, valueElements, context, requireChild))
          break;
      }
      sequenceSatisfied = true;
    }}
    
    if (!sequenceSatisfied && requireChild) {
      if (this.strictOccurenceBounds)
        throw new Error("Cannot find value for definition " + childDefinition.toXMLString() + " in sequence.");
      else
        return false;
    }
    if (lastIndex == context.index) {
      if (sequenceSatisfied) {
        sequenceOccurs++;
        sequenceOccurs = sequenceOccurs > minOccurs ? sequenceOccurs : minOccurs;
      }
      break;
    }
  }
  if (sequenceOccurs < minOccurs) {
    if (isRequired && this.strictOccurenceBounds)
      throw new Error("Value supplied for sequence " + name.toString() + " occurs " + sequenceOccurs + " times which falls short of minOccurs " + minOccurs + ".");
    else
      return false;
  }
  return true;
};


/**
 * <code>simpleContent</code> specifies that the content will be simple text
 * only, that is it conforms to a simple type and will not contain elements,
 * although it may also define attributes.
 * 
 * A simpleContent must be defined with an extension or a restriction. An
 * extension specifies the attribute definitions that are to be added to the
 * type and the base attribute specifies from which simple data type this
 * custom type is defined. A restriction for simpleContent is less common,
 * although it may be used to prohibit attributes in derived types also
 * with simpleContent.
 * 
 * simpleContent
 *     (annotation?, (restriction | extension))
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeSimpleContent = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {XML} */ childDefinition = this.getSingleElementFromNode(definition, this.constants.extensionQName, this.constants.restrictionQName);
  if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy))
    org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple = true;
  if (childDefinition != null) {
    var /** @type {string} */ baseName = this.getAttributeFromNode("base", childDefinition);
    if (baseName == null)
      throw new Error("A simpleContent extension or restriction must declare a base type.");
    var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, childDefinition);
    if (!this.isBuiltInType(baseType)) {
      var /** @type {XML} */ baseDefinition = this.schemaManager.getNamedDefinition(baseType, this.constants.complexTypeQName, this.constants.simpleTypeQName);
      if (baseDefinition == null)
        throw new Error("Cannot find base type definition '" + baseType + "'");
      this.schemaManager.releaseScope();
    }
    var /** @type {*} */ simpleValue;
    if (QName.equality(childDefinition.name(),this.constants.extensionQName)) {
      if (this.isBuiltInType(baseType)) {
        simpleValue = this.getSimpleValue(value, name);
        var /** @type {*} */ result = this.marshallBuiltInType(baseType, parent, name, simpleValue, restriction);
        this.setSimpleValue(parent, name, result, baseType);
      } else {
        this.decodeType(baseType, parent, name, value, restriction);
      }
      var /** @type {XMLList} */ extensions = childDefinition.elements();
      var foreachiter12_target = extensions;
      for (var foreachiter12 in foreachiter12_target.elementNames()) 
      {
      var extensionChild = foreachiter12_target[foreachiter12];
      {
        if (QName.equality(extensionChild.name(),this.constants.attributeQName)) {
          this.decodeAttribute(extensionChild, parent, value, restriction);
        } else if (QName.equality(extensionChild.name(),this.constants.attributeGroupQName)) {
          this.decodeAttributeGroup(extensionChild, parent, value, restriction);
        } else if (QName.equality(extensionChild.name(),this.constants.anyAttributeQName)) {
          this.decodeAnyAttribute(extensionChild, parent, value, restriction);
        }
      }}
      
    } else if (QName.equality(childDefinition.name(),this.constants.restrictionQName)) {
      simpleValue = this.getSimpleValue(value, name);
      this.decodeSimpleRestriction(childDefinition, parent, name, simpleValue);
    }
  }
};


/**
 * A <code>simpleType</code> may declare a list of space separated
 * simple content for a single value.
 * 
 * <list
 *     id = ID
 *     itemType = QName >
 *     Content: (annotation?, simpleType?)
 * </list>
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeSimpleList = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {string} */ itemTypeAttribute = org.apache.royale.utils.Language.string(definition.attribute('itemType'));
  var /** @type {QName} */ itemTypeQName;
  var /** @type {XML} */ itemDefinition;
  if (itemTypeAttribute != "")
    itemTypeQName = this.schemaManager.getQNameForPrefixedName(itemTypeAttribute, definition);
  else
    itemDefinition = this.getSingleElementFromNode(definition, this.constants.simpleTypeQName);
  var /** @type {string} */ listValue = "";
  if (!mx.rpc.xml.TypeIterator.isIterable(value))
    value = [value];
  var /** @type {mx.rpc.xml.TypeIterator} */ iter = new mx.rpc.xml.TypeIterator(value);
  while (iter.hasNext()) {
    var /** @type {*} */ item = iter.next();
    var /** @type {*} */ tempValue = this.createContent();
    if (itemTypeQName != null)
      this.decodeType(itemTypeQName, tempValue, name, item, restriction);
    else
      this.decodeSimpleType(itemDefinition, tempValue, name, item, restriction);
    var /** @type {string} */ encodedItem = org.apache.royale.utils.Language.string(tempValue != null ? tempValue.toString() : "");
    listValue = listValue.concat(encodedItem);
    if (iter.hasNext())
      listValue = listValue.concat(" ");
  }
  this.setValue(parent, name, listValue, itemTypeQName);
};


/**
 * simpleType:
 *   restriction: (annotation?, (simpleType?,
 *       (minExclusive | minInclusive | maxExclusive | maxInclusive |
 *       totalDigits | fractionDigits | maxScale | minScale | length |
 *       minLength | maxLength | enumeration | whiteSpace | pattern)*))
 * 
 * @asprivate
 * @export
 * @param {XML} restriction
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 */
mx.rpc.xml.XMLDecoder.prototype.decodeSimpleRestriction = function(restriction, parent, name, value) {
  var /** @type {XML} */ simpleTypeDefinition = this.getSingleElementFromNode(restriction, this.constants.simpleTypeQName);
  if (simpleTypeDefinition != null) {
    this.decodeSimpleType(simpleTypeDefinition, parent, name, value, restriction);
  } else {
    var /** @type {string} */ baseName = this.getAttributeFromNode("base", restriction);
    var /** @type {QName} */ baseType = this.schemaManager.getQNameForPrefixedName(baseName, restriction);
    this.decodeType(baseType, parent, name, value, restriction);
  }
};


/**
 * <simpleType
 *     final = (#all | List of (list | union | restriction | extension))
 *     id = ID
 *     name = NCName>
 *     Content: (annotation?, (restriction | list | union))
 * </simpleType>
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeSimpleType = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {XML} */ definitionChild = this.getSingleElementFromNode(definition, this.constants.restrictionQName, this.constants.listQName, this.constants.unionQName);
  if (QName.equality(definitionChild.name(),this.constants.restrictionQName)) {
    this.decodeSimpleRestriction(definitionChild, parent, name, value);
  } else if (QName.equality(definitionChild.name(),this.constants.listQName)) {
    this.decodeSimpleList(definitionChild, parent, name, value, restriction);
  } else if (QName.equality(definitionChild.name(),this.constants.unionQName)) {
    this.decodeSimpleUnion(definitionChild, parent, name, value, restriction);
  }
};


/**
 * <union
 *     id = ID
 *     memberTypes = List of QName >
 *     Content: (annotation?, simpleType*)
 * </union>
 * 
 * FIXME: This needs a lot of work.
 * 
 * @asprivate
 * @export
 * @param {XML} definition
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeSimpleUnion = function(definition, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {string} */ memberList = this.getAttributeFromNode("memberTypes", definition);
  var /** @type {Array} */ memberArray = memberList.split(" ");
  var /** @type {QName} */ type;
  var /** @type {*} */ args;
  for (var /** @type {number} */ i = 0; i < memberArray.length; i++) {
    var /** @type {string} */ prefixedName = org.apache.royale.utils.Language.string(memberArray[i]);
    var /** @type {QName} */ simpleType = this.schemaManager.getQNameForPrefixedName(prefixedName, definition);
    if (!this.isBuiltInType(simpleType)) {
      args = this.getValue(value, simpleType);
      if (args !== undefined) {
        type = simpleType;
        break;
      }
    }
  }
  if (!type) {
    type = this.schemaManager.schemaDatatypes.stringQName;
  }
  var /** @type {*} */ result = this.marshallBuiltInType(type, parent, name, value, restriction);
  this.setValue(parent, name, result, type);
};


/**
 * @asprivate
 * @export
 * @param {QName} type
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.xml.XMLDecoder.prototype.decodeType = function(type, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  if (this.isBuiltInType(type)) {
    var /** @type {*} */ result = this.marshallBuiltInType(type, parent, name, value, restriction);
    this.setValue(parent, name, result, type);
  } else {
    var /** @type {XML} */ definition = this.schemaManager.getNamedDefinition(type, this.constants.complexTypeQName, this.constants.simpleTypeQName);
    if (definition == null)
      throw new Error("Cannot find definition for type '" + type + "'");
    if (this.isXSINil(value)) {
      this.setValue(parent, name, null, type);
      return;
    }
    var /** @type {QName} */ definitionType = org.apache.royale.utils.Language.as(definition.name(), QName);
    if (QName.equality(definitionType,this.constants.complexTypeQName)) {
      this.decodeComplexType(definition, parent, name, value, restriction);
    } else if (QName.equality(definitionType,this.constants.simpleTypeQName)) {
      this.decodeSimpleType(definition, parent, name, value, restriction);
    } else {
      throw new Error("Invalid type definition " + definitionType);
    }
    this.schemaManager.releaseScope();
  }
  this.setXSIType(parent, type);
};


/**
 * This function controls the marshalling of XML values into
 * ActionScript values for a <code>simpleType</code>.
 * 
 * All simple types are derived from a built-in schema simple types, with
 * the parent being <code>allSimpleTypes</code>. Simple types must not
 * have complex content as they are also used to describe the values of
 * attributes.
 * 
 * If this method is called with the schema <code>anyType</code> and a
 * value with complex content it redirects to decodeAny to handle generic
 * complex types without a type definition.
 * 
 * @asprivate
 * @export
 * @param {QName} type
 * @param {*} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.marshallBuiltInType = function(type, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  if (QName.equality(type,this.constants.anyTypeQName) && !this.isSimpleValue(value)) {
    var /** @type {XMLList} */ propertyList;
    var /** @type {*} */ content;
    if (org.apache.royale.utils.Language.is(value, XML)) {
      var /** @type {XML} */ xml = XML.conversion(value);
      if (xml.nodeKind() == "element") {
        var /** @type {string} */ nilAttribute = xml.attribute(XML.swfCompatibleQuery(this.constants.nilQName)).toString();
        if (nilAttribute == "true")
          return null;
      }
      if (xml.hasSimpleContent()) {
        content = new mx.rpc.xml.SimpleContent(xml.text().toString());
        propertyList = this.filterAttributes(xml.attributes());
        if (propertyList.length() == 0) {
          return this.schemaManager.unmarshall(xml, type, restriction);
        }
      } else {
        content = this.createContent();
        if (org.apache.royale.utils.Language.is(content, mx.rpc.xml.ContentProxy))
          org.apache.royale.utils.Language.as(content, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple = false;
        propertyList = xml.elements();
        propertyList = propertyList.plus(this.filterAttributes(xml.attributes()));
      }
    } else {
      content = this.createContent();
      if (org.apache.royale.utils.Language.is(content, mx.rpc.xml.ContentProxy))
        org.apache.royale.utils.Language.as(content, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple = false;
      propertyList = new XMLList(value);
    }
    this.decodeAnyType(content, name, propertyList);
    return content;
  } else {
    return this.schemaManager.unmarshall(value, type, restriction);
  }
};


/**
 * Resets the decoder to its initial state, including resetting any 
 * Schema scope to the top level and releases the current XML document by
 * setting it to null.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @override
 */
mx.rpc.xml.XMLDecoder.prototype.reset = function() {
  mx.rpc.xml.XMLDecoder.superClass_.reset.apply(this);
  this.document = null;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.getAttribute = function(parent, name) {
  var /** @type {*} */ result;
  var /** @type {XMLList} */ attribute;
  if (org.apache.royale.utils.Language.is(parent, XML)) {
    attribute = XML.conversion(parent).attribute(name);
    result = this.parseValue(name, attribute);
  } else if (org.apache.royale.utils.Language.is(parent, XMLList)) {
    attribute = XMLList.conversion(parent).attribute(name);
    result = this.parseValue(name, attribute);
  }
  return result;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.hasAttribute = function(parent, name) {
  return (this.getAttribute(parent, name) !== undefined);
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @param {*} value
 */
mx.rpc.xml.XMLDecoder.prototype.setAttribute = function(parent, name, value) {
  if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy)) {
    var /** @type {mx.rpc.xml.ContentProxy} */ parentProxy = org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy);
    if (parentProxy.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple) {
      var /** @type {*} */ existingContent = parentProxy.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
      if (!org.apache.royale.utils.Language.is(existingContent, mx.rpc.xml.SimpleContent)) {
        var /** @type {mx.rpc.xml.SimpleContent} */ simpleContent = new mx.rpc.xml.SimpleContent(existingContent);
        parentProxy.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content = simpleContent;
      }
      parentProxy.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple = false;
    }
  }
  this.setValue(parent, name, value);
};


/**
 * @asprivate
 * @export
 * @param {*} value
 * @return {Array}
 */
mx.rpc.xml.XMLDecoder.prototype.getProperties = function(value) {
  var /** @type {Array} */ properties = [];
  var /** @type {XMLList} */ elements;
  if (org.apache.royale.utils.Language.is(value, XML)) {
    elements = XML.conversion(value).elements();
  } else if (org.apache.royale.utils.Language.is(value, XMLList)) {
    elements = XMLList.conversion(value).elements();
  }
  if (elements != null) {
    var foreachiter13_target = elements;
    for (var foreachiter13 in foreachiter13_target.elementNames()) 
    {
    var element = foreachiter13_target[foreachiter13];
    {
      properties.push(element.name());
    }}
    
  }
  return properties;
};


/**
 * @asprivate
 * @export
 * @param {QName=} type
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.createContent = function(type) {
  type = typeof type !== 'undefined' ? type : null;
  var /** @type {*} */ content = undefined;
  if (type != null && this.typeRegistry != null) {
    var /** @type {Object} */ c = this.typeRegistry.getClass(type);
    if (c == null)
      c = this.typeRegistry.getCollectionClass(type);
    if (c != null) {
      try {
        content = new c();
      } catch (e) {
        var /** @type {string} */ className = org.apache.royale.reflection.getQualifiedClassName(c);
        this.mx_rpc_xml_XMLDecoder_log.debug("Unable to create new instance of Class '{0}' for type '{1}'.", className, type);
      }
    }
  }
  return new mx.rpc.xml.ContentProxy(content, this.makeObjectsBindable);
};


/**
 * @asprivate
 * @export
 * @param {*} value
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.isSimpleValue = function(value) {
  if (org.apache.royale.utils.Language.is(value, XML)) {
    var /** @type {XML} */ xml = XML.conversion(value);
    var /** @type {XMLList} */ attributes = xml.attributes();
    if (attributes != null && attributes.length() > 0)
      return false;
    return xml.hasSimpleContent();
  } else if (org.apache.royale.utils.Language.is(value, String) || org.apache.royale.utils.Language.is(value, Number) || org.apache.royale.utils.Language.is(value, Boolean) || org.apache.royale.utils.Language.is(value, Date) || org.apache.royale.utils.Language.is(value, org.apache.royale.utils.Language.synthType('int')) || org.apache.royale.utils.Language.is(value, org.apache.royale.utils.Language.synthType('uint'))) {
    return true;
  }
  return false;
};


/**
 * If the parent only contains simple content, then that content is
 * returned as the value, otherwise getValue is called.
 * 
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.getSimpleValue = function(parent, name) {
  if (org.apache.royale.utils.Language.is(parent, XML)) {
    var /** @type {XML} */ xml = org.apache.royale.utils.Language.as(parent, XML);
    if (xml.hasSimpleContent()) {
      return xml.toString();
    }
  } else if (org.apache.royale.utils.Language.is(parent, XMLList)) {
    var /** @type {XMLList} */ list = org.apache.royale.utils.Language.as(parent, XMLList);
    if (list.hasSimpleContent()) {
      return list.toString();
    }
  } else if (this.isSimpleValue(parent)) {
    return parent;
  }
  return this.getValue(parent, name);
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @param {*} value
 * @param {Object=} type
 */
mx.rpc.xml.XMLDecoder.prototype.setSimpleValue = function(parent, name, value, type) {
  type = typeof type !== 'undefined' ? type : null;
  if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy)) {
    var /** @type {mx.rpc.xml.ContentProxy} */ parentProxy = org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy);
    if (parentProxy.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple) {
      parentProxy.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content = value;
      return;
    }
  }
  this.setValue(parent, name, value, type);
};


/**
 * Assuming the parent is XML, the decoder looks for child element(s) with
 * the given name. If a single child element exists that contains simple
 * content, the simple content is returned unwrapped.
 * @see #parseValue
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} parent
 * @param {*} name
 * @param {number=} index
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.getValue = function(parent, name, index) {
  index = typeof index !== 'undefined' ? index : -1;
  var /** @type {*} */ result;
  var /** @type {QName} */ qname;
  if (org.apache.royale.utils.Language.is(name, QName)) {
    qname = org.apache.royale.utils.Language.as(name, QName);
    if (qname.uri == null || qname.uri == "")
      name = qname.localName;
  }
  var /** @type {XMLList} */ elements;
  if (org.apache.royale.utils.Language.is(parent, XML)) {
    elements = XML.conversion(parent).elements(name);
    if (elements.length() > 0)
      result = this.parseValue(name, elements);
  } else if (org.apache.royale.utils.Language.is(parent, XMLList)) {
    elements = XMLList.conversion(parent).elements(name);
    if (elements.length() > 0)
      result = this.parseValue(name, elements);
  } else if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy)) {
    if (qname != null)
      name = qname.localName;
    result = org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy).hasOwnProperty(name) ? parent[name] : undefined;
  } else if (!this.isSimpleValue(parent)) {
    result = parent[name];
  }
  return result;
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.hasValue = function(parent, name) {
  return (this.getValue(parent, name) !== undefined);
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {*} name
 * @param {*} value
 * @param {Object=} type
 */
mx.rpc.xml.XMLDecoder.prototype.setValue = function(parent, name, value, type) {
  type = typeof type !== 'undefined' ? type : null;
  if (parent != null) {
    if (org.apache.royale.utils.Language.is(value, mx.rpc.xml.ContentProxy))
      value = org.apache.royale.utils.Language.as(value, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
    var /** @type {*} */ existingValue;
    if (mx.rpc.xml.TypeIterator.isIterable(parent)) {
      mx.rpc.xml.TypeIterator.push(parent, value);
    } else if (name != null) {
      var /** @type {string} */ propertyName;
      if (org.apache.royale.utils.Language.is(name, mx.rpc.xml.ContentProxy))
        name = org.apache.royale.utils.Language.as(name, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
      if (org.apache.royale.utils.Language.is(name, QName))
        propertyName = org.apache.royale.utils.Language.as(name, QName, true).localName;
      else
        propertyName = org.apache.royale.utils.Language.resolveUncertain(Object(name)).toString();
      if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy) && org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple) {
        var /** @type {*} */ simpleContent = org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
        if (simpleContent != null) {
          if (this.isSimpleValue(simpleContent) || mx.rpc.xml.TypeIterator.isIterable(simpleContent)) {
            existingValue = simpleContent;
          } else {
            var /** @type {string} */ localName = mx.rpc.xml.XMLDecoder.getUnqualifiedClassName(simpleContent);
            var /** @type {string} */ simplePropName = "_" + localName;
            if (org.apache.royale.utils.Language.resolveUncertain(Object(simpleContent)).hasOwnProperty(simplePropName)) {
              simpleContent[simplePropName] = value;
              return;
            }
            simplePropName = localName.charAt(0).toLowerCase() + localName.substr(1);
            if (org.apache.royale.utils.Language.resolveUncertain(Object(simpleContent)).hasOwnProperty(simplePropName)) {
              simpleContent[simplePropName] = value;
              return;
            }
          }
        }
      } else {
        if (org.apache.royale.utils.Language.resolveUncertain(Object(parent)).hasOwnProperty(propertyName))
          existingValue = this.getExistingValue(parent, propertyName);
        else if (org.apache.royale.utils.Language.resolveUncertain(Object(parent)).hasOwnProperty("_" + propertyName))
          existingValue = this.getExistingValue(parent, "_" + propertyName);
      }
      if (existingValue != null) {
        existingValue = this.promoteValueToArray(existingValue, type);
        mx.rpc.xml.TypeIterator.push(existingValue, value);
        value = existingValue;
      }
      try {
        if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy) && org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__isSimple) {
          org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content = value;
        } else {
          try {
            parent[propertyName] = value;
          } catch (e) {
            parent["_" + propertyName] = value;
          }
        }
      } catch (e) {
        this.mx_rpc_xml_XMLDecoder_log.warn("Unable to set property '{0}' on parent.", propertyName);
      }
    } else if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy)) {
      var /** @type {mx.rpc.xml.ContentProxy} */ proxyParent = org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy);
      existingValue = proxyParent.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
      if (existingValue !== undefined) {
        existingValue = this.promoteValueToArray(existingValue, type);
        proxyParent.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content = existingValue;
        mx.rpc.xml.TypeIterator.push(existingValue, value);
        value = existingValue;
      }
      proxyParent.http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content = value;
    }
  }
};


/**
 * If an array value is required (as when decoding an element
 * with maxOccurs > 1), we need to create an empty Array or the
 * appropriate instance of IList. The optional parameter unwrap
 * can be set to true to indicate that the array should be the
 * parent object itself, and not a property on the parent.
 * 
 * @asparam type Optional. The XML Schema type for the property
 * that holds this iterable value. The SchemaTypeRegistry will be checked
 * to see if a custom collection Class has been registered for that
 * type.
 * 
 * @asprivate
 * @export
 * @param {Object=} type
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.createIterableValue = function(type) {
  type = typeof type !== 'undefined' ? type : null;
  var /** @type {*} */ value;
  try {
    if (type != null) {
      var /** @type {Object} */ c = this.typeRegistry.getCollectionClass(type);
      if (c != null)
        value = new c();
    }
  } catch (e1) {
    this.mx_rpc_xml_XMLDecoder_log.debug("Error while resolving custom collection type for '{0}'.\nError: '{1}'.", type, e1);
  }
  try {
    if (value == null) {
      if (this.makeObjectsBindable) {
        value = new mx.rpc.xml.XMLDecoder.listClass();
      } else {
        value = [];
      }
    }
  } catch (e2) {
    this.mx_rpc_xml_XMLDecoder_log.warn("Unable to create instance of '{0}'.", mx.rpc.xml.XMLDecoder.listClass);
  }
  return value;
};


/**
 * Returns the appropriate values from the list of encoded elements in a
 * model group. In the base case, start from the current index and return
 * consequent elements with the given name. If context.anyIndex > -1 an <any>
 * definition has already decoded some values, so we start at anyIndex until
 * we find a value by the same name, possibly one that has already been
 * decoded. If that is the case, the previously decoded value is removed from
 * the parent.
 * @asprivate
 * @export
 * @param {*} parent
 * @param {XMLList} valueElements
 * @param {QName} name
 * @param {mx.rpc.xml.DecodingContext} context
 * @param {number} maxOccurs
 * @return {XMLList}
 */
mx.rpc.xml.XMLDecoder.prototype.getApplicableValues = function(parent, valueElements, name, context, maxOccurs) {
  var /** @type {XMLList} */ applicableValues = new XMLList();
  var /** @type {number} */ startIndex = (context.index) >>> 0;
  var /** @type {boolean} */ skipAhead = false;
  if (context.anyIndex > -1 && name != null) {
    startIndex = (context.anyIndex) >>> 0;
    skipAhead = true;
  } else if (context.laxSequence) {
    startIndex = 0;
    skipAhead = true;
  }
  for (var /** @type {number} */ i = startIndex; i < valueElements.length(); i++) {
    if (applicableValues.length() == maxOccurs)
      break;
    if (name == null || valueElements[i].name() == name || ((name.uri == "" || name.uri == null) && name.localName == valueElements[i].name().localName)) {
      applicableValues = applicableValues.plus(valueElements[i]);
      if (i < context.index)
        parent[name.localName] = null;
      skipAhead = false;
    } else if (skipAhead == false) {
      break;
    }
  }
  return applicableValues;
};


/**
 * Tests whether a given namespace is included in a wildcard definition. If
 * no restrictions are provided the default behavior is to include all
 * namespaces.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} namespaceURI
 * @param {Array=} includedNamespaces
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.includeNamespace = function(namespaceURI, includedNamespaces) {
  includedNamespaces = typeof includedNamespaces !== 'undefined' ? includedNamespaces : null;
  if (includedNamespaces != null) {
    var /** @type {boolean} */ matchFound = false;
    var foreachiter14_target = includedNamespaces;
    for (var foreachiter14 in foreachiter14_target) 
    {
    var definedURI = foreachiter14_target[foreachiter14];
    {
      if (definedURI == "##local" && namespaceURI == null) {
        return true;
      }
      if (mx.utils.URLUtil.urisEqual(namespaceURI, definedURI)) {
        return true;
      }
    }}
    
    return false;
  }
  return true;
};


/**
 * This method primarily exists to give subclasses a chance to post-process
 * returned value(s) before the decoder processes them. This particular
 * implementation checks to see if the value is not a list of values (i.e.
 * it existed as a single child element) and contains only simple content -
 * if so, the simple content is returned unwrapped.
 * 
 * @asprivate
 * @export
 * @param {*} name
 * @param {XMLList} value
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.parseValue = function(name, value) {
  var /** @type {*} */ result = value;
  if (value.hasSimpleContent()) {
    if (this.isXSINil(value))
      result = null;
    else
      result = value.toString();
  } else if (value.length() == 1) {
    result = value[0];
  }
  return result;
};


/**
 * @export
 * @param {*} value
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.isXSINil = function(value) {
  if (value != null) {
    var /** @type {string} */ nilAttribute = "false";
    if (org.apache.royale.utils.Language.is(value, XML))
      nilAttribute = XML.conversion(value).attribute(XML.swfCompatibleQuery(this.constants.nilQName)).toString();
    else if (org.apache.royale.utils.Language.is(value, XMLList))
      nilAttribute = XMLList.conversion(value).attribute(XML.swfCompatibleQuery(this.constants.nilQName)).toString();
    if (nilAttribute == "true")
      return true;
  }
  return false;
};


/**
 * This function determines whether a given value is already iterable
 * and if not, wraps the value in a suitable iterable implementation. If
 * the value needs to be wrapped, makeObjectsBindable set to false will
 * just wrap the value in an Array where as makeObjectsBindable set to true
 * will wrap the value in the current listClass implementation, which
 * by default is an ArrayCollection.
 * 
 * @asparam value The value to promote to an iterable type, such as an Array.
 * @asparam type Optional. The XML Schema type for the property that
 * will hold this iterable value.
 * 
 * @asprivate
 * @export
 * @param {*} value
 * @param {Object=} type
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.promoteValueToArray = function(value, type) {
  type = typeof type !== 'undefined' ? type : null;
  if (!mx.rpc.xml.TypeIterator.isIterable(value)) {
    var /** @type {*} */ array = this.createIterableValue(type);
    mx.rpc.xml.TypeIterator.push(array, value);
    value = array;
  }
  return value;
};


/**
 * Search for an XSI type attribute on an XML value.
 * 
 * @asprivate
 * @export
 * @param {*} value
 * @return {QName}
 */
mx.rpc.xml.XMLDecoder.prototype.getXSIType = function(value) {
  var /** @type {QName} */ xsiType;
  var /** @type {XML} */ xml;
  if (org.apache.royale.utils.Language.is(value, XML))
    xml = org.apache.royale.utils.Language.as(value, XML);
  else if (org.apache.royale.utils.Language.is(value, XMLList) && value.length() == 1)
    xml = value[0];
  if (xml != null) {
    var /** @type {string} */ xsi = mx.utils.XMLUtil.getAttributeByQName(xml, this.constants.typeAttrQName).toString();
    if (xsi != null && xsi != "")
      xsiType = this.schemaManager.getQNameForPrefixedName(xsi, xml);
  }
  return xsiType;
};


/**
 * We record the qualified type used for anonymous objects wrapped in
 * ObjectProxy or for strongly typed objects that implement
 * IXMLSchemaInstance.
 * 
 * @asprivate
 * @export
 * @param {*} value
 * @param {QName} type
 */
mx.rpc.xml.XMLDecoder.prototype.setXSIType = function(value, type) {
  if (value != null && this.recordXSIType) {
    if (org.apache.royale.utils.Language.is(value, mx.rpc.xml.ContentProxy))
      value = value[new QName(mx.utils.object_proxy, 'content').objectAccessFormat()];
    if (value != null) {
      if (org.apache.royale.utils.Language.is(value, mx.utils.ObjectProxy))
        org.apache.royale.utils.Language.as(value, mx.utils.ObjectProxy, true)[new QName(mx.utils.object_proxy, 'type').objectAccessFormat()] = type;
      else if (org.apache.royale.utils.Language.is(value, mx.rpc.xml.IXMLSchemaInstance))
        org.apache.royale.utils.Language.as(value, mx.rpc.xml.IXMLSchemaInstance, true).xsiType = type;
    }
  }
};


/**
 * @asprivate
 * @export
 * @param {*} parent
 * @param {string} propertyName
 * @return {*}
 */
mx.rpc.xml.XMLDecoder.prototype.getExistingValue = function(parent, propertyName) {
  var /** @type {*} */ existingValue;
  var /** @type {Object} */ object = org.apache.royale.utils.Language.resolveUncertain(Object(parent));
  if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy))
    object = org.apache.royale.utils.Language.as(parent, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
  if (org.apache.royale.utils.Language.is(object, mx.utils.ObjectProxy))
    object = org.apache.royale.utils.Language.as(object, mx.utils.ObjectProxy, true)[new QName(mx.utils.object_proxy, 'object').objectAccessFormat()];
  var /** @type {string} */ className = org.apache.royale.reflection.getQualifiedClassName(object);
  if (className == "Object") {
    existingValue = parent[propertyName];
  } else {
    var /** @type {org.apache.royale.reflection.TypeDefinition} */ td = org.apache.royale.reflection.describeType(object);
    var /** @type {Array} */ props = td.accessors;
    var /** @type {number} */ n = (props.length) >> 0;
    for (var /** @type {number} */ i = 0; i < n; i++) {
      var /** @type {org.apache.royale.reflection.AccessorDefinition} */ ad = props[i];
      if (ad.name == propertyName) {
        if (ad.access == "readwrite") {
          var /** @type {string} */ propertyType = ad.type.qualifiedName;
          var /** @type {*} */ tempValue = parent[propertyName];
          if (propertyType == "Object" || propertyType == "*" || mx.rpc.xml.TypeIterator.isIterable(tempValue))
            existingValue = tempValue;
        }
        break;
      }
    }
  }
  return existingValue;
};


/**
 *  Returns the name of the specified object's class,
 *  such as <code>"Button"</code>
 *
 *  <p>This string does not include the package name.
 *  If you need the package name as well, call the
 *  <code>getQualifiedClassName()</code> method in the flash.utils package.
 *  It will return a string such as <code>"mx.controls::Button"</code>.</p>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} object
 * @return {string}
 */
mx.rpc.xml.XMLDecoder.getUnqualifiedClassName = function(object) {
  var /** @type {string} */ name;
  if (org.apache.royale.utils.Language.is(object, String))
    name = org.apache.royale.utils.Language.as(object, String);
  else
    name = org.apache.royale.reflection.getQualifiedClassName(object);
  var /** @type {number} */ index = (name.indexOf("::")) >> 0;
  if (index != -1)
    name = name.substr(index + 2);
  return name;
};


/**
 * Remove attributes that should not be included in general
 * deserialization to ActionScript, such as internal schema instance
 * attributes.  
 * @asprivate
 * @export
 * @param {XMLList} attributes
 * @return {XMLList}
 */
mx.rpc.xml.XMLDecoder.prototype.filterAttributes = function(attributes) {
  var /** @type {XMLList} */ filtered = attributes.copy();
  for (var /** @type {number} */ i = (filtered.length() - 1) >> 0; i >= 0; i--) {
    var /** @type {XML} */ attr = filtered[i];
    if (attr != null) {
      var /** @type {QName} */ name = org.apache.royale.utils.Language.as(attr.name(), QName);
      if (this.isInternalNamespace(name)) {
        filtered.removeChild(i);
      }
    }
  }
  return filtered;
};


/**
 * Determines whether a name is in an internal (XML Schema specific)
 * namespace (as opposed to a user's namespace).
 * @asprivate 
 * @export
 * @param {QName} name
 * @return {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.isInternalNamespace = function(name) {
  var /** @type {string} */ uri = org.apache.royale.utils.Language.string((name != null) ? name.uri : null);
  if (uri) {
    if (mx.utils.URLUtil.urisEqual(uri, this.constants.xsiNamespace.uri) || mx.utils.URLUtil.urisEqual(uri, this.constants.xsdNamespace.uri)) {
      return true;
    }
  }
  return false;
};


/**
 * Noop. Method exists to give a chance to subclasses to pre-process the
 * encoded XML.
 * @asprivate
 * @export
 * @param {XML} root
 */
mx.rpc.xml.XMLDecoder.prototype.preProcessXML = function(root) {
};


mx.rpc.xml.XMLDecoder.get__listClass = function() {
  var value = mx.collections.ArrayCollection;
  Object.defineProperty(mx.rpc.xml.XMLDecoder, 'listClass', { value: value, writable: true });
  return value;
};
mx.rpc.xml.XMLDecoder.set__listClass = function(value) {
  Object.defineProperty(mx.rpc.xml.XMLDecoder, 'listClass', { value: value, writable: true });
};
Object.defineProperties(mx.rpc.xml.XMLDecoder, /** @lends {mx.rpc.xml.XMLDecoder} */ {
/**
 * @export
 * @type {Object}
 */
listClass: {
  get: mx.rpc.xml.XMLDecoder.get__listClass,
  set: mx.rpc.xml.XMLDecoder.set__listClass,
  configurable: true}});


/**
 * @export
 * @type {XML}
 */
mx.rpc.xml.XMLDecoder.prototype.document;


/**
 * @private
 * @type {mx.logging.ILogger}
 */
mx.rpc.xml.XMLDecoder.prototype.mx_rpc_xml_XMLDecoder_log;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.mx_rpc_xml_XMLDecoder__makeObjectsBindable;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.xml.XMLDecoder.prototype.mx_rpc_xml_XMLDecoder__recordXSIType;


/**
 * @private
 * @type {mx.rpc.xml.SchemaTypeRegistry}
 */
mx.rpc.xml.XMLDecoder.prototype.mx_rpc_xml_XMLDecoder__typeRegistry;


mx.rpc.xml.XMLDecoder.prototype.get__makeObjectsBindable = function() {
  return this.mx_rpc_xml_XMLDecoder__makeObjectsBindable;
};


mx.rpc.xml.XMLDecoder.prototype.set__makeObjectsBindable = function(value) {
  this.mx_rpc_xml_XMLDecoder__makeObjectsBindable = value;
};


mx.rpc.xml.XMLDecoder.prototype.get__recordXSIType = function() {
  return this.mx_rpc_xml_XMLDecoder__recordXSIType;
};


mx.rpc.xml.XMLDecoder.prototype.set__recordXSIType = function(value) {
  this.mx_rpc_xml_XMLDecoder__recordXSIType = value;
};


mx.rpc.xml.XMLDecoder.prototype.get__typeRegistry = function() {
  return this.mx_rpc_xml_XMLDecoder__typeRegistry;
};


mx.rpc.xml.XMLDecoder.prototype.set__typeRegistry = function(value) {
  this.mx_rpc_xml_XMLDecoder__typeRegistry = value;
};


Object.defineProperties(mx.rpc.xml.XMLDecoder.prototype, /** @lends {mx.rpc.xml.XMLDecoder.prototype} */ {
/**
  * @export
  * @type {boolean} */
makeObjectsBindable: {
get: mx.rpc.xml.XMLDecoder.prototype.get__makeObjectsBindable,
set: mx.rpc.xml.XMLDecoder.prototype.set__makeObjectsBindable},
/**
  * @export
  * @type {boolean} */
recordXSIType: {
get: mx.rpc.xml.XMLDecoder.prototype.get__recordXSIType,
set: mx.rpc.xml.XMLDecoder.prototype.set__recordXSIType},
/**
  * @export
  * @type {mx.rpc.xml.SchemaTypeRegistry} */
typeRegistry: {
get: mx.rpc.xml.XMLDecoder.prototype.get__typeRegistry,
set: mx.rpc.xml.XMLDecoder.prototype.set__typeRegistry}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.xml.XMLDecoder.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'XMLDecoder', qName: 'mx.rpc.xml.XMLDecoder', kind: 'class' }], interfaces: [mx.rpc.xml.IXMLDecoder] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.xml.XMLDecoder.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|listClass': { type: 'Class', get_set: function (/** * */ v) {return v !== undefined ? mx.rpc.xml.XMLDecoder.listClass = v : mx.rpc.xml.XMLDecoder.listClass;}}
      };
    },
    accessors: function () {
      return {
        'makeObjectsBindable': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.rpc.xml.XMLDecoder'},
        'recordXSIType': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.rpc.xml.XMLDecoder'},
        'typeRegistry': { type: 'mx.rpc.xml.SchemaTypeRegistry', access: 'readwrite', declaredBy: 'mx.rpc.xml.XMLDecoder'}
      };
    },
    methods: function () {
      return {
        'XMLDecoder': { type: '', declaredBy: 'mx.rpc.xml.XMLDecoder'},
        'decode': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'QName', true ,'QName', true ,'XML', true ]; }},
        'decodeAll': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'XMLList', false ,'mx.rpc.xml.DecodingContext', true ,'Boolean', true ]; }},
        'decodeAnyType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'QName', false ,'XMLList', false ]; }},
        'decodeAnyElement': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'XMLList', false ,'mx.rpc.xml.DecodingContext', true ,'Boolean', true ]; }},
        'decodeAnyAttribute': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'*', true ,'XML', true ]; }},
        'decodeAttribute': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'*', true ,'XML', true ]; }},
        'decodeAttributeGroup': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'*', true ,'XML', true ]; }},
        'decodeChoice': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'XMLList', false ,'mx.rpc.xml.DecodingContext', true ,'Boolean', true ]; }},
        'decodeComplexContent': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'mx.rpc.xml.DecodingContext', false ]; }},
        'decodeComplexExtension': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'mx.rpc.xml.DecodingContext', true ]; }},
        'decodeComplexRestriction': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ]; }},
        'decodeComplexType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'XML', true ,'mx.rpc.xml.DecodingContext', true ]; }},
        'decodeGroupElement': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'XMLList', false ,'mx.rpc.xml.DecodingContext', true ,'Boolean', true ,'Boolean', true ]; }},
        'decodeElementTopLevel': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'QName', false ,'*', false ]; }},
        'decodeGroupReference': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'XMLList', false ,'mx.rpc.xml.DecodingContext', true ,'Boolean', true ]; }},
        'decodeSequence': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'XMLList', false ,'mx.rpc.xml.DecodingContext', true ,'Boolean', true ]; }},
        'decodeSimpleContent': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'decodeSimpleList': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'decodeSimpleRestriction': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ]; }},
        'decodeSimpleType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'decodeSimpleUnion': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'decodeType': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'QName', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'marshallBuiltInType': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'QName', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'reset': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder'},
        'getAttribute': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'hasAttribute': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'setAttribute': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ,'*', false ]; }},
        'getProperties': { type: 'Array', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ]; }},
        'createContent': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'QName', true ]; }},
        'isSimpleValue': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ]; }},
        'getSimpleValue': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'setSimpleValue': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ,'*', false ,'Object', true ]; }},
        'getValue': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ,'Number', true ]; }},
        'hasValue': { type: 'Boolean', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ]; }},
        'setValue': { type: 'void', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ '*', false ,'*', false ,'*', false ,'Object', true ]; }},
        'createIterableValue': { type: '*', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'Object', true ]; }},
        '|getUnqualifiedClassName': { type: 'String', declaredBy: 'mx.rpc.xml.XMLDecoder', parameters: function () { return [ 'Object', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.xml.XMLDecoder.prototype.ROYALE_COMPILE_FLAGS = 26;
