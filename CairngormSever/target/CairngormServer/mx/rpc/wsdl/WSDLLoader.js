/**
 * Generated by Apache Royale Compiler from mx/rpc/wsdl/WSDLLoader.as
 * mx.rpc.wsdl.WSDLLoader
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.wsdl.WSDLLoader');
/* Royale Dependency List: Namespace,QName,XML,XMLList,mx.resources.IResourceManager,mx.resources.ResourceManager,mx.rpc.AsyncToken,mx.rpc.Fault,mx.rpc.events.FaultEvent,mx.rpc.events.ResultEvent,mx.rpc.events.SchemaLoadEvent,mx.rpc.events.WSDLLoadEvent,mx.rpc.http.HTTPService,mx.rpc.wsdl.WSDL,mx.rpc.xml.Schema,mx.rpc.xml.SchemaLoader,mx.rpc.xml.SchemaManager,org.apache.royale.utils.Language*/

goog.require('mx.rpc.xml.XMLLoader');



/**
 * @constructor
 * @extends {mx.rpc.xml.XMLLoader}
 * @param {mx.rpc.http.HTTPService=} httpService
 */
mx.rpc.wsdl.WSDLLoader = function(httpService) {
  httpService = typeof httpService !== 'undefined' ? httpService : null;
  
  this.mx_rpc_wsdl_WSDLLoader_resourceManager = mx.resources.ResourceManager.getInstance();
  mx.rpc.wsdl.WSDLLoader.base(this, 'constructor', httpService);
  this.mx_rpc_wsdl_WSDLLoader_locationMap = {};
  this.mx_rpc_wsdl_WSDLLoader_schemaLoader = new mx.rpc.xml.SchemaLoader(httpService);
  this.mx_rpc_wsdl_WSDLLoader_schemaLoader.addEventListener(mx.rpc.events.SchemaLoadEvent.LOAD, org.apache.royale.utils.Language.closure(this.mx_rpc_wsdl_WSDLLoader_schemaLoadHandler, this, 'schemaLoadHandler'));
};
goog.inherits(mx.rpc.wsdl.WSDLLoader, mx.rpc.xml.XMLLoader);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.wsdl.WSDLLoader', mx.rpc.wsdl.WSDLLoader);


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_resourceManager;


/**
 * Asynchronously loads a WSDL for a given URL, including resolving all
 * WSDL imports and includes and XML Schema imports and includes.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @override
 */
mx.rpc.wsdl.WSDLLoader.prototype.load = function(url) {
  url = this.getQualifiedLocation(url);
  this.mx_rpc_wsdl_WSDLLoader_loadWSDL(url);
};


/**
 * @export
 * @override
 */
mx.rpc.wsdl.WSDLLoader.prototype.faultHandler = function(event) {
  this.loadsOutstanding--;
  var /** @type {string} */ location = org.apache.royale.utils.Language.string(event.token == null ? null : event.token.location);
  var /** @type {string} */ detail = this.mx_rpc_wsdl_WSDLLoader_resourceManager.getString("rpc", "unableToLoadWSDL", [location]);
  var /** @type {mx.rpc.Fault} */ fault = new mx.rpc.Fault(event.fault.faultCode, event.fault.faultString, detail);
  event = mx.rpc.events.FaultEvent.createEvent(fault, event.token, event.message);
  this.dispatchEvent(event);
};


/**
 * @export
 * @override
 */
mx.rpc.wsdl.WSDLLoader.prototype.resultHandler = function(event) {
  mx.rpc.wsdl.WSDLLoader.superClass_.resultHandler.apply(this, [ event] );
  var /** @type {mx.rpc.AsyncToken} */ token = event.token;
  var /** @type {XML} */ xml = XML.conversion(event.result);
  var /** @type {mx.rpc.wsdl.WSDL} */ wsdl;
  var /** @type {string} */ location = org.apache.royale.utils.Language.string(token.location);
  if (token.parent != null) {
    var /** @type {mx.rpc.wsdl.WSDL} */ parent = org.apache.royale.utils.Language.as(token.parent, mx.rpc.wsdl.WSDL);
    var /** @type {Namespace} */ ns = org.apache.royale.utils.Language.as(token.importNamespace, Namespace);
    var /** @type {QName} */ name = org.apache.royale.utils.Language.as(xml.name(), QName);
    if (QName.equality(name,parent.schemaConstants.schemaQName)) {
      var /** @type {mx.rpc.xml.Schema} */ schema = new mx.rpc.xml.Schema(xml);
      this.mx_rpc_wsdl_WSDLLoader_schemaLoader.schemaImports(schema, location, parent.schemaManager);
      parent.addSchema(schema);
      if (this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL != null) {
        this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL.addSchema(schema);
        this.mx_rpc_wsdl_WSDLLoader_schemaImports(this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL, location);
      }
    } else {
      wsdl = new mx.rpc.wsdl.WSDL(xml, this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL ? this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL.schemaManager : null);
      parent.addImport(ns, wsdl);
    }
  } else {
    wsdl = new mx.rpc.wsdl.WSDL(xml);
    this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL = wsdl;
    this.mx_rpc_wsdl_WSDLLoader_topLevelLocation = location;
  }
  if (wsdl != null) {
    this.mx_rpc_wsdl_WSDLLoader_locationMap[location] = wsdl;
    this.mx_rpc_wsdl_WSDLLoader_wsdlImports(wsdl, location);
    this.mx_rpc_wsdl_WSDLLoader_schemaImports(wsdl, location);
  }
  this.mx_rpc_wsdl_WSDLLoader_checkLoadsOutstanding();
};


/**
 * This handler is triggered when all schema imports and
 * includes have loaded. This is necessary as the WSDL imports and
 * includes are likely to be finished before the schema sections.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {mx.rpc.events.SchemaLoadEvent} event
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_schemaLoadHandler = function(event) {
  this.mx_rpc_wsdl_WSDLLoader_checkLoadsOutstanding();
};


/**
 * Checks whether a WSDL and all of its Schemas have finished loading.
 * If there are no loads outstanding, a WSDL load event will be dispatched.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_checkLoadsOutstanding = function() {
  if (this.loadsOutstanding == 0 && this.mx_rpc_wsdl_WSDLLoader_schemaLoader.loadsOutstanding == 0) {
    var /** @type {mx.rpc.events.WSDLLoadEvent} */ loadEvent = mx.rpc.events.WSDLLoadEvent.createEvent(this.mx_rpc_wsdl_WSDLLoader_topLevelWSDL, this.mx_rpc_wsdl_WSDLLoader_topLevelLocation);
    this.dispatchEvent(loadEvent);
  }
};


/**
 * @private
 * @param {string} location
 * @param {mx.rpc.wsdl.WSDL=} parent
 * @param {Namespace=} ns
 * @return {mx.rpc.AsyncToken}
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_loadWSDL = function(location, parent, ns) {
  parent = typeof parent !== 'undefined' ? parent : null;
  ns = typeof ns !== 'undefined' ? ns : null;
  var /** @type {mx.rpc.AsyncToken} */ token = this.internalLoad(location);
  if (token != null) {
    token.parent = parent;
    token.importNamespace = ns;
  }
  return token;
};


/**
 * WSDL definitions can contain imports to other WSDL definitions.
 * 
 * A WSDL import must define a valid namespace and location.
 * 
 * The WSDLLoader attempts to keep track of imports to avoid cyclic
 * dependencies.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {mx.rpc.wsdl.WSDL} wsdl
 * @param {string} parentLocation
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_wsdlImports = function(wsdl, parentLocation) {
  var /** @type {QName} */ importQName = wsdl.wsdlConstants.importQName;
  var /** @type {XMLList} */ imports = wsdl.xml.elements(importQName);
  var foreachiter0_target = imports;
  for (var foreachiter0 in foreachiter0_target.elementNames()) 
  {
  var importNode = foreachiter0_target[foreachiter0];
  {
    var /** @type {string} */ location = importNode.attribute("location").toString();
    var /** @type {string} */ importURI = importNode.attribute("namespace").toString();
    var /** @type {Namespace} */ importNS = new Namespace(importURI);
    location = this.getQualifiedLocation(location, parentLocation);
    var /** @type {mx.rpc.wsdl.WSDL} */ existing = this.mx_rpc_wsdl_WSDLLoader_locationMap[location];
    if (existing == null)
      this.mx_rpc_wsdl_WSDLLoader_loadWSDL(location, wsdl, importNS);
    else
      wsdl.addImport(importNS, existing);
  }}
  
};


/**
 * @private
 * @param {mx.rpc.wsdl.WSDL} wsdl
 * @param {string} parentLocation
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_schemaImports = function(wsdl, parentLocation) {
  var /** @type {mx.rpc.xml.SchemaManager} */ schemaManager = wsdl.schemaManager;
  var /** @type {Array} */ schemas = schemaManager.currentScope();
  for (var /** @type {number} */ s = 0; s < schemas.length; s++) {
    var /** @type {mx.rpc.xml.Schema} */ schema = schemas[s];
    var /** @type {XML} */ schemaXML = schema.xml;
    var /** @type {XMLList} */ includeSchema = schemaXML.elements(schema.schemaConstants.includeQName);
    if (includeSchema != null && includeSchema.length() > 0) {
      this.mx_rpc_wsdl_WSDLLoader_schemaLoader.schemaIncludes(schema, parentLocation);
    }
    this.mx_rpc_wsdl_WSDLLoader_schemaLoader.schemaImports(schema, parentLocation, schemaManager);
  }
};


/**
 * @private
 * @type {mx.rpc.xml.SchemaLoader}
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_schemaLoader;


/**
 * @private
 * @type {mx.rpc.wsdl.WSDL}
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_topLevelWSDL;


/**
 * @private
 * @type {string}
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_topLevelLocation;


/**
 * @private
 * @type {Object}
 */
mx.rpc.wsdl.WSDLLoader.prototype.mx_rpc_wsdl_WSDLLoader_locationMap;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.wsdl.WSDLLoader.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'WSDLLoader', qName: 'mx.rpc.wsdl.WSDLLoader', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.wsdl.WSDLLoader.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'WSDLLoader': { type: '', declaredBy: 'mx.rpc.wsdl.WSDLLoader', parameters: function () { return [ 'mx.rpc.http.HTTPService', true ]; }},
        'load': { type: 'void', declaredBy: 'mx.rpc.wsdl.WSDLLoader', parameters: function () { return [ 'String', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.wsdl.WSDLLoader.prototype.ROYALE_COMPILE_FLAGS = 26;
