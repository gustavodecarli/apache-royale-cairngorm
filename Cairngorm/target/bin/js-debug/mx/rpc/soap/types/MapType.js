/**
 * Generated by Apache Royale Compiler from mx/rpc/soap/types/MapType.as
 * mx.rpc.soap.types.MapType
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.soap.types.MapType');
/* Royale Dependency List: QName,XML,mx.rpc.soap.SOAPDecoder,mx.rpc.soap.SOAPEncoder,mx.rpc.xml.ContentProxy,mx.rpc.xml.SchemaConstants,mx.rpc.xml.SchemaDatatypes,mx.rpc.xml.SchemaMarshaller,mx.utils.ByteArray,mx.utils.object_proxy,org.apache.royale.utils.Language*/

goog.require('mx.rpc.soap.types.ICustomSOAPType');



/**
 * @constructor
 * @implements {mx.rpc.soap.types.ICustomSOAPType}
 */
mx.rpc.soap.types.MapType = function() {
  ;
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.soap.types.MapType', mx.rpc.soap.types.MapType);


/**
 * @export
 * @param {mx.rpc.soap.SOAPEncoder} encoder
 * @param {XML} parent
 * @param {QName} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.soap.types.MapType.prototype.encode = function(encoder, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {mx.rpc.xml.SchemaDatatypes} */ datatypes = encoder.schemaManager.schemaDatatypes;
  for (var /** @type {string} */ item in value) {
    var /** @type {XML} */ itemNode = encoder.createElement(mx.rpc.soap.types.MapType.itemQName);
    var /** @type {XML} */ keyNode = encoder.createElement(mx.rpc.soap.types.MapType.keyQName);
    var /** @type {XML} */ valueNode = encoder.createElement(mx.rpc.soap.types.MapType.valueQName);
    if (item != null)
      encoder.encodeType(datatypes.stringQName, keyNode, mx.rpc.soap.types.MapType.keyQName, item);
    else
      encoder.setValue(keyNode, null);
    encoder.setValue(itemNode, keyNode);
    var /** @type {Object} */ keyValue = value[item];
    if (keyValue != null) {
      var /** @type {string} */ typeLocalName = "string";
      if (org.apache.royale.utils.Language.is(keyValue, Number)) {
        if (org.apache.royale.utils.Language.is(keyValue, org.apache.royale.utils.Language.synthType('uint'))) {
          typeLocalName = "unsignedInt";
        } else if (org.apache.royale.utils.Language.is(keyValue, org.apache.royale.utils.Language.synthType('int'))) {
          typeLocalName = "int";
        } else {
          typeLocalName = "double";
        }
      } else if (org.apache.royale.utils.Language.is(keyValue, Boolean)) {
        typeLocalName = "boolean";
      } else if (org.apache.royale.utils.Language.is(keyValue, String)) {
        typeLocalName = "string";
      } else if (org.apache.royale.utils.Language.is(keyValue, mx.utils.ByteArray)) {
        if (mx.rpc.xml.SchemaMarshaller.byteArrayAsBase64Binary)
          typeLocalName = "base64Binary";
        else
          typeLocalName = "hexBinary";
      } else if (org.apache.royale.utils.Language.is(keyValue, Date)) {
        typeLocalName = "dateTime";
      }
      var /** @type {mx.rpc.xml.SchemaConstants} */ constants = encoder.schemaManager.schemaConstants;
      var /** @type {QName} */ type = (typeLocalName != null) ? new QName(constants.xsdURI, typeLocalName) : null;
      encoder.encodeType(type, valueNode, mx.rpc.soap.types.MapType.valueQName, keyValue);
    } else {
      encoder.setValue(valueNode, null);
    }
    encoder.setValue(itemNode, valueNode);
    encoder.setValue(parent, itemNode);
  }
};


/**
 * @export
 * @param {mx.rpc.soap.SOAPDecoder} decoder
 * @param {*} parent
 * @param {*} name
 * @param {*} value
 * @param {XML=} restriction
 */
mx.rpc.soap.types.MapType.prototype.decode = function(decoder, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  if (org.apache.royale.utils.Language.is(parent, mx.rpc.xml.ContentProxy))
    parent[new QName(mx.utils.object_proxy, 'isSimple').objectAccessFormat()] = false;
  var /** @type {mx.rpc.xml.SchemaConstants} */ constants = decoder.schemaManager.schemaConstants;
  var /** @type {XML} */ mapValue = org.apache.royale.utils.Language.as(value, XML);
  var foreachiter0_target = mapValue.elements();
  for (var foreachiter0 in foreachiter0_target) 
  {
  var item = foreachiter0_target[foreachiter0];
  {
    var /** @type {Object} */ key;
    var /** @type {Object} */ itemValue;
    var foreachiter1_target = item.elements();
    for (var foreachiter1 in foreachiter1_target) 
    {
    var itemChild = foreachiter1_target[foreachiter1];
    {
      var /** @type {string} */ typeName = org.apache.royale.utils.Language.string(itemChild.attribute(XML.swfCompatibleQuery(constants.typeAttrQName)));
      var /** @type {QName} */ type;
      if (typeName != null && typeName != "")
        type = decoder.schemaManager.getQNameForPrefixedName(typeName, itemChild);
      else
        type = constants.anyTypeQName;
      if (itemChild.localName() == "key") {
        key = decoder.createContent();
        decoder.decodeType(type, key, org.apache.royale.utils.Language.as(itemChild.name(), QName), itemChild);
      } else if (itemChild.localName() == "value") {
        itemValue = decoder.createContent();
        decoder.decodeType(type, itemValue, org.apache.royale.utils.Language.as(itemChild.name(), QName), itemChild);
      } else {
        throw new Error("Apache Map datatype must only contain key/value pairs.");
      }
    }}
    
    decoder.setValue(parent, key, itemValue);
  }}
  
};


mx.rpc.soap.types.MapType.get__itemQName = function() {
  var value = new QName("", "item");
  Object.defineProperty(mx.rpc.soap.types.MapType, 'itemQName', { value: value, writable: true });
  return value;
};
mx.rpc.soap.types.MapType.set__itemQName = function(value) {
  Object.defineProperty(mx.rpc.soap.types.MapType, 'itemQName', { value: value, writable: true });
};
Object.defineProperties(mx.rpc.soap.types.MapType, /** @lends {mx.rpc.soap.types.MapType} */ {
/**
 * @export
 * @type {QName}
 */
itemQName: {
  get: mx.rpc.soap.types.MapType.get__itemQName,
  set: mx.rpc.soap.types.MapType.set__itemQName,
  configurable: true}});


mx.rpc.soap.types.MapType.get__keyQName = function() {
  var value = new QName("", "key");
  Object.defineProperty(mx.rpc.soap.types.MapType, 'keyQName', { value: value, writable: true });
  return value;
};
mx.rpc.soap.types.MapType.set__keyQName = function(value) {
  Object.defineProperty(mx.rpc.soap.types.MapType, 'keyQName', { value: value, writable: true });
};
Object.defineProperties(mx.rpc.soap.types.MapType, /** @lends {mx.rpc.soap.types.MapType} */ {
/**
 * @export
 * @type {QName}
 */
keyQName: {
  get: mx.rpc.soap.types.MapType.get__keyQName,
  set: mx.rpc.soap.types.MapType.set__keyQName,
  configurable: true}});


mx.rpc.soap.types.MapType.get__valueQName = function() {
  var value = new QName("", "value");
  Object.defineProperty(mx.rpc.soap.types.MapType, 'valueQName', { value: value, writable: true });
  return value;
};
mx.rpc.soap.types.MapType.set__valueQName = function(value) {
  Object.defineProperty(mx.rpc.soap.types.MapType, 'valueQName', { value: value, writable: true });
};
Object.defineProperties(mx.rpc.soap.types.MapType, /** @lends {mx.rpc.soap.types.MapType} */ {
/**
 * @export
 * @type {QName}
 */
valueQName: {
  get: mx.rpc.soap.types.MapType.get__valueQName,
  set: mx.rpc.soap.types.MapType.set__valueQName,
  configurable: true}});


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.soap.types.MapType.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'MapType', qName: 'mx.rpc.soap.types.MapType', kind: 'class' }], interfaces: [mx.rpc.soap.types.ICustomSOAPType] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.soap.types.MapType.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|itemQName': { type: 'QName', get_set: function (/** * */ v) {return v !== undefined ? mx.rpc.soap.types.MapType.itemQName = v : mx.rpc.soap.types.MapType.itemQName;}},
        '|keyQName': { type: 'QName', get_set: function (/** * */ v) {return v !== undefined ? mx.rpc.soap.types.MapType.keyQName = v : mx.rpc.soap.types.MapType.keyQName;}},
        '|valueQName': { type: 'QName', get_set: function (/** * */ v) {return v !== undefined ? mx.rpc.soap.types.MapType.valueQName = v : mx.rpc.soap.types.MapType.valueQName;}}
      };
    },
    methods: function () {
      return {
        'MapType': { type: '', declaredBy: 'mx.rpc.soap.types.MapType'},
        'encode': { type: 'void', declaredBy: 'mx.rpc.soap.types.MapType', parameters: function () { return [ 'mx.rpc.soap.SOAPEncoder', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'decode': { type: 'void', declaredBy: 'mx.rpc.soap.types.MapType', parameters: function () { return [ 'mx.rpc.soap.SOAPDecoder', false ,'*', false ,'*', false ,'*', false ,'XML', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.soap.types.MapType.prototype.ROYALE_COMPILE_FLAGS = 26;
