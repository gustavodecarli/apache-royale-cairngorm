/**
 * Generated by Apache Royale Compiler from mx/rpc/soap/SOAPEncoder.as
 * mx.rpc.soap.SOAPEncoder
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.soap.SOAPEncoder');
/* Royale Dependency List: Namespace,QName,XML,XMLList,mx.logging.ILogger,mx.logging.Log,mx.resources.IResourceManager,mx.resources.ResourceManager,mx.rpc.soap.SOAPConstants,mx.rpc.soap.types.ICustomSOAPType,mx.rpc.wsdl.WSDLEncoding,mx.rpc.wsdl.WSDLMessagePart,mx.rpc.wsdl.WSDLOperation,mx.rpc.xml.SchemaConstants,mx.rpc.xml.SchemaDatatypes,mx.rpc.xml.SchemaMarshaller,org.apache.royale.utils.Language*/

goog.require('mx.rpc.xml.XMLEncoder');
goog.require('mx.rpc.soap.ISOAPEncoder');



/**
 * @constructor
 * @extends {mx.rpc.xml.XMLEncoder}
 * @implements {mx.rpc.soap.ISOAPEncoder}
 */
mx.rpc.soap.SOAPEncoder = function() {
  
  this.mx_rpc_soap_SOAPEncoder_resourceManager = mx.resources.ResourceManager.getInstance();
  mx.rpc.soap.SOAPEncoder.base(this, 'constructor');
  this.mx_rpc_soap_SOAPEncoder_log = mx.logging.Log.getLogger("mx.rpc.soap.SOAPEncoder");
};
goog.inherits(mx.rpc.soap.SOAPEncoder, mx.rpc.xml.XMLEncoder);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.soap.SOAPEncoder', mx.rpc.soap.SOAPEncoder);


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.rpc.soap.SOAPEncoder.prototype.mx_rpc_soap_SOAPEncoder_resourceManager;


/**
 *  @inheritDoc
 * @export
 * @param {*=} args
 * @param {Array=} headers
 * @return {XML}
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeRequest = function(args, headers) {
  args = typeof args !== 'undefined' ? args : null;
  headers = typeof headers !== 'undefined' ? headers : null;
  this.reset();
  var /** @type {XML} */ envelopeXML;
  var /** @type {boolean} */ oldIgnoreWhitespace = !!(XML.ignoreWhitespace);
  var /** @type {boolean} */ oldPrettyPrinting = !!(XML.prettyPrinting);
  try {
    XML.ignoreWhitespace = this.ignoreWhitespace;
    XML.prettyPrinting = false;
    envelopeXML = this.encodeEnvelope(args, headers);
  } finally {
    XML.ignoreWhitespace = oldIgnoreWhitespace;
    XML.prettyPrinting = oldPrettyPrinting;
  }
  return envelopeXML;
};


/**
 * A SOAP Envelope element is the root element of a SOAP message. It
 * must specify the SOAP namespace.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} args
 * @param {Array} headers
 * @return {XML}
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeEnvelope = function(args, headers) {
  this.mx_rpc_soap_SOAPEncoder_log.debug("Encoding SOAP request envelope");
  var /** @type {XML} */ envelopeXML = new XML( '<' + this.soapConstants.envelopeQName.localName + '/>');
  envelopeXML.setNamespace(this.soapConstants.envelopeNamespace);
  envelopeXML.addNamespace(this.schemaConstants.xsdNamespace);
  envelopeXML.addNamespace(this.schemaConstants.xsiNamespace);
  this.schemaManager.namespaces[this.soapConstants.envelopeNamespace.prefix] = this.soapConstants.envelopeNamespace;
  this.encodeHeaders(headers, envelopeXML);
  this.encodeBody(args, envelopeXML);
  return envelopeXML;
};


/**
 * Appends SOAP Header to the SOAP Envelope
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Array} headers
 * @param {XML} envelopeXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeHeaders = function(headers, envelopeXML) {
  if (headers != null) {
    var /** @type {number} */ count = (headers.length) >>> 0;
    if (count > 0) {
      var /** @type {XML} */ headersXML = new XML( '<' + this.soapConstants.headerQName.localName + '/>                 ');
      headersXML.setNamespace(this.soapConstants.envelopeNamespace);
      envelopeXML.appendChild(headersXML);
      for (var /** @type {number} */ i = 0; i < count; i++) {
        this.encodeHeaderElement(headers[i], headersXML);
      }
    }
  }
};


/**
 * Appends a header element to top SOAP Header tag
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} header
 * @param {XML} headersXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeHeaderElement = function(header, headersXML) {
  var /** @type {*} */ preEncodedNode = this.preEncodedCheck(header);
  if (preEncodedNode != null) {
    headersXML.appendChild(header);
  } else {
    var /** @type {XMLList} */ headerElement = new XMLList();
    if (header.content != null && header.content.hasOwnProperty(header.qname.localName)) {
      header.content = header.content[header.qname.localName];
    }
    preEncodedNode = this.preEncodedCheck(header.content);
    if (preEncodedNode != null) {
      if (org.apache.royale.utils.Language.is(preEncodedNode, XMLList)) {
        headerElement = org.apache.royale.utils.Language.as(preEncodedNode, XMLList);
      } else {
        headerElement = new XMLList(preEncodedNode);
      }
    } else {
      headerElement = this.encode(header.content, header.qname);
    }
    var foreachiter0_target = headerElement;
    for (var foreachiter0 in foreachiter0_target.elementNames()) 
    {
    var headerElementNode = foreachiter0_target[foreachiter0];
    {
      if (header.qname.uri != null && header.qname.uri.length > 0 && headerElementNode.namespace().uri != header.qname.uri) {
        var /** @type {string} */ prefix = this.schemaManager.getOrCreatePrefix(org.apache.royale.utils.Language.string(header.qname.uri));
        var /** @type {Namespace} */ ns = new Namespace(prefix, header.qname.uri);
        headerElementNode.setNamespace(ns);
      }
      var /** @type {string} */ attrStr;
      if (header.mustUnderstand) {
        attrStr = this.schemaManager.getOrCreatePrefix(this.soapConstants.mustUnderstandQName.uri);
        headerElementNode.setAttribute(attrStr + ":" + this.soapConstants.mustUnderstandQName.localName, "1");
      }
      if (header.role != null) {
        attrStr = this.schemaManager.getOrCreatePrefix(this.soapConstants.actorQName.uri);
        headerElementNode.setAttribute(attrStr + ":" + this.soapConstants.actorQName.localName, header.role);
      }
    }}
    
    headersXML.appendChild(headerElement);
  }
};


/**
 * Encodes the SOAP Body. Currently assumes only one operation sub-element.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} inputParams
 * @param {XML} envelopeXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeBody = function(inputParams, envelopeXML) {
  this.mx_rpc_soap_SOAPEncoder_log.debug("Encoding SOAP request body");
  var /** @type {XML} */ bodyXML = new XML( '<' + this.soapConstants.bodyQName.localName + '/>');
  bodyXML.setNamespace(this.soapConstants.envelopeNamespace);
  var /** @type {Object} */ preEncoded = this.preEncodedCheck(inputParams);
  if (preEncoded != null) {
    bodyXML.appendChild(preEncoded);
  } else {
    if (this.wsdlOperation.style == mx.rpc.soap.SOAPConstants.DOC_STYLE) {
      if (this.inputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_LITERAL) {
        this.encodeOperationAsDocumentLiteral(inputParams, bodyXML);
      } else {
        throw new Error("WSDL 1.1 supports operations with binding style 'document' only if use style is 'literal'.");
      }
    } else if (this.wsdlOperation.style == mx.rpc.soap.SOAPConstants.RPC_STYLE) {
      if (this.inputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_LITERAL) {
        this.encodeOperationAsRPCLiteral(inputParams, bodyXML);
      } else if (this.inputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_ENCODED) {
        this.encodeOperationAsRPCEncoded(inputParams, bodyXML);
      } else {
        throw new Error("WSDL 1.1 does not support operations with binding style 'rpc' and use style " + this.inputEncoding.useStyle + ".");
      }
    } else {
      throw new Error("Unrecognized binding style '" + this.wsdlOperation.style + "'. Only 'document' and 'rpc' styles are supported.");
    }
  }
  envelopeXML.appendChild(bodyXML);
};


/**
 * Encodes a WSDL operation using document literal format.
 * There's no need to generate an operation element so advance directly
 * to encoding the message.
 * <p>
 * From the WSDL 1.1 specification:
 * </p>
 * <p>
 * &quot;If <code>use</code> is <b>literal</b>, then each part references
 * a concrete schema definition using either the <code>element</code> or
 * <code>type</code> attribute. In the first case, the element referenced
 * by the part will appear directly under the Body element (for document
 * style bindings)... In the second, the type referenced by the part
 * becomes the schema type of the enclosing element (Body for document
 * style...).&quot;
 * </p>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} inputParams
 * @param {XML} bodyXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeOperationAsDocumentLiteral = function(inputParams, bodyXML) {
  var /** @type {Array} */ parts = this.wsdlOperation.inputMessage.parts;
  if (this.wsdlOperation.inputMessage.isWrapped) {
    var /** @type {QName} */ wrappedQName = this.wsdlOperation.inputMessage.wrappedQName;
    var /** @type {XML} */ operationXML = new XML( '<' + wrappedQName.localName + '/>');
    if (wrappedQName.uri != null && wrappedQName.uri != "") {
      var /** @type {string} */ prefix = this.schemaManager.getOrCreatePrefix(wrappedQName.uri);
      var /** @type {Namespace} */ inputNamespace = new Namespace(prefix, wrappedQName.uri);
      operationXML.setNamespace(inputNamespace);
    }
    this.encodeMessage(inputParams, operationXML);
    bodyXML.appendChild(operationXML);
  } else {
    this.encodeMessage(inputParams, bodyXML);
  }
};


/**
 * Encodes a WSDL operation using RPC literal format.
 * <p>
 * From the WSDL 1.1 specification:
 * </p>
 * <p>
 * &quot;If the operation style is <code>rpc</code> each part is a parameter
 * or a return value and appears inside a wrapper element within the body
 * (following Section 7.1 of the SOAP specification). The wrapper element
 * is named identically to the operation name and its namespace is the
 * value of the namespace attribute. Each message part (parameter) appears
 * under the wrapper, represented by an accessor named identically to the
 * corresponding parameter of the call. Parts are arranged in the same
 * order as the parameters of the call.&quot;
 * </p>
 * <p>
 * &quot;If <code>use</code> is <b>literal</b>, then each part references
 * a concrete schema definition using either the <code>element</code> or
 * <code>type</code> attribute. In the first case, the element referenced
 * by the part will appear ... under an accessor element named after the
 * message part (in rpc style). In the second, the type referenced by the
 * part becomes the schema type of the enclosing element ( ... part accessor
 * element for rpc style).&quot;
 * </p>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} inputParams
 * @param {XML} bodyXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeOperationAsRPCLiteral = function(inputParams, bodyXML) {
  var /** @type {XML} */ operationXML = new XML( '<' + this.wsdlOperation.name + '/>');
  var /** @type {string} */ prefix = this.schemaManager.getOrCreatePrefix(this.inputEncoding.namespaceURI);
  var /** @type {Namespace} */ ns = new Namespace(prefix, this.inputEncoding.namespaceURI);
  operationXML.setNamespace(ns);
  this.encodeMessage(inputParams, operationXML);
  bodyXML.appendChild(operationXML);
};


/**
 * Encodes a WSDL message part using RPC encoded format.
 * <p>
 * From the WSDL 1.1 specification:
 * </p>
 * <p>
 * &quot;If the operation style is <code>rpc</code> each part is a parameter
 * or a return value and appears inside a wrapper element within the body
 * (following Section 7.1 of the SOAP specification). The wrapper element
 * is named identically to the operation name and its namespace is the
 * value of the namespace attribute. Each message part (parameter) appears
 * under the wrapper, represented by an accessor named identically to the
 * corresponding parameter of the call. Parts are arranged in the same
 * order as the parameters of the call.&quot;
 * </p>
 * <p>
 * &quot;If <code>use</code> is <b>encoded</b>, then each message part
 * references an abstract type using the <code>type</code> attribute. These
 * abstract types are used to produce a concrete message by applying an
 * encoding specified by the <code>encodingStyle</code> attribute. The part
 * names, types and value of the namespace attribute are all inputs to the
 * encoding, although the namespace attribute only applies to content not
 * explicitly defined by the abstract types. If the referenced encoding
 * style allows variations in it's format (such as the SOAP encoding does),
 * then all variations MUST be supported ("reader makes right").&quot;
 * </p>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} inputParams
 * @param {XML} bodyXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeOperationAsRPCEncoded = function(inputParams, bodyXML) {
  this.mx_rpc_soap_SOAPEncoder_isSOAPEncoding = true;
  var /** @type {XML} */ operationXML = new XML( '<' + this.wsdlOperation.name + '/>');
  var /** @type {string} */ inputNamespaceURI = this.inputEncoding.namespaceURI;
  var /** @type {string} */ inputPrefix = this.schemaManager.getOrCreatePrefix(inputNamespaceURI);
  var /** @type {Namespace} */ inputNamespace = new Namespace(inputPrefix, inputNamespaceURI);
  operationXML.setNamespace(inputNamespace);
  this.encodeMessage(inputParams, operationXML);
  bodyXML.appendChild(operationXML);
  bodyXML.setAttribute(mx.rpc.soap.SOAPConstants.SOAP_ENV_PREFIX + ":encodingStyle", this.soapConstants.encodingURI);
};


/**
 * Encodes an input message for a WSDL operation. The provided input
 * parameters are validated against the required message parts.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} inputParams
 * @param {XML} operationXML
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeMessage = function(inputParams, operationXML) {
  var /** @type {Array} */ parts;
  if (this.wsdlOperation.inputMessage != null)
    parts = this.wsdlOperation.inputMessage.parts;
  if (parts == null)
    return;
  var /** @type {Object} */ partNames = {};
  var /** @type {number} */ optionalOmitted = 0;
  var /** @type {string} */ message;
  for (var /** @type {number} */ i = 0; i < parts.length; i++) {
    var /** @type {mx.rpc.wsdl.WSDLMessagePart} */ part = parts[i];
    var /** @type {*} */ value = undefined;
    if (org.apache.royale.utils.Language.is(inputParams, Array)) {
      value = inputParams[i];
      if (value === undefined) {
        if (part.optional) {
          optionalOmitted++;
        } else {
          message = this.mx_rpc_soap_SOAPEncoder_resourceManager.getString("rpc", "missingInputParameter", [i]);
          throw new Error(message);
        }
      }
    } else {
      var /** @type {string} */ name = part.name.localName;
      if (inputParams != null)
        value = inputParams[name];
      partNames[name] = value;
      if (value === undefined || (inputParams != null && !inputParams.hasOwnProperty(name))) {
        if (part.optional) {
          optionalOmitted++;
        } else {
          message = this.mx_rpc_soap_SOAPEncoder_resourceManager.getString("rpc", "missingInputParameterWithName", [name]);
          throw new Error(message);
        }
      }
    }
    if (value !== undefined) {
      var /** @type {XMLList} */ partXMLList = this.encodePartValue(part, value);
      operationXML.appendChild(partXMLList);
    }
  }
  if (inputParams != null) {
    if (org.apache.royale.utils.Language.is(inputParams, Array)) {
      if (inputParams.length < (parts.length - optionalOmitted)) {
        message = this.mx_rpc_soap_SOAPEncoder_resourceManager.getString("rpc", "tooFewInputParameters", [parts.length, inputParams.length]);
        throw new Error(message);
      }
    } else {
      for (var /** @type {string} */ inName in inputParams) {
        if (!partNames.hasOwnProperty(inName)) {
          message = this.mx_rpc_soap_SOAPEncoder_resourceManager.getString("rpc", "unexpectedInputParameter", [inName]);
          throw new Error(message);
        }
      }
    }
  }
};


/**
 * A WSDL message part may either refer to an XML Schema type (that is, a
 * &lt;complexType&gt; or &lt;simpleType&gt;) directly by QName or to an element
 * definition by QName depending on the SOAP use and encodingStyle
 * attributes.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {mx.rpc.wsdl.WSDLMessagePart} part
 * @param {*} value
 * @return {XMLList}
 */
mx.rpc.soap.SOAPEncoder.prototype.encodePartValue = function(part, value) {
  var /** @type {XMLList} */ partXMLList;
  if (part.element != null) {
    partXMLList = this.encode(value, part.element);
  } else {
    partXMLList = this.encode(value, part.name, part.type, part.definition);
  }
  return partXMLList;
};


/**
 * Looks to see whether a pre-encoded SOAP request has been passed to the
 * encoder.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} value
 * @return {Object}
 */
mx.rpc.soap.SOAPEncoder.prototype.preEncodedCheck = function(value) {
  var /** @type {Object} */ preEncodedNode = null;
  if (value != null) {
    if (org.apache.royale.utils.Language.is(value, XMLList)) {
      preEncodedNode = org.apache.royale.utils.Language.as(value, XMLList);
    } else if (org.apache.royale.utils.Language.is(value, XML)) {
      preEncodedNode = org.apache.royale.utils.Language.as(value, XML);
    }
  }
  return preEncodedNode;
};


/**
 * SOAP specific override to handle special wrapped-style document-literal 
 * parameters which can specify minOccurs and maxOccurs attributes on
 * local element definitions that are, for all intents and purposes,
 * really top-level element definitions representing operation parts.
 * XML Schema does not normally allow minOccurs or maxOccurs on top-level
 * element definitions and the SchemaProcessor is not looking out for them
 * so we have to special case this situation here.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @override
 */
mx.rpc.soap.SOAPEncoder.prototype.encode = function(value, name, type, definition) {
  name = typeof name !== 'undefined' ? name : null;
  type = typeof type !== 'undefined' ? type : null;
  definition = typeof definition !== 'undefined' ? definition : null;
  if (definition != null) {
    var /** @type {XMLList} */ result = new XMLList();
    var /** @type {number} */ maxOccurs = this.getMaxOccurs(definition);
    var /** @type {number} */ minOccurs = this.getMinOccurs(definition);
    if (maxOccurs == 0)
      return result;
    if (value == null && minOccurs == 0)
      return result;
    if (maxOccurs > 1) {
      var /** @type {XMLList} */ content = new XMLList();
      var /** @type {boolean} */ foundScope = this.schemaManager.pushNamespaceInScope(name.uri);
      this.encodeGroupElement(definition, content, name, value);
      if (foundScope)
        this.schemaManager.releaseScope();
      result = result.plus(content);
      return result;
    }
  }
  return mx.rpc.soap.SOAPEncoder.superClass_.encode.apply(this, [ value, name, type, definition] );
};


/**
 * SOAP specific override to intercept SOAP encoded types such as base64.
 * Also, SOAP encoding requires an XSI type attribute to be specified on
 * encoded types.
 * 
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeType = function(type, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {mx.rpc.xml.SchemaDatatypes} */ datatypes = this.schemaManager.schemaDatatypes;
  var /** @type {QName} */ xsiType = this.getXSIType(value);
  if (xsiType != null)
    type = xsiType;
  if (this.mx_rpc_soap_SOAPEncoder_isSOAPEncoding) {
    xsiType = type;
    if (mx.rpc.soap.SOAPConstants.isSOAPEncodedType(type)) {
      if (QName.equality(type,this.soapConstants.soapBase64QName)) {
        type = datatypes.base64BinaryQName;
      } else {
        var /** @type {string} */ localName = type.localName;
        if (localName != "Array" && localName != "arrayType") {
          type = this.schemaConstants.getQName(localName);
        }
      }
    }
  }
  var /** @type {mx.rpc.soap.types.ICustomSOAPType} */ customType = mx.rpc.soap.SOAPConstants.getCustomSOAPType(type);
  if (customType != null) {
    customType.encode(this, parent, name, value, restriction);
  } else {
    mx.rpc.soap.SOAPEncoder.superClass_.encodeType.apply(this, [ type, parent, name, value, restriction] );
  }
  if (xsiType != null) {
    var /** @type {string} */ xsiTypeAttr = org.apache.royale.utils.Language.string(parent.attribute(this.schemaConstants.getXSIToken(this.schemaConstants.typeAttrQName)));
    if (xsiTypeAttr == null || xsiTypeAttr == "") {
      mx.rpc.soap.SOAPEncoder.superClass_.setXSIType.apply(this, [ parent, xsiType] );
    }
  }
};


/**
 * This override intercepts encoding a complexType with complexContent based
 * on a SOAP encoded Array. This awkward approach to Array type definitions
 * was popular in WSDL 1.1 rpc-encoded operations and is a special case that
 * needs to be handled, but note it violates the WS-I Basic Profile 1.0.
 * 
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPEncoder.prototype.encodeComplexRestriction = function(restriction, parent, name, value) {
  var /** @type {mx.rpc.xml.SchemaConstants} */ schemaConstants = this.schemaManager.schemaConstants;
  var /** @type {string} */ baseName = org.apache.royale.utils.Language.string(restriction.attribute('base'));
  var /** @type {QName} */ baseQName = this.schemaManager.getQNameForPrefixedName(baseName, restriction);
  if (QName.equality(baseQName,this.soapConstants.soapencArrayQName)) {
    var /** @type {mx.rpc.soap.types.ICustomSOAPType} */ customType = mx.rpc.soap.SOAPConstants.getCustomSOAPType(baseQName);
    if (customType != null) {
      customType.encode(this, parent, name, value, restriction);
      return;
    }
  }
  mx.rpc.soap.SOAPEncoder.superClass_.encodeComplexRestriction.apply(this, [ restriction, parent, name, value] );
};


/**
 * This override tries to determine the XSI type for the encoded value if
 * SOAP use style is set to <code>encoded</code>.
 * 
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPEncoder.prototype.deriveXSIType = function(parent, type, value) {
  if (this.mx_rpc_soap_SOAPEncoder_isSOAPEncoding) {
    var /** @type {mx.rpc.xml.SchemaDatatypes} */ datatypes = this.schemaManager.schemaDatatypes;
    var /** @type {QName} */ soapType;
    if (QName.equality(type,datatypes.anyTypeQName) || QName.equality(type,datatypes.anySimpleTypeQName)) {
      if (this.isSimpleValue(value) || QName.equality(type,datatypes.anySimpleTypeQName)) {
        var /** @type {string} */ localName = org.apache.royale.utils.Language.string(mx.rpc.xml.SchemaMarshaller.guessSimpleType(value));
        soapType = new QName(this.schemaConstants.xsdURI, localName);
      }
    } else {
      soapType = type;
    }
    if (soapType != null) {
      parent.setAttribute(this.schemaConstants.getXSIToken(this.schemaConstants.typeAttrQName), this.schemaConstants.getXSDToken(soapType));
    }
  }
};


/**
 * @private
 * @type {boolean}
 */
mx.rpc.soap.SOAPEncoder.prototype.mx_rpc_soap_SOAPEncoder__ignoreWhitespace = true;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.soap.SOAPEncoder.prototype.mx_rpc_soap_SOAPEncoder_isSOAPEncoding = false;


/**
 * @private
 * @type {mx.logging.ILogger}
 */
mx.rpc.soap.SOAPEncoder.prototype.mx_rpc_soap_SOAPEncoder_log;


/**
 * @private
 * @type {mx.rpc.wsdl.WSDLOperation}
 */
mx.rpc.soap.SOAPEncoder.prototype.mx_rpc_soap_SOAPEncoder__wsdlOperation;


mx.rpc.soap.SOAPEncoder.prototype.get__ignoreWhitespace = function() {
  return this.mx_rpc_soap_SOAPEncoder__ignoreWhitespace;
};


mx.rpc.soap.SOAPEncoder.prototype.set__ignoreWhitespace = function(value) {
  this.mx_rpc_soap_SOAPEncoder__ignoreWhitespace = value;
};


mx.rpc.soap.SOAPEncoder.prototype.get__inputEncoding = function() {
  return this.mx_rpc_soap_SOAPEncoder__wsdlOperation.inputMessage.encoding;
};


mx.rpc.soap.SOAPEncoder.prototype.get__schemaConstants = function() {
  return this.schemaManager.schemaConstants;
};


mx.rpc.soap.SOAPEncoder.prototype.get__soapConstants = function() {
  return this.wsdlOperation.soapConstants;
};


mx.rpc.soap.SOAPEncoder.prototype.get__wsdlOperation = function() {
  return this.mx_rpc_soap_SOAPEncoder__wsdlOperation;
};


mx.rpc.soap.SOAPEncoder.prototype.set__wsdlOperation = function(value) {
  this.mx_rpc_soap_SOAPEncoder__wsdlOperation = value;
  this.schemaManager = this.mx_rpc_soap_SOAPEncoder__wsdlOperation.schemaManager;
};


Object.defineProperties(mx.rpc.soap.SOAPEncoder.prototype, /** @lends {mx.rpc.soap.SOAPEncoder.prototype} */ {
/**
  * @export
  * @type {boolean} */
ignoreWhitespace: {
get: mx.rpc.soap.SOAPEncoder.prototype.get__ignoreWhitespace,
set: mx.rpc.soap.SOAPEncoder.prototype.set__ignoreWhitespace},
/**
  * @type {mx.rpc.wsdl.WSDLEncoding} */
inputEncoding: {
get: mx.rpc.soap.SOAPEncoder.prototype.get__inputEncoding},
/**
  * @export
  * @type {mx.rpc.xml.SchemaConstants} */
schemaConstants: {
get: mx.rpc.soap.SOAPEncoder.prototype.get__schemaConstants},
/**
  * @export
  * @type {mx.rpc.soap.SOAPConstants} */
soapConstants: {
get: mx.rpc.soap.SOAPEncoder.prototype.get__soapConstants},
/**
  * @export
  * @type {mx.rpc.wsdl.WSDLOperation} */
wsdlOperation: {
get: mx.rpc.soap.SOAPEncoder.prototype.get__wsdlOperation,
set: mx.rpc.soap.SOAPEncoder.prototype.set__wsdlOperation}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.soap.SOAPEncoder.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'SOAPEncoder', qName: 'mx.rpc.soap.SOAPEncoder', kind: 'class' }], interfaces: [mx.rpc.soap.ISOAPEncoder] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.soap.SOAPEncoder.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'ignoreWhitespace': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPEncoder'},
        'schemaConstants': { type: 'mx.rpc.xml.SchemaConstants', access: 'readonly', declaredBy: 'mx.rpc.soap.SOAPEncoder'},
        'soapConstants': { type: 'mx.rpc.soap.SOAPConstants', access: 'readonly', declaredBy: 'mx.rpc.soap.SOAPEncoder'},
        'wsdlOperation': { type: 'mx.rpc.wsdl.WSDLOperation', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPEncoder'}
      };
    },
    methods: function () {
      return {
        'SOAPEncoder': { type: '', declaredBy: 'mx.rpc.soap.SOAPEncoder'},
        'encodeRequest': { type: 'XML', declaredBy: 'mx.rpc.soap.SOAPEncoder', parameters: function () { return [ '*', true ,'Array', true ]; }},
        'encode': { type: 'XMLList', declaredBy: 'mx.rpc.soap.SOAPEncoder', parameters: function () { return [ '*', false ,'QName', true ,'QName', true ,'XML', true ]; }},
        'encodeType': { type: 'void', declaredBy: 'mx.rpc.soap.SOAPEncoder', parameters: function () { return [ 'QName', false ,'XML', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'encodeComplexRestriction': { type: 'void', declaredBy: 'mx.rpc.soap.SOAPEncoder', parameters: function () { return [ 'XML', false ,'XML', false ,'QName', false ,'*', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.soap.SOAPEncoder.prototype.ROYALE_COMPILE_FLAGS = 26;
