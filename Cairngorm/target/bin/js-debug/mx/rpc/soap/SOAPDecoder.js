/**
 * Generated by Apache Royale Compiler from mx/rpc/soap/SOAPDecoder.as
 * mx.rpc.soap.SOAPDecoder
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.soap.SOAPDecoder');
/* Royale Dependency List: Namespace,QName,XML,XMLList,mx.logging.ILogger,mx.logging.Log,mx.rpc.soap.SOAPConstants,mx.rpc.soap.SOAPFault,mx.rpc.soap.SOAPHeader,mx.rpc.soap.SOAPResult,mx.rpc.soap.types.ICustomSOAPType,mx.rpc.wsdl.WSDLEncoding,mx.rpc.wsdl.WSDLMessagePart,mx.rpc.wsdl.WSDLOperation,mx.rpc.xml.ContentProxy,mx.rpc.xml.DecodingContext,mx.rpc.xml.SchemaConstants,mx.rpc.xml.SchemaDatatypes,mx.rpc.xml.TypeIterator,mx.utils.StringUtil,mx.utils.URLUtil,mx.utils.XMLUtil,mx.utils.object_proxy,org.apache.royale.utils.Language*/

goog.require('mx.rpc.xml.XMLDecoder');
goog.require('mx.rpc.soap.ISOAPDecoder');



/**
 * @constructor
 * @extends {mx.rpc.xml.XMLDecoder}
 * @implements {mx.rpc.soap.ISOAPDecoder}
 */
mx.rpc.soap.SOAPDecoder = function() {
  mx.rpc.soap.SOAPDecoder.base(this, 'constructor');
  this.mx_rpc_soap_SOAPDecoder_log = mx.logging.Log.getLogger("mx.rpc.soap.SOAPDecoder");
};
goog.inherits(mx.rpc.soap.SOAPDecoder, mx.rpc.xml.XMLDecoder);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.soap.SOAPDecoder', mx.rpc.soap.SOAPDecoder);


/**
 * @export
 * @type {boolean}
 */
mx.rpc.soap.SOAPDecoder.prototype.supportGenericCompoundTypes = false;


/**
 * Decodes a SOAP response into a result and headers. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} response
 * @return {mx.rpc.soap.SOAPResult}
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeResponse = function(response) {
  var /** @type {mx.rpc.soap.SOAPResult} */ soapResult;
  var /** @type {string} */ responseString;
  if (org.apache.royale.utils.Language.is(response, XML))
    responseString = XML.conversion(response).toXMLString();
  else
    responseString = String(response);
  var /** @type {number} */ startTime;
  
  startTime = Date.now();
  this.mx_rpc_soap_SOAPDecoder_log.info("Decoding SOAP response");
  this.reset();
  if (responseString != null) {
    this.mx_rpc_soap_SOAPDecoder_log.debug("Encoded SOAP response {0}", responseString);
    var /** @type {boolean} */ oldIgnoreWhitespace = !!(XML.ignoreWhitespace);
    try {
      responseString = responseString.replace(mx.rpc.soap.SOAPDecoder.PI_WHITESPACE_PATTERN, "?><");
      responseString = mx.utils.StringUtil.trim(responseString);
      XML.ignoreWhitespace = this.ignoreWhitespace;
      var /** @type {XML} */ responseXML = new XML(responseString);
      soapResult = this.decodeEnvelope(responseXML);
    } finally {
      XML.ignoreWhitespace = oldIgnoreWhitespace;
    }
  }
  var /** @type {number} */ stopTime;
  
  stopTime = Date.now();
  this.mx_rpc_soap_SOAPDecoder_log.info("Decoded SOAP response into result [{0} millis]", stopTime - startTime);
  return soapResult;
};


/**
 * @export
 * @param {XML} responseXML
 * @return {mx.rpc.soap.SOAPResult}
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeEnvelope = function(responseXML) {
  this.mx_rpc_soap_SOAPDecoder_log.debug("Decoding SOAP response envelope");
  var /** @type {mx.rpc.soap.SOAPResult} */ soapResult = new mx.rpc.soap.SOAPResult();
  var /** @type {Namespace} */ envNS;
  if (responseXML != null) {
    envNS = responseXML.namespace();
  }
  if (envNS == null) {
    throw new Error("SOAP Response cannot be decoded. Raw response: " + responseXML);
  } else if (envNS.uri != mx.rpc.soap.SOAPConstants.SOAP_ENVELOPE_URI) {
    throw new Error("SOAP Response Version Mismatch");
  } else {
    var /** @type {mx.rpc.xml.SchemaConstants} */ schemaConst;
    var /** @type {Array} */ nsArray = responseXML.inScopeNamespaces();
    var foreachiter0_target = nsArray;
    for (var foreachiter0 in foreachiter0_target) 
    {
    var ns = foreachiter0_target[foreachiter0];
    {
      this.schemaManager.namespaces[ns.prefix] = ns;
    }}
    
    var /** @type {XML} */ headerXML = responseXML.child(this.soapConstants.headerQName)[0];
    if (headerXML != null) {
      soapResult.headers = this.decodeHeaders(headerXML);
    }
    var /** @type {XML} */ bodyXML = responseXML.child(this.soapConstants.bodyQName)[0];
    if (bodyXML == null || bodyXML.hasComplexContent() == false || bodyXML.children().length() <= 0) {
      soapResult.result = undefined;
    } else {
      var /** @type {XMLList} */ faultXMLList = bodyXML.child(this.soapConstants.faultQName);
      if (faultXMLList.length() > 0) {
        soapResult.isFault = true;
        soapResult.result = this.decodeFaults(faultXMLList);
      } else {
        if (this.resultFormat == "object") {
          this.decodeBody(bodyXML, soapResult);
        } else if (this.resultFormat == "e4x") {
          soapResult.result = bodyXML.children();
        }
      }
    }
  }
  return soapResult;
};


/**
 * Decodes the response SOAP Body. The contents may either be the encoded
 * output parameters, or a collection of SOAP faults.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {XML} bodyXML
 * @param {mx.rpc.soap.SOAPResult} soapResult
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeBody = function(bodyXML, soapResult) {
  this.mx_rpc_soap_SOAPDecoder_log.debug("Decoding SOAP response body");
  var /** @type {*} */ result;
  this.document = bodyXML;
  this.preProcessXML(bodyXML);
  if (this.wsdlOperation.outputMessage == null) {
    soapResult.result = undefined;
    return;
  }
  var /** @type {Array} */ parts = this.wsdlOperation.outputMessage.parts;
  if (parts == null || parts.length == 0) {
    soapResult.result = undefined;
    return;
  }
  var /** @type {XML} */ outputMessageXML = bodyXML;
  if (this.wsdlOperation.style == mx.rpc.soap.SOAPConstants.RPC_STYLE) {
    outputMessageXML = outputMessageXML.elements()[0];
  } else if (this.outputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_LITERAL && this.wsdlOperation.outputMessage.isWrapped == true) {
    var /** @type {XML} */ wrappedDefinition = this.schemaManager.getNamedDefinition(this.wsdlOperation.outputMessage.wrappedQName, this.constants.complexTypeQName, this.constants.elementTypeQName);
    outputMessageXML = outputMessageXML.elements()[0];
  }
  var foreachiter1_target = parts;
  for (var foreachiter1 in foreachiter1_target) 
  {
  var part = foreachiter1_target[foreachiter1];
  {
    var /** @type {XMLList} */ encodedPartValues;
    var /** @type {XML} */ encodedPartValue;
    var /** @type {*} */ decodedPart;
    var /** @type {QName} */ partQName;
    var /** @type {QName} */ partType;
    var /** @type {XML} */ partDefinition;
    if (part.element != null) {
      if (outputMessageXML.hasComplexContent())
        encodedPartValues = outputMessageXML.elements(part.element);
      else
        encodedPartValues = outputMessageXML.text();
      partQName = part.element;
      partType = null;
    } else {
      partType = part.type;
      partDefinition = part.definition;
      if (outputMessageXML.hasComplexContent()) {
        if (this.outputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_ENCODED) {
          partQName = new QName("", part.name.localName);
          encodedPartValues = outputMessageXML.elements(partQName);
          if (encodedPartValues.length() == 0) {
            var /** @type {string} */ encodedNamespace = this.outputEncoding.namespaceURI;
            partQName = new QName(encodedNamespace, part.name.localName);
            encodedPartValues = outputMessageXML.elements(partQName);
            if (encodedPartValues.length() == 0) {
              encodedNamespace = this.inputEncoding.namespaceURI;
              partQName = new QName(encodedNamespace, part.name.localName);
              encodedPartValues = outputMessageXML.elements(partQName);
            }
          }
        } else {
          encodedPartValues = outputMessageXML.elements(part.name);
        }
      } else {
        encodedPartValues = outputMessageXML.text();
      }
    }
    var foreachiter2_target = encodedPartValues;
    for (var foreachiter2 in foreachiter2_target.elementNames()) 
    {
    encodedPartValue = foreachiter2_target[foreachiter2];
    {
      decodedPart = this.decode(encodedPartValue, partQName, partType, partDefinition);
      if (parts.length > 1) {
        if (this.multiplePartsFormat == "object") {
          if (result == null) {
            result = this.createContent(org.apache.royale.utils.Language.as(outputMessageXML.name(), QName));
            result.isSimple = false;
          }
          if (result[part.name.localName] == null) {
            var /** @type {number} */ partMaxOccurs = this.getMaxOccurs(partDefinition);
            if ((partMaxOccurs > 1 && this.forcePartArrays) || encodedPartValues.length() > 1) {
              result[part.name.localName] = this.createIterableValue(part.type);
            }
          }
          if (mx.rpc.xml.TypeIterator.isIterable(result[part.name.localName]))
            mx.rpc.xml.TypeIterator.push(result[part.name.localName], decodedPart);
          else
            result[part.name.localName] = decodedPart;
        } else if (this.multiplePartsFormat == "array") {
          if (result == null) {
            result = this.createIterableValue(outputMessageXML.name());
          }
          mx.rpc.xml.TypeIterator.push(result, decodedPart);
        }
      } else {
        if (result == null) {
          var /** @type {QName} */ sinlgePartResultType = partType;
          if (sinlgePartResultType == null)
            sinlgePartResultType = part.element;
          if (sinlgePartResultType == null)
            sinlgePartResultType = part.name;
          var /** @type {number} */ singlePartMaxOccurs = this.getMaxOccurs(partDefinition);
          if ((singlePartMaxOccurs > 1 && this.forcePartArrays) || encodedPartValues.length() > 1) {
            result = this.createIterableValue(sinlgePartResultType);
          } else {
            result = this.createContent();
          }
        }
        if (mx.rpc.xml.TypeIterator.isIterable(result)) {
          mx.rpc.xml.TypeIterator.push(result, decodedPart);
        } else {
          result = decodedPart;
        }
      }
    }}
    
  }}
  
  if (org.apache.royale.utils.Language.is(result, mx.rpc.xml.ContentProxy))
    result = org.apache.royale.utils.Language.as(result, mx.rpc.xml.ContentProxy, true).http_$$www_adobe_com$2006$actionscript$flash$objectproxy__content;
  soapResult.result = result;
};


/**
 * Decodes a SOAP 1.1. Fault.
 * 
 * FIXME: We need to add SOAP 1.2 Fault support which is very different
 * from SOAP 1.1.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {XMLList} faultsXMLList
 * @return {Array}
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeFaults = function(faultsXMLList) {
  this.mx_rpc_soap_SOAPDecoder_log.debug("SOAP: Decoding SOAP response fault");
  var /** @type {Array} */ faults = [];
  var foreachiter3_target = faultsXMLList;
  for (var foreachiter3 in foreachiter3_target.elementNames()) 
  {
  var faultXML = foreachiter3_target[foreachiter3];
  {
    var /** @type {QName} */ code;
    var /** @type {string} */ string;
    var /** @type {string} */ detail;
    var /** @type {XML} */ element = faultXML;
    var /** @type {string} */ actor;
    var /** @type {XMLList} */ faultProperties = faultXML.children();
    var foreachiter4_target = faultProperties;
    for (var foreachiter4 in foreachiter4_target.elementNames()) 
    {
    var child = foreachiter4_target[foreachiter4];
    {
      if (child.localName() == "faultcode") {
        code = this.schemaManager.getQNameForPrefixedName(child.toString(), child);
      } else if (child.localName() == "faultstring") {
        string = child.toString();
      } else if (child.localName() == "faultactor") {
        actor = child.toString();
      } else if (child.localName() == "detail") {
        if (child.hasComplexContent()) {
          detail = child.children().toXMLString();
        } else {
          detail = child.toString();
        }
      }
    }}
    
    var /** @type {mx.rpc.soap.SOAPFault} */ fault = new mx.rpc.soap.SOAPFault(code, string, detail, element, actor);
    faults.push(fault);
  }}
  
  return faults;
};


/**
 * @export
 * @param {XML} headerXML
 * @return {Array}
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeHeaders = function(headerXML) {
  this.mx_rpc_soap_SOAPDecoder_log.debug("Decoding SOAP response headers");
  var /** @type {Array} */ headers = [];
  var /** @type {XMLList} */ headerXMLList = headerXML.elements();
  var foreachiter5_target = headerXMLList;
  for (var foreachiter5 in foreachiter5_target.elementNames()) 
  {
  var headerChild = foreachiter5_target[foreachiter5];
  {
    if (this.headerFormat == "object") {
      var /** @type {QName} */ xsiType = this.getXSIType(headerChild);
      var /** @type {XML} */ definition = null;
      var /** @type {Object} */ headerContent = null;
      if (xsiType != null)
        definition = this.schemaManager.getNamedDefinition(xsiType, this.constants.complexTypeQName, this.constants.simpleTypeQName);
      if (definition != null) {
        this.schemaManager.releaseScope();
        headerContent = this.decode(headerChild, null, xsiType);
      } else {
        headerContent = this.decode(headerChild, org.apache.royale.utils.Language.as(headerChild.name(), QName));
      }
      var /** @type {mx.rpc.soap.SOAPHeader} */ headerObject = new mx.rpc.soap.SOAPHeader(org.apache.royale.utils.Language.as(headerChild.name(), QName), headerContent);
      var /** @type {string} */ muValue = mx.utils.XMLUtil.getAttributeByQName(headerChild, this.soapConstants.mustUnderstandQName).toString();
      if (muValue == "1")
        headerObject.mustUnderstand = true;
      var /** @type {string} */ actValue = mx.utils.XMLUtil.getAttributeByQName(headerChild, this.soapConstants.actorQName).toString();
      if (actValue != "")
        headerObject.role = actValue;
      headers.push(headerObject);
    } else if (this.headerFormat == "e4x") {
      headers.push(headerChild);
    }
  }}
  
  return headers;
};


/**
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeComplexType = function(definition, parent, name, value, restriction, context) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  context = typeof context !== 'undefined' ? context : null;
  if (org.apache.royale.utils.Language.is(value, XML)) {
    var /** @type {XML} */ valXML = org.apache.royale.utils.Language.as(value, XML);
    if (valXML.elements(mx.rpc.soap.SOAPConstants.diffgramQName).length() > 0 && valXML.elements(this.schemaConstants.schemaQName).length() > 0) {
      this.decodeType(mx.rpc.soap.SOAPConstants.diffgramQName, parent, org.apache.royale.utils.Language.as(valXML.name(), QName), value);
      return;
    }
  }
  mx.rpc.soap.SOAPDecoder.superClass_.decodeComplexType.apply(this, [ definition, parent, name, value, restriction, context] );
};


/**
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeType = function(type, parent, name, value, restriction) {
  restriction = typeof restriction !== 'undefined' ? restriction : null;
  var /** @type {QName} */ originalType = type;
  var /** @type {QName} */ xsiType = this.getXSIType(value);
  if (xsiType != null)
    type = xsiType;
  if (this.outputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_ENCODED) {
    if (mx.rpc.soap.SOAPConstants.isSOAPEncodedType(type)) {
      var /** @type {mx.rpc.xml.SchemaDatatypes} */ datatypes = this.schemaManager.schemaDatatypes;
      if (QName.equality(type,this.soapConstants.soapBase64QName)) {
        type = datatypes.base64BinaryQName;
      } else {
        var /** @type {string} */ localName = type.localName;
        if (localName != "Array" && localName != "arrayType") {
          type = this.schemaConstants.getQName(localName);
        }
      }
    }
  }
  var /** @type {mx.rpc.soap.types.ICustomSOAPType} */ customType = mx.rpc.soap.SOAPConstants.getCustomSOAPType(type);
  if (customType != null) {
    customType.decode(this, parent, name, value, restriction);
    this.setXSIType(parent, type);
  } else {
    var /** @type {mx.rpc.xml.SchemaConstants} */ constants = this.schemaManager.schemaConstants;
    if (this.isBuiltInType(type)) {
      mx.rpc.soap.SOAPDecoder.superClass_.decodeType.apply(this, [ type, parent, name, value, restriction] );
    } else {
      var /** @type {XML} */ definition = this.schemaManager.getNamedDefinition(type, constants.complexTypeQName, constants.simpleTypeQName, constants.elementTypeQName);
      if (definition != null) {
        this.schemaManager.releaseScope();
        mx.rpc.soap.SOAPDecoder.superClass_.decodeType.apply(this, [ type, parent, name, value, restriction] );
      } else {
        mx.rpc.soap.SOAPDecoder.superClass_.decodeType.apply(this, [ originalType, parent, name, value, restriction] );
      }
    }
  }
};


/**
 * This override intercepts dencoding a complexType with complexContent based
 * on a SOAP encoded Array. This awkward approach to Array type definitions
 * was popular in WSDL 1.1 rpc-encoded operations and is a special case that
 * needs to be handled, but note it violates the WS-I Basic Profile 1.0.
 * 
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.decodeComplexRestriction = function(restriction, parent, name, value) {
  var /** @type {mx.rpc.xml.SchemaConstants} */ schemaConstants = this.schemaManager.schemaConstants;
  var /** @type {string} */ baseName = org.apache.royale.utils.Language.string(restriction.attribute('base'));
  var /** @type {QName} */ baseQName = this.schemaManager.getQNameForPrefixedName(baseName, restriction);
  if (QName.equality(baseQName,this.soapConstants.soapencArrayQName)) {
    var /** @type {mx.rpc.soap.types.ICustomSOAPType} */ customType = mx.rpc.soap.SOAPConstants.getCustomSOAPType(baseQName);
    if (customType != null) {
      customType.decode(this, parent, name, value, restriction);
      return;
    }
  }
  mx.rpc.soap.SOAPDecoder.superClass_.decodeComplexRestriction.apply(this, [ restriction, parent, name, value] );
};


/**
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.reset = function() {
  mx.rpc.soap.SOAPDecoder.superClass_.reset.apply(this);
  this.mx_rpc_soap_SOAPDecoder__referencesResolved = false;
  this.mx_rpc_soap_SOAPDecoder__elementsWithId = null;
};


/**
 * Determines whether a name is in an internal (SOAP or XSD specific)
 * namespace (as opposed to a user's namespace).
 * @asprivate 
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.isInternalNamespace = function(name) {
  var /** @type {string} */ uri = org.apache.royale.utils.Language.string((name != null) ? name.uri : null);
  if (uri) {
    if (mx.utils.URLUtil.urisEqual(uri, this.soapConstants.encodingURI) || mx.utils.URLUtil.urisEqual(uri, this.soapConstants.envelopeURI)) {
      return true;
    }
  }
  return mx.rpc.soap.SOAPDecoder.superClass_.isInternalNamespace.apply(this, [ name] );
};


/**
 * Overrides XMLDecoder.parseValue to allow us to detect a legacy case
 * of literal style encoding where by generically encoded compound types
 * (such as arrays) had entries encoded with multiple child
 * <code>item</code> elements (instead of matching the correct schema
 * definition of just repeating the value node).
 * 
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.parseValue = function(name, value) {
  if (this.supportGenericCompoundTypes && this.outputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_LITERAL && value.length() > 0) {
    var /** @type {QName} */ itemQName = new QName(value[0].name().uri, "item");
    var /** @type {XMLList} */ items = value.elements(itemQName);
    if (items.length() > 0)
      value = items;
  }
  return mx.rpc.soap.SOAPDecoder.superClass_.parseValue.apply(this, [ name, value] );
};


/**
 * Overrides XMLDecoder.preProcessXML to allow us to handle multi-ref SOAP
 * encoding.
 * @asprivate
 * @export
 * @override
 */
mx.rpc.soap.SOAPDecoder.prototype.preProcessXML = function(root) {
  if (this.outputEncoding.useStyle == mx.rpc.soap.SOAPConstants.USE_ENCODED)
    this.mx_rpc_soap_SOAPDecoder_resolveReferences(root);
};


/**
 * Resolves multi-refs in rpc/encoded. Substitutes each reference by its
 * referent node.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {XML} root
 * @param {boolean=} cleanupElementsWithIdCache
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder_resolveReferences = function(root, cleanupElementsWithIdCache) {
  cleanupElementsWithIdCache = typeof cleanupElementsWithIdCache !== 'undefined' ? cleanupElementsWithIdCache : true;
  if (this.mx_rpc_soap_SOAPDecoder__referencesResolved)
    return;
  var /** @type {number} */ index = 0;
  if (this.mx_rpc_soap_SOAPDecoder__elementsWithId == null)
    this.mx_rpc_soap_SOAPDecoder__elementsWithId = this.document.descendants('*').filter(function(/** @type {XML} */ node){return (node.attribute("id").length() > 0)});
  var foreachiter6_target = root.children();
  for (var foreachiter6 in foreachiter6_target) 
  {
  var child = foreachiter6_target[foreachiter6];
  {
    if (child.nodeKind() == "element") {
      var /** @type {string} */ href = this.getAttributeFromNode("href", child);
      if (href != null) {
        var /** @type {number} */ hashPosition = (href.indexOf("#")) >> 0;
        if (hashPosition >= 0)
          href = href.substring(hashPosition + 1);
        var /** @type {XMLList} */ matches = this.mx_rpc_soap_SOAPDecoder__elementsWithId.filter(function(/** @type {XML} */ node){return (node.attribute('id') == href)});
        var /** @type {XML} */ referent;
        if (matches.length() > 0)
          referent = matches[0];
        else
          throw new Error("The element referenced by id '" + href + "' was not found.");
        referent.setName(child.name());
        if (referent.hasComplexContent())
          this.mx_rpc_soap_SOAPDecoder_resolveReferences(referent, false);
        root.replace(index, referent);
        referent = root.child(index)[0];
        referent.removeChild(referent.attribute('id'));
      } else if (child.hasComplexContent()) {
        this.mx_rpc_soap_SOAPDecoder_resolveReferences(child, false);
      }
    }
    index++;
  }}
  
  if (cleanupElementsWithIdCache) {
    this.mx_rpc_soap_SOAPDecoder__elementsWithId = null;
    this.mx_rpc_soap_SOAPDecoder__referencesResolved = true;
  }
};


/**
 * @private
 * @type {mx.logging.ILogger}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder_log;


/**
 * @private
 * @type {XMLList}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__elementsWithId;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__forcePartArrays;


/**
 * @private
 * @type {string}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__headerFormat;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__ignoreWhitespace = true;


/**
 * @private
 * @type {string}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__multiplePartsFormat;


/**
 * @private
 * @type {boolean}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__referencesResolved;


/**
 * @private
 * @type {string}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__resultFormat;


/**
 * @private
 * @type {mx.rpc.wsdl.WSDLOperation}
 */
mx.rpc.soap.SOAPDecoder.prototype.mx_rpc_soap_SOAPDecoder__wsdlOperation;


/**
 * @export
 * @type {RegExp}
 */
mx.rpc.soap.SOAPDecoder.PI_WHITESPACE_PATTERN = new RegExp("[\\?][>]\\s*[<]", "g");


mx.rpc.soap.SOAPDecoder.prototype.get__forcePartArrays = function() {
  return this.mx_rpc_soap_SOAPDecoder__forcePartArrays;
};


mx.rpc.soap.SOAPDecoder.prototype.set__forcePartArrays = function(value) {
  this.mx_rpc_soap_SOAPDecoder__forcePartArrays = value;
};


mx.rpc.soap.SOAPDecoder.prototype.get__headerFormat = function() {
  return this.mx_rpc_soap_SOAPDecoder__headerFormat;
};


mx.rpc.soap.SOAPDecoder.prototype.set__headerFormat = function(value) {
  this.mx_rpc_soap_SOAPDecoder__headerFormat = value;
};


mx.rpc.soap.SOAPDecoder.prototype.get__ignoreWhitespace = function() {
  return this.mx_rpc_soap_SOAPDecoder__ignoreWhitespace;
};


mx.rpc.soap.SOAPDecoder.prototype.set__ignoreWhitespace = function(value) {
  this.mx_rpc_soap_SOAPDecoder__ignoreWhitespace = value;
};


mx.rpc.soap.SOAPDecoder.prototype.get__multiplePartsFormat = function() {
  return this.mx_rpc_soap_SOAPDecoder__multiplePartsFormat;
};


mx.rpc.soap.SOAPDecoder.prototype.set__multiplePartsFormat = function(value) {
  this.mx_rpc_soap_SOAPDecoder__multiplePartsFormat = value;
};


mx.rpc.soap.SOAPDecoder.prototype.get__resultFormat = function() {
  return this.mx_rpc_soap_SOAPDecoder__resultFormat;
};


mx.rpc.soap.SOAPDecoder.prototype.set__resultFormat = function(value) {
  this.mx_rpc_soap_SOAPDecoder__resultFormat = value;
};


mx.rpc.soap.SOAPDecoder.prototype.get__schemaConstants = function() {
  return this.schemaManager.schemaConstants;
};


mx.rpc.soap.SOAPDecoder.prototype.get__soapConstants = function() {
  return this.wsdlOperation.soapConstants;
};


mx.rpc.soap.SOAPDecoder.prototype.get__wsdlOperation = function() {
  return this.mx_rpc_soap_SOAPDecoder__wsdlOperation;
};


mx.rpc.soap.SOAPDecoder.prototype.set__wsdlOperation = function(value) {
  this.mx_rpc_soap_SOAPDecoder__wsdlOperation = value;
  this.schemaManager = this.mx_rpc_soap_SOAPDecoder__wsdlOperation.schemaManager;
};


mx.rpc.soap.SOAPDecoder.prototype.get__inputEncoding = function() {
  var /** @type {mx.rpc.wsdl.WSDLEncoding} */ encoding;
  if (this.mx_rpc_soap_SOAPDecoder__wsdlOperation.inputMessage != null)
    encoding = this.mx_rpc_soap_SOAPDecoder__wsdlOperation.inputMessage.encoding;
  else
    encoding = new mx.rpc.wsdl.WSDLEncoding();
  return encoding;
};


mx.rpc.soap.SOAPDecoder.prototype.get__outputEncoding = function() {
  var /** @type {mx.rpc.wsdl.WSDLEncoding} */ encoding;
  if (this.mx_rpc_soap_SOAPDecoder__wsdlOperation.outputMessage != null)
    encoding = this.mx_rpc_soap_SOAPDecoder__wsdlOperation.outputMessage.encoding;
  else
    encoding = new mx.rpc.wsdl.WSDLEncoding();
  return encoding;
};


Object.defineProperties(mx.rpc.soap.SOAPDecoder.prototype, /** @lends {mx.rpc.soap.SOAPDecoder.prototype} */ {
/**
  * @export
  * @type {boolean} */
forcePartArrays: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__forcePartArrays,
set: mx.rpc.soap.SOAPDecoder.prototype.set__forcePartArrays},
/**
  * @export
  * @type {string} */
headerFormat: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__headerFormat,
set: mx.rpc.soap.SOAPDecoder.prototype.set__headerFormat},
/**
  * @export
  * @type {boolean} */
ignoreWhitespace: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__ignoreWhitespace,
set: mx.rpc.soap.SOAPDecoder.prototype.set__ignoreWhitespace},
/**
  * @export
  * @type {string} */
multiplePartsFormat: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__multiplePartsFormat,
set: mx.rpc.soap.SOAPDecoder.prototype.set__multiplePartsFormat},
/**
  * @export
  * @type {string} */
resultFormat: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__resultFormat,
set: mx.rpc.soap.SOAPDecoder.prototype.set__resultFormat},
/**
  * @export
  * @type {mx.rpc.xml.SchemaConstants} */
schemaConstants: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__schemaConstants},
/**
  * @export
  * @type {mx.rpc.soap.SOAPConstants} */
soapConstants: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__soapConstants},
/**
  * @export
  * @type {mx.rpc.wsdl.WSDLOperation} */
wsdlOperation: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__wsdlOperation,
set: mx.rpc.soap.SOAPDecoder.prototype.set__wsdlOperation},
/**
  * @type {mx.rpc.wsdl.WSDLEncoding} */
inputEncoding: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__inputEncoding},
/**
  * @type {mx.rpc.wsdl.WSDLEncoding} */
outputEncoding: {
get: mx.rpc.soap.SOAPDecoder.prototype.get__outputEncoding}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.soap.SOAPDecoder.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'SOAPDecoder', qName: 'mx.rpc.soap.SOAPDecoder', kind: 'class' }], interfaces: [mx.rpc.soap.ISOAPDecoder] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.soap.SOAPDecoder.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'supportGenericCompoundTypes': { type: 'Boolean', get_set: function (/** mx.rpc.soap.SOAPDecoder */ inst, /** * */ v) {return v !== undefined ? inst.supportGenericCompoundTypes = v : inst.supportGenericCompoundTypes;}},
        '|PI_WHITESPACE_PATTERN': { type: 'RegExp', get_set: function (/** * */ v) {return v !== undefined ? mx.rpc.soap.SOAPDecoder.PI_WHITESPACE_PATTERN = v : mx.rpc.soap.SOAPDecoder.PI_WHITESPACE_PATTERN;}}
      };
    },
    accessors: function () {
      return {
        'forcePartArrays': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'headerFormat': { type: 'String', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'ignoreWhitespace': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'multiplePartsFormat': { type: 'String', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'resultFormat': { type: 'String', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'schemaConstants': { type: 'mx.rpc.xml.SchemaConstants', access: 'readonly', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'soapConstants': { type: 'mx.rpc.soap.SOAPConstants', access: 'readonly', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'wsdlOperation': { type: 'mx.rpc.wsdl.WSDLOperation', access: 'readwrite', declaredBy: 'mx.rpc.soap.SOAPDecoder'}
      };
    },
    methods: function () {
      return {
        'SOAPDecoder': { type: '', declaredBy: 'mx.rpc.soap.SOAPDecoder'},
        'decodeResponse': { type: 'mx.rpc.soap.SOAPResult', declaredBy: 'mx.rpc.soap.SOAPDecoder', parameters: function () { return [ '*', false ]; }},
        'decodeComplexType': { type: 'void', declaredBy: 'mx.rpc.soap.SOAPDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ,'XML', true ,'mx.rpc.xml.DecodingContext', true ]; }},
        'decodeType': { type: 'void', declaredBy: 'mx.rpc.soap.SOAPDecoder', parameters: function () { return [ 'QName', false ,'*', false ,'QName', false ,'*', false ,'XML', true ]; }},
        'decodeComplexRestriction': { type: 'void', declaredBy: 'mx.rpc.soap.SOAPDecoder', parameters: function () { return [ 'XML', false ,'*', false ,'QName', false ,'*', false ]; }},
        'reset': { type: 'void', declaredBy: 'mx.rpc.soap.SOAPDecoder'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.soap.SOAPDecoder.prototype.ROYALE_COMPILE_FLAGS = 26;
