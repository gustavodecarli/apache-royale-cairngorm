/**
 * Generated by Apache Royale Compiler from mx/rpc/wsdl/WSDL.as
 * mx.rpc.wsdl.WSDL
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.rpc.wsdl.WSDL');
/* Royale Dependency List: Namespace,QName,XML,XMLList,mx.logging.ILogger,mx.logging.Log,mx.resources.IResourceManager,mx.resources.ResourceManager,mx.rpc.Fault,mx.rpc.soap.SOAPConstants,mx.rpc.wsdl.WSDLBinding,mx.rpc.wsdl.WSDLConstants,mx.rpc.wsdl.WSDLEncoding,mx.rpc.wsdl.WSDLMessage,mx.rpc.wsdl.WSDLMessagePart,mx.rpc.wsdl.WSDLOperation,mx.rpc.wsdl.WSDLPort,mx.rpc.wsdl.WSDLPortType,mx.rpc.wsdl.WSDLService,mx.rpc.xml.QualifiedResourceManager,mx.rpc.xml.Schema,mx.rpc.xml.SchemaConstants,mx.rpc.xml.SchemaManager*/




/**
 * Constructs a WSDL from XML. Services and their operations are
 * parsed into object representations on the first call to
 * <code>getService()</code>, <code>getPort()</code> or
 * <code>getOperation()</code>.
 *
 * @asparam xml An XML document starting from the top-level WSDL 
 * <code>defintions</code> element.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @constructor
 * @param {XML} xml
 * @param {mx.rpc.xml.SchemaManager=} topLevelManager
 */
mx.rpc.wsdl.WSDL = function(xml, topLevelManager) {
  topLevelManager = typeof topLevelManager !== 'undefined' ? topLevelManager : null;
  
  this.mx_rpc_wsdl_WSDL_resourceManager = mx.resources.ResourceManager.getInstance();
  ;
  if (topLevelManager != null) {
    this.mx_rpc_wsdl_WSDL__schemaManager = topLevelManager;
  }
  this.mx_rpc_wsdl_WSDL__xml = xml;
  this.mx_rpc_wsdl_WSDL__log = mx.logging.Log.getLogger("mx.rpc.wsdl.WSDL");
  this.mx_rpc_wsdl_WSDL_processNamespaces();
  this.mx_rpc_wsdl_WSDL_processSchemas();
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.rpc.wsdl.WSDL', mx.rpc.wsdl.WSDL);


/**
 * @private
 * @type {mx.resources.IResourceManager}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_resourceManager;


/**
 * @export
 * @param {Namespace} targetNamespace
 * @param {mx.rpc.wsdl.WSDL} wsdl
 */
mx.rpc.wsdl.WSDL.prototype.addImport = function(targetNamespace, wsdl) {
  if (this.mx_rpc_wsdl_WSDL_importsManager == null)
    this.mx_rpc_wsdl_WSDL_importsManager = new mx.rpc.xml.QualifiedResourceManager();
  this.mx_rpc_wsdl_WSDL_importsManager.addResource(targetNamespace, wsdl);
};


/**
 * @export
 * @param {mx.rpc.xml.Schema} schema
 */
mx.rpc.wsdl.WSDL.prototype.addSchema = function(schema) {
  this.schemaManager.addSchema(schema);
};


/**
 * @export
 * @param {string} operationName
 * @param {string=} serviceName
 * @param {string=} portName
 * @return {mx.rpc.wsdl.WSDLOperation}
 */
mx.rpc.wsdl.WSDL.prototype.getOperation = function(operationName, serviceName, portName) {
  serviceName = typeof serviceName !== 'undefined' ? serviceName : null;
  portName = typeof portName !== 'undefined' ? portName : null;
  var /** @type {mx.rpc.wsdl.WSDLPort} */ port = this.getPort(serviceName, portName);
  var /** @type {mx.rpc.wsdl.WSDLBinding} */ binding = port.binding;
  var /** @type {mx.rpc.wsdl.WSDLPortType} */ portType = binding.portType;
  var /** @type {mx.rpc.wsdl.WSDLOperation} */ operation = portType.getOperation(operationName);
  return operation;
};


/**
 * Locate a port for a service by name. If a serviceName is provided, a
 * service is first located, otherwise the first service is used by default.
 * Once a service has been selected, the search then considers the port.
 * If a portName is not provided, the first port is used by default.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string=} serviceName
 * @param {string=} portName
 * @return {mx.rpc.wsdl.WSDLPort}
 */
mx.rpc.wsdl.WSDL.prototype.getPort = function(serviceName, portName) {
  serviceName = typeof serviceName !== 'undefined' ? serviceName : null;
  portName = typeof portName !== 'undefined' ? portName : null;
  var /** @type {mx.rpc.wsdl.WSDLPort} */ port;
  var /** @type {mx.rpc.wsdl.WSDLService} */ service = this.getService(serviceName, portName);
  if (service != null) {
    if (portName == null)
      port = service.defaultPort;
    else
      port = service.getPort(portName);
  }
  if (port == null) {
    var /** @type {string} */ message = this.mx_rpc_wsdl_WSDL_resourceManager.getString("rpc", "noServiceAndPort", [serviceName, portName]);
    throw new mx.rpc.Fault("Client.NoSuchPort", message);
  }
  return port;
};


/**
 * Search for WSDL service and port by name. If a serviceName is not
 * provided the first service found will be selected by default. 
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string=} serviceName
 * @param {string=} portName
 * @return {mx.rpc.wsdl.WSDLService}
 */
mx.rpc.wsdl.WSDL.prototype.getService = function(serviceName, portName) {
  serviceName = typeof serviceName !== 'undefined' ? serviceName : null;
  portName = typeof portName !== 'undefined' ? portName : null;
  var /** @type {mx.rpc.wsdl.WSDLService} */ service;
  var /** @type {mx.rpc.wsdl.WSDLPort} */ port;
  if (this.mx_rpc_wsdl_WSDL_serviceMap != null && serviceName != null) {
    service = this.mx_rpc_wsdl_WSDL_serviceMap[serviceName];
    if (service != null) {
      if (portName != null)
        port = service.getPort(portName);
      if (port == null) {
        var /** @type {mx.rpc.wsdl.WSDLService} */ tempService = this.mx_rpc_wsdl_WSDL_parseService(serviceName, portName);
        var foreachiter0_target = tempService.ports;
        for (var foreachiter0 in foreachiter0_target) 
        {
        var p = foreachiter0_target[foreachiter0];
        {
          service.addPort(p);
        }}
        
      }
    }
  }
  if (service == null) {
    service = this.mx_rpc_wsdl_WSDL_parseService(serviceName, portName);
    var /** @type {string} */ message;
    var /** @type {string} */ detail;
    if (service != null) {
      if (this.mx_rpc_wsdl_WSDL_serviceMap == null)
        this.mx_rpc_wsdl_WSDL_serviceMap = {};
      this.mx_rpc_wsdl_WSDL_serviceMap[service.name] = service;
    } else if (serviceName != null) {
      message = this.mx_rpc_wsdl_WSDL_resourceManager.getString("rpc", "noSuchServiceInWSDL", [serviceName]);
      throw new mx.rpc.Fault("Client.NoSuchService", message);
    } else {
      message = this.mx_rpc_wsdl_WSDL_resourceManager.getString("rpc", "noServiceElement");
      detail = this.mx_rpc_wsdl_WSDL_resourceManager.getString("rpc", "noServiceElement.details", [""]);
      throw new mx.rpc.Fault("Server.NoServicesInWSDL", message, detail);
    }
  }
  return service;
};


/**
 * @export
 * @param {Namespace} targetNamespace
 * @return {XML}
 */
mx.rpc.wsdl.WSDL.prototype.getTypes = function(targetNamespace) {
  var /** @type {XML} */ types;
  var /** @type {XMLList} */ typesXMLList = this.xml.elements(this.wsdlConstants.typesQName);
  if (typesXMLList.length() > 0) {
    types = typesXMLList[0];
  } else if (this.mx_rpc_wsdl_WSDL_importsManager != null) {
    var /** @type {Array} */ imports = this.mx_rpc_wsdl_WSDL_importsManager.getResourcesForNamespace(targetNamespace);
    var foreachiter1_target = imports;
    for (var foreachiter1 in foreachiter1_target) 
    {
    var childWSDL = foreachiter1_target[foreachiter1];
    {
      types = childWSDL.getTypes(targetNamespace);
      if (types != null)
        break;
    }}
    
  }
  return types;
};


/**
 * Search for a requested service in the definitions XML, including all
 * WSDL imports. This is the usual entry point to start parsing the WSDL as
 * only one service and one of its port will be used at any time.
 * <p>
 * If the service name is not specified, the first service is used by
 * default. If a service is located it is parsed and then the search
 * continues for the requested port, which is in turn parsed, and so forth.
 * </p>
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {string=} serviceName
 * @param {string=} portName
 * @return {mx.rpc.wsdl.WSDLService}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseService = function(serviceName, portName) {
  serviceName = typeof serviceName !== 'undefined' ? serviceName : null;
  portName = typeof portName !== 'undefined' ? portName : null;
  var /** @type {mx.rpc.wsdl.WSDLService} */ service;
  var /** @type {XML} */ serviceXML;
  var /** @type {XMLList} */ serviceXMLList = this.xml.elements(this.wsdlConstants.serviceQName);
  var foreachiter2_target = serviceXMLList;
  for (var foreachiter2 in foreachiter2_target.elementNames()) 
  {
  var x = foreachiter2_target[foreachiter2];
  {
    if (serviceName == null) {
      serviceXML = x;
      serviceName = x.attribute('name').toString();
      break;
    } else if (x.attribute('name') == serviceName) {
      serviceXML = x;
      break;
    }
  }}
  
  if (serviceXML != null) {
    service = new mx.rpc.wsdl.WSDLService(serviceName);
    var /** @type {mx.rpc.wsdl.WSDLPort} */ port = this.mx_rpc_wsdl_WSDL_parsePort(service, serviceXML, portName);
    if (port != null) {
      service.addPort(port);
    }
  } else if (this.mx_rpc_wsdl_WSDL_importsManager != null) {
    var /** @type {Array} */ imports = this.mx_rpc_wsdl_WSDL_importsManager.getResources();
    var foreachiter3_target = imports;
    for (var foreachiter3 in foreachiter3_target) 
    {
    var childWSDL = foreachiter3_target[foreachiter3];
    {
      service = childWSDL.mx_rpc_wsdl_WSDL_parseService(serviceName, portName);
      if (service != null)
        break;
    }}
    
  }
  return service;
};


/**
 * Search for a requested port in the given service XML. If a port
 * name was not specified, the first port is used by default.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {mx.rpc.wsdl.WSDLService} service
 * @param {XML} serviceXML
 * @param {string=} portName
 * @return {mx.rpc.wsdl.WSDLPort}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parsePort = function(service, serviceXML, portName) {
  portName = typeof portName !== 'undefined' ? portName : null;
  var /** @type {mx.rpc.wsdl.WSDLPort} */ port;
  var /** @type {XML} */ portXML;
  var /** @type {XMLList} */ portXMLList = serviceXML.elements(this.wsdlConstants.portQName);
  var foreachiter4_target = portXMLList;
  for (var foreachiter4 in foreachiter4_target.elementNames()) 
  {
  var x = foreachiter4_target[foreachiter4];
  {
    if (portName == null) {
      portXML = x;
      portName = x.attribute('name').toString();
      break;
    } else if (x.attribute('name') == portName) {
      portXML = x;
      break;
    }
  }}
  
  if (portXML != null) {
    port = new mx.rpc.wsdl.WSDLPort(portName, service);
    var /** @type {XMLList} */ soapAddressXMLList;
    soapAddressXMLList = portXML.elements(this.wsdlConstants.soapAddressQName);
    if (soapAddressXMLList.length() > 0) {
      port.endpointURI = soapAddressXMLList[0].attribute('location').toString();
    }
    var /** @type {string} */ prefixedBindingName = portXML.attribute('binding').toString();
    var /** @type {QName} */ bindingQName = this.schemaManager.getQNameForPrefixedName(prefixedBindingName, portXML);
    var /** @type {mx.rpc.wsdl.WSDLBinding} */ binding = this.mx_rpc_wsdl_WSDL_parseBinding(bindingQName);
    if (binding != null) {
      port.binding = binding;
    } else {
      var /** @type {string} */ message = this.mx_rpc_wsdl_WSDL_resourceManager.getString("rpc", "unrecognizedBindingName", [bindingQName.localName, bindingQName.uri]);
      throw new mx.rpc.Fault("WSDL.UnrecognizedBindingName", message);
    }
  }
  return port;
};


/**
 * Search for a binding by QName. If a URI is not specified, the
 * targetNamespace is assumed. FIXME: We may need to consider whether
 * formElementDefault is set to qualified or not.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {QName} bindingQName
 * @return {mx.rpc.wsdl.WSDLBinding}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseBinding = function(bindingQName) {
  var /** @type {mx.rpc.wsdl.WSDLBinding} */ binding;
  var /** @type {XML} */ bindingXML;
  var /** @type {XMLList} */ bindingXMLList = this.xml.elements(this.wsdlConstants.bindingQName);
  var foreachiter5_target = bindingXMLList;
  for (var foreachiter5 in foreachiter5_target.elementNames()) 
  {
  var x = foreachiter5_target[foreachiter5];
  {
    if (x.attribute('name') == bindingQName.localName) {
      bindingXML = x;
      break;
    }
  }}
  
  if (bindingXML != null) {
    binding = new mx.rpc.wsdl.WSDLBinding(bindingQName.localName);
    var /** @type {XMLList} */ soapBindingXMLList;
    soapBindingXMLList = bindingXML.elements(this.wsdlConstants.soapBindingQName);
    if (soapBindingXMLList.length() > 0) {
      var /** @type {string} */ style = soapBindingXMLList[0].attribute('style').toString();
      binding.style = style;
      var /** @type {string} */ transport = soapBindingXMLList[0].attribute('transport').toString();
      binding.transport = transport;
    }
    var /** @type {string} */ prefixedTypeName = bindingXML.attribute('type').toString();
    var /** @type {QName} */ portTypeQName = this.schemaManager.getQNameForPrefixedName(prefixedTypeName, bindingXML);
    var /** @type {mx.rpc.wsdl.WSDLPortType} */ portType = new mx.rpc.wsdl.WSDLPortType(portTypeQName.localName);
    binding.portType = portType;
    var /** @type {XMLList} */ operationXMLList = bindingXML.elements(this.wsdlConstants.operationQName);
    var foreachiter6_target = operationXMLList;
    for (var foreachiter6 in foreachiter6_target.elementNames()) 
    {
    var operationXML = foreachiter6_target[foreachiter6];
    {
      var /** @type {string} */ operationName = operationXML.attribute('name').toString();
      var /** @type {mx.rpc.wsdl.WSDLOperation} */ operation = new mx.rpc.wsdl.WSDLOperation(operationName);
      operation.schemaManager = this.schemaManager;
      operation.namespaces = this.mx_rpc_wsdl_WSDL_namespaces;
      operation.wsdlConstants = this.wsdlConstants;
      var /** @type {XMLList} */ soapOperationXMLList = operationXML.elements(this.wsdlConstants.soapOperationQName);
      if (soapOperationXMLList.length() > 0) {
        var /** @type {string} */ soapAction = soapOperationXMLList[0].attribute('soapAction').toString();
        operation.soapAction = soapAction;
        var /** @type {string} */ opStyle = soapOperationXMLList[0].attribute('style').toString();
        if (opStyle == "")
          operation.style = binding.style;
        else
          operation.style = opStyle;
      }
      var /** @type {XMLList} */ operationExtensionXMLList;
      var /** @type {XML} */ operationExtensionXML;
      var /** @type {mx.rpc.wsdl.WSDLEncoding} */ encoding;
      var /** @type {XMLList} */ extensionXMLList;
      var /** @type {XML} */ extensionXML;
      var /** @type {string} */ extensionName;
      var /** @type {mx.rpc.wsdl.WSDLMessage} */ extensionMessage;
      operationExtensionXMLList = operationXML.elements(this.wsdlConstants.inputQName);
      if (operationExtensionXMLList.length() > 0) {
        operationExtensionXML = operationExtensionXMLList[0];
        operation.inputMessage = new mx.rpc.wsdl.WSDLMessage();
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapBodyQName);
        if (extensionXMLList.length() > 0) {
          extensionXML = extensionXMLList[0];
          encoding = this.mx_rpc_wsdl_WSDL_parseEncodingExtension(extensionXML);
          operation.inputMessage.encoding = encoding;
        }
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapHeaderQName);
        var foreachiter7_target = extensionXMLList;
        for (var foreachiter7 in foreachiter7_target.elementNames()) 
        {
        extensionXML = foreachiter7_target[foreachiter7];
        {
          extensionMessage = this.mx_rpc_wsdl_WSDL_parseHeader(operationName, extensionXML);
          operation.inputMessage.addHeader(extensionMessage);
        }}
        
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapHeaderFaultQName);
        var foreachiter8_target = extensionXMLList;
        for (var foreachiter8 in foreachiter8_target.elementNames()) 
        {
        extensionXML = foreachiter8_target[foreachiter8];
        {
          extensionMessage = this.mx_rpc_wsdl_WSDL_parseHeader(operationName, extensionXML);
          operation.inputMessage.addHeaderFault(extensionMessage);
        }}
        
      }
      operationExtensionXMLList = operationXML.elements(this.wsdlConstants.outputQName);
      if (operationExtensionXMLList.length() > 0) {
        operationExtensionXML = operationExtensionXMLList[0];
        operation.outputMessage = new mx.rpc.wsdl.WSDLMessage();
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapBodyQName);
        if (extensionXMLList.length() > 0) {
          extensionXML = extensionXMLList[0];
          encoding = this.mx_rpc_wsdl_WSDL_parseEncodingExtension(extensionXML);
          operation.outputMessage.encoding = encoding;
        }
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapHeaderQName);
        var foreachiter9_target = extensionXMLList;
        for (var foreachiter9 in foreachiter9_target.elementNames()) 
        {
        extensionXML = foreachiter9_target[foreachiter9];
        {
          extensionMessage = this.mx_rpc_wsdl_WSDL_parseHeader(operationName, extensionXML);
          operation.outputMessage.addHeader(extensionMessage);
        }}
        
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapHeaderFaultQName);
        var foreachiter10_target = extensionXMLList;
        for (var foreachiter10 in foreachiter10_target.elementNames()) 
        {
        extensionXML = foreachiter10_target[foreachiter10];
        {
          extensionMessage = this.mx_rpc_wsdl_WSDL_parseHeader(operationName, extensionXML);
          operation.outputMessage.addHeaderFault(extensionMessage);
        }}
        
      }
      operationExtensionXMLList = operationXML.elements(this.wsdlConstants.faultQName);
      var foreachiter11_target = operationExtensionXMLList;
      for (var foreachiter11 in foreachiter11_target.elementNames()) 
      {
      operationExtensionXML = foreachiter11_target[foreachiter11];
      {
        extensionXMLList = operationExtensionXML.elements(this.wsdlConstants.soapFaultQName);
        if (extensionXMLList.length() > 0) {
          extensionXML = extensionXMLList[0];
          var /** @type {string} */ faultName = extensionXML.attribute("name").toString();
          extensionMessage = new mx.rpc.wsdl.WSDLMessage(faultName);
          encoding = this.mx_rpc_wsdl_WSDL_parseEncodingExtension(extensionXML, false, true);
          extensionMessage.encoding = encoding;
          operation.addFault(extensionMessage);
        }
      }}
      
      portType.addOperation(operation);
    }}
    
    this.mx_rpc_wsdl_WSDL_parsePortType(portTypeQName, portType);
  } else if (this.mx_rpc_wsdl_WSDL_importsManager != null) {
    var /** @type {Array} */ imports = this.mx_rpc_wsdl_WSDL_importsManager.getResources();
    var foreachiter12_target = imports;
    for (var foreachiter12 in foreachiter12_target) 
    {
    var childWSDL = foreachiter12_target[foreachiter12];
    {
      binding = childWSDL.mx_rpc_wsdl_WSDL_parseBinding(bindingQName);
      if (binding != null)
        break;
    }}
    
  }
  return binding;
};


/**
 * Search for a portType by QName. If a URI is not specified, the
 * targetNamespace is assumed.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {QName} portTypeQName
 * @param {mx.rpc.wsdl.WSDLPortType} portType
 * @return {boolean}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parsePortType = function(portTypeQName, portType) {
  var /** @type {XML} */ portTypeXML;
  var /** @type {boolean} */ foundMatchingPortType;
  var /** @type {XMLList} */ portTypeXMLList = this.xml.elements(this.wsdlConstants.portTypeQName);
  var foreachiter13_target = portTypeXMLList;
  for (var foreachiter13 in foreachiter13_target.elementNames()) 
  {
  var x = foreachiter13_target[foreachiter13];
  {
    if (x.attribute('name') == portTypeQName.localName) {
      portTypeXML = x;
      break;
    }
  }}
  
  if (portTypeXML != null) {
    foundMatchingPortType = true;
    var /** @type {XMLList} */ operationsXMLList = portTypeXML.elements(this.wsdlConstants.operationQName);
    var foreachiter14_target = operationsXMLList;
    for (var foreachiter14 in foreachiter14_target.elementNames()) 
    {
    var operationXML = foreachiter14_target[foreachiter14];
    {
      var /** @type {string} */ operationName = operationXML.attribute('name').toString();
      var /** @type {mx.rpc.wsdl.WSDLOperation} */ operation = portType.getOperation(operationName);
      if (operation == null) {
        this.mx_rpc_wsdl_WSDL__log.warn("An operation '{0}' was found in the port type but is missing binding information.", operationName);
        continue;
      }
      var /** @type {string} */ messageName;
      var /** @type {QName} */ messageQName;
      var /** @type {mx.rpc.wsdl.WSDLMessage} */ message;
      var /** @type {XMLList} */ inputXMLList = operationXML.elements(this.wsdlConstants.inputQName);
      if (inputXMLList.length() > 0) {
        this.schemaManager.reset();
        messageName = inputXMLList[0].attribute('message').toString();
        messageQName = this.schemaManager.getQNameForPrefixedName(messageName, inputXMLList[0]);
        message = operation.inputMessage;
        message.name = messageQName.localName;
        this.mx_rpc_wsdl_WSDL_parseMessage(message, messageQName, operationName, mx.rpc.wsdl.WSDLConstants.MODE_IN);
      }
      var /** @type {XMLList} */ outputXMLList = operationXML.elements(this.wsdlConstants.outputQName);
      if (outputXMLList.length() > 0) {
        this.schemaManager.reset();
        messageName = outputXMLList[0].attribute('message').toString();
        messageQName = this.schemaManager.getQNameForPrefixedName(messageName, outputXMLList[0]);
        message = operation.outputMessage;
        message.name = messageQName.localName;
        this.mx_rpc_wsdl_WSDL_parseMessage(message, messageQName, operationName, mx.rpc.wsdl.WSDLConstants.MODE_OUT);
      }
      var /** @type {XMLList} */ faultsXMLList = operationXML.elements(this.wsdlConstants.faultQName);
      var foreachiter15_target = faultsXMLList;
      for (var foreachiter15 in foreachiter15_target.elementNames()) 
      {
      var faultXML = foreachiter15_target[foreachiter15];
      {
        this.schemaManager.reset();
        var /** @type {string} */ faultName = faultXML.attribute('name').toString();
        message = operation.getFault(faultName);
        if (message != null) {
          messageName = faultXML.attribute('message').toString();
          messageQName = this.schemaManager.getQNameForPrefixedName(messageName, faultXML);
          this.mx_rpc_wsdl_WSDL_parseMessage(message, messageQName, operationName, mx.rpc.wsdl.WSDLConstants.MODE_FAULT);
        }
      }}
      
      if (operation.style == mx.rpc.soap.SOAPConstants.DOC_STYLE) {
        this.mx_rpc_wsdl_WSDL_parseDocumentOperation(operation);
      }
    }}
    
  } else if (this.mx_rpc_wsdl_WSDL_importsManager != null) {
    var /** @type {Array} */ imports = this.mx_rpc_wsdl_WSDL_importsManager.getResources();
    var foreachiter16_target = imports;
    for (var foreachiter16 in foreachiter16_target) 
    {
    var childWSDL = foreachiter16_target[foreachiter16];
    {
      foundMatchingPortType = childWSDL.mx_rpc_wsdl_WSDL_parsePortType(portTypeQName, portType);
      if (foundMatchingPortType)
        break;
    }}
    
  }
  return foundMatchingPortType;
};


/**
 * Search for a message by QName. If a URI is not specified, the
 * targetNamespace is assumed.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {mx.rpc.wsdl.WSDLMessage} message
 * @param {QName} messageQName
 * @param {string} operationName
 * @param {number} mode
 * @return {boolean}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseMessage = function(message, messageQName, operationName, mode) {
  var /** @type {XML} */ messageXML;
  var /** @type {boolean} */ foundMatchingMessage;
  var /** @type {mx.rpc.wsdl.WSDLEncoding} */ encoding = message.encoding;
  var /** @type {XMLList} */ messageXMLList = this.xml.elements(this.wsdlConstants.messageQName);
  var foreachiter17_target = messageXMLList;
  for (var foreachiter17 in foreachiter17_target.elementNames()) 
  {
  var x = foreachiter17_target[foreachiter17];
  {
    if (x.attribute('name') == messageQName.localName) {
      messageXML = x;
      break;
    }
  }}
  
  if (messageXML != null) {
    foundMatchingMessage = true;
    if (message.name == null || message.name == "") {
      if (mode == mx.rpc.wsdl.WSDLConstants.MODE_IN) {
        message.name = operationName + "Request";
      } else if (mode == mx.rpc.wsdl.WSDLConstants.MODE_OUT) {
        message.name = operationName + "Response";
      }
    }
    var /** @type {XMLList} */ partXMLList = messageXML.elements(this.wsdlConstants.partQName);
    var foreachiter18_target = partXMLList;
    for (var foreachiter18 in foreachiter18_target.elementNames()) 
    {
    var partXML = foreachiter18_target[foreachiter18];
    {
      var /** @type {string} */ partName = org.apache.royale.utils.Language.string(partXML.attribute('name'));
      if (encoding != null && !encoding.hasPart(partName)) {
        continue;
      }
      var /** @type {mx.rpc.wsdl.WSDLMessagePart} */ part = this.mx_rpc_wsdl_WSDL_parseMessagePart(partXML);
      message.addPart(part);
    }}
    
  } else if (this.mx_rpc_wsdl_WSDL_importsManager != null) {
    var /** @type {Array} */ imports = this.mx_rpc_wsdl_WSDL_importsManager.getResources();
    var foreachiter19_target = imports;
    for (var foreachiter19 in foreachiter19_target) 
    {
    var childWSDL = foreachiter19_target[foreachiter19];
    {
      foundMatchingMessage = childWSDL.mx_rpc_wsdl_WSDL_parseMessage(message, messageQName, operationName, mode);
      if (foundMatchingMessage)
        break;
    }}
    
  }
  return foundMatchingMessage;
};


/**
 * Returns a WSDL message part based on the name and looks for either an
 * element QName or type QName to determine which definition describes
 * this message part.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {XML} partXML
 * @return {mx.rpc.wsdl.WSDLMessagePart}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseMessagePart = function(partXML) {
  var /** @type {string} */ partName = org.apache.royale.utils.Language.string(partXML.attribute('name'));
  var /** @type {QName} */ partQName = new QName("", partName);
  var /** @type {mx.rpc.wsdl.WSDLMessagePart} */ part = new mx.rpc.wsdl.WSDLMessagePart(partQName);
  var /** @type {string} */ partXMLElement = org.apache.royale.utils.Language.string(partXML.attribute('element'));
  var /** @type {string} */ partXMLType = org.apache.royale.utils.Language.string(partXML.attribute('type'));
  if (partXMLElement != "") {
    var /** @type {string} */ elementName = org.apache.royale.utils.Language.string(partXML.attribute('element'));
    var /** @type {QName} */ elementQName = this.schemaManager.getQNameForPrefixedName(elementName, partXML);
    part.element = elementQName;
  } else if (partXMLType != "") {
    var /** @type {string} */ typeName = org.apache.royale.utils.Language.string(partXML.attribute('type'));
    var /** @type {QName} */ typeQName = this.schemaManager.getQNameForPrefixedName(typeName, partXML);
    part.type = typeQName;
  }
  return part;
};


/**
 * Looks for the SOAP encoding extensions based on the type of WSDL
 * operation message. SOAP encoding is required for SOAP Body, Header
 * (header and headerfault) and Fault extensions.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {string} operationName
 * @param {XML} headerXML
 * @return {mx.rpc.wsdl.WSDLMessage}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseHeader = function(operationName, headerXML) {
  var /** @type {string} */ headerName = headerXML.attribute("part").toString();
  var /** @type {mx.rpc.wsdl.WSDLMessage} */ headerMessage = new mx.rpc.wsdl.WSDLMessage(headerName);
  var /** @type {mx.rpc.wsdl.WSDLEncoding} */ encoding = this.mx_rpc_wsdl_WSDL_parseEncodingExtension(headerXML, true);
  headerMessage.encoding = encoding;
  this.mx_rpc_wsdl_WSDL_parseMessage(headerMessage, encoding.message, operationName, mx.rpc.wsdl.WSDLConstants.MODE_HEADER);
  return headerMessage;
};


/**
 * Looks for the SOAP encoding extensions based on the type of WSDL
 * operation message. SOAP encoding is required for SOAP Body, Header
 * (header and headerfault) and Fault extensions.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {XML} extensionXML
 * @param {boolean=} isHeader
 * @param {boolean=} isFault
 * @return {mx.rpc.wsdl.WSDLEncoding}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseEncodingExtension = function(extensionXML, isHeader, isFault) {
  isHeader = typeof isHeader !== 'undefined' ? isHeader : false;
  isFault = typeof isFault !== 'undefined' ? isFault : false;
  var /** @type {mx.rpc.wsdl.WSDLEncoding} */ encoding = new mx.rpc.wsdl.WSDLEncoding();
  encoding.useStyle = extensionXML.attribute("use").toString();
  encoding.namespaceURI = extensionXML.attribute("namespace").toString();
  encoding.encodingStyle = extensionXML.attribute("encodingStyle").toString();
  if (isHeader) {
    var /** @type {string} */ messageName = extensionXML.attribute("message").toString();
    encoding.message = this.schemaManager.getQNameForPrefixedName(messageName, extensionXML);
    encoding.setParts(extensionXML.attribute("part").toString());
  } else if (!isFault) {
    encoding.setParts(extensionXML.attribute("parts").toString());
  }
  return encoding;
};


/**
 * A Document-Literal operation may make use of "wrapped" style. If so,
 * then the message parts should be replaced by the the individual wrapped
 * parts so that the SOAP encoders correctly bind ActionScript input params
 * to message params, and SOAP decoders correctly bind output params
 * to predictable ActionScript constructs. Essentially the wrappers should
 * be an encoding detail that is invisible to the Flex developer.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {mx.rpc.wsdl.WSDLOperation} operation
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseDocumentOperation = function(operation) {
  var /** @type {mx.rpc.wsdl.WSDLMessagePart} */ part;
  var /** @type {XML} */ element;
  var /** @type {string} */ elementTypeString;
  var /** @type {QName} */ elementType;
  var /** @type {XMLList} */ complexTypes;
  var /** @type {XML} */ complexType;
  var /** @type {XMLList} */ attributes;
  var /** @type {XMLList} */ sequences;
  var /** @type {XML} */ sequence;
  if (operation.inputMessage != null && operation.inputMessage.encoding != null && operation.inputMessage.encoding.useStyle == mx.rpc.soap.SOAPConstants.USE_LITERAL) {
    var /** @type {mx.rpc.wsdl.WSDLMessage} */ input = operation.inputMessage;
    if (input.parts != null && input.parts.length == 1) {
      this.schemaManager.reset();
      part = input.parts[0];
      if (part.element != null) {
        element = this.schemaManager.getNamedDefinition(part.element, this.schemaConstants.elementTypeQName);
        if (element != null && element.attribute("name") == operation.name) {
          elementTypeString = org.apache.royale.utils.Language.string(element.attribute("type"));
          if (elementTypeString != null && elementTypeString != "") {
            elementType = this.schemaManager.getQNameForPrefixedName(elementTypeString, element);
            complexType = this.schemaManager.getNamedDefinition(elementType, this.schemaConstants.complexTypeQName);
          } else {
            complexTypes = element.elements(this.schemaConstants.complexTypeQName);
            if (complexTypes.length() == 1) {
              complexType = complexTypes[0];
            }
          }
          if (complexType != null) {
            attributes = complexType.elements(this.schemaConstants.attributeQName);
            if (attributes.length() == 0) {
              sequences = complexType.elements(this.schemaConstants.sequenceQName);
              if (complexType.elements().length() == 0 || sequences.length() == 1) {
                input.isWrapped = true;
                input.wrappedQName = part.element;
                input.parts = [];
                if (sequences.length() == 1) {
                  sequence = sequences[0];
                  var /** @type {XMLList} */ requestElements = sequence.elements(this.schemaConstants.elementTypeQName);
                  var foreachiter20_target = requestElements;
                  for (var foreachiter20 in foreachiter20_target.elementNames()) 
                  {
                  var requestElement = foreachiter20_target[foreachiter20];
                  {
                    part = this.mx_rpc_wsdl_WSDL_parseWrappedMessagePart(requestElement);
                    input.addPart(part);
                  }}
                  
                }
              }
            }
          }
        }
      }
    }
  }
  complexType = null;
  elementTypeString = null;
  if (operation.outputMessage != null && operation.outputMessage.encoding != null && operation.outputMessage.encoding.useStyle == mx.rpc.soap.SOAPConstants.USE_LITERAL) {
    var /** @type {mx.rpc.wsdl.WSDLMessage} */ output = operation.outputMessage;
    if (output.parts != null && output.parts.length == 1) {
      part = output.parts[0];
      if (part.element != null) {
        this.schemaManager.reset();
        element = this.schemaManager.getNamedDefinition(part.element, this.schemaConstants.elementTypeQName);
        if (element != null) {
          elementTypeString = org.apache.royale.utils.Language.string(element.attribute("type"));
          if (elementTypeString != null && elementTypeString != "") {
            elementType = this.schemaManager.getQNameForPrefixedName(elementTypeString, element);
            complexType = this.schemaManager.getNamedDefinition(elementType, this.schemaConstants.complexTypeQName);
          } else {
            complexTypes = element.elements(this.schemaConstants.complexTypeQName);
            if (complexTypes.length() == 1) {
              complexType = complexTypes[0];
            }
          }
          if (complexType != null) {
            attributes = complexType.elements(this.schemaConstants.attributeQName);
            if (attributes.length() == 0) {
              sequences = complexType.elements(this.schemaConstants.sequenceQName);
              if (complexType.elements().length() == 0 || sequences.length() == 1) {
                output.isWrapped = true;
                output.wrappedQName = part.element;
                output.parts = [];
                if (sequences.length() == 1) {
                  sequence = sequences[0];
                  var /** @type {XMLList} */ resultElements = sequence.elements(this.schemaConstants.elementTypeQName);
                  var foreachiter21_target = resultElements;
                  for (var foreachiter21 in foreachiter21_target.elementNames()) 
                  {
                  var resultElement = foreachiter21_target[foreachiter21];
                  {
                    part = this.mx_rpc_wsdl_WSDL_parseWrappedMessagePart(resultElement);
                    output.addPart(part);
                  }}
                  
                }
              }
            }
          }
        }
      }
    }
  }
};


/**
 * Returns a WSDL message part based on the name and looks for either an
 * element QName or type QName to determine which definition describes
 * this message part.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 * @param {XML} elementXML
 * @return {mx.rpc.wsdl.WSDLMessagePart}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_parseWrappedMessagePart = function(elementXML) {
  var /** @type {QName} */ ref;
  if (elementXML.attribute("ref").length() == 1) {
    ref = this.schemaManager.getQNameForPrefixedName(org.apache.royale.utils.Language.string(elementXML.attribute('ref')), elementXML, true);
    elementXML = this.schemaManager.getNamedDefinition(ref, this.schemaConstants.elementTypeQName);
    if (elementXML == null)
      throw new Error("Cannot resolve element definition for ref '" + ref + "'");
  }
  var /** @type {string} */ partName = org.apache.royale.utils.Language.string(elementXML.attribute('name'));
  var /** @type {QName} */ partQName = this.schemaManager.getQNameForElement(partName, org.apache.royale.utils.Language.string(elementXML.attribute('form')));
  var /** @type {mx.rpc.wsdl.WSDLMessagePart} */ part = new mx.rpc.wsdl.WSDLMessagePart(partQName);
  var /** @type {string} */ minOccurs = org.apache.royale.utils.Language.string(elementXML.attribute('minOccurs'));
  var /** @type {string} */ maxOccurs = org.apache.royale.utils.Language.string(elementXML.attribute('maxOccurs'));
  if (minOccurs != "" && parseInt(minOccurs, undefined) == 0)
    part.optional = true;
  if (ref != null) {
    part.element = ref;
  } else {
    var /** @type {string} */ partType = org.apache.royale.utils.Language.string(elementXML.attribute('type'));
    if (partType != "" || !elementXML.hasComplexContent()) {
      if (partType == null || partType == "")
        part.type = this.schemaConstants.anyTypeQName;
      else
        part.type = this.schemaManager.getQNameForPrefixedName(partType, elementXML);
      if (minOccurs != "" || maxOccurs != "") {
        part.definition = elementXML;
      }
    } else if (elementXML.hasComplexContent()) {
      part.definition = elementXML;
    }
  }
  if (ref != null)
    this.schemaManager.releaseScope();
  return part;
};


/**
 * Determines the WSDL and SOAP versions from the definitions and creates
 * a map of top level prefixes to namespaces.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @private
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_processNamespaces = function() {
  if (this.mx_rpc_wsdl_WSDL__xml != null) {
    var /** @type {string} */ tns = this.mx_rpc_wsdl_WSDL__xml.attribute('targetNamespace').toString();
    this.mx_rpc_wsdl_WSDL__targetNamespace = new Namespace(tns);
    this.mx_rpc_wsdl_WSDL_namespaces = {};
    var /** @type {Array} */ nsArray = this.mx_rpc_wsdl_WSDL__xml.namespaceDeclarations();
    var foreachiter22_target = nsArray;
    for (var foreachiter22 in foreachiter22_target) 
    {
    var ns = foreachiter22_target[foreachiter22];
    {
      this.mx_rpc_wsdl_WSDL_namespaces[ns.prefix] = ns;
    }}
    
    this.mx_rpc_wsdl_WSDL__wsdlConstants = mx.rpc.wsdl.WSDLConstants.getConstants(this.mx_rpc_wsdl_WSDL__xml);
    this.mx_rpc_wsdl_WSDL__schemaConstants = mx.rpc.xml.SchemaConstants.getConstants(this.mx_rpc_wsdl_WSDL__xml);
    this.schemaManager.addNamespaces(this.mx_rpc_wsdl_WSDL_namespaces);
  }
};


/**
 * @private
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_processSchemas = function() {
  var /** @type {XML} */ types = this.getTypes(this.targetNamespace);
  if (types != null) {
    var /** @type {XMLList} */ schemas = types.elements(this.schemaConstants.schemaQName);
    var foreachiter23_target = schemas;
    for (var foreachiter23 in foreachiter23_target.elementNames()) 
    {
    var schemaXML = foreachiter23_target[foreachiter23];
    {
      var /** @type {mx.rpc.xml.Schema} */ schema = new mx.rpc.xml.Schema(schemaXML);
      this.addSchema(schema);
    }}
    
  }
};


/**
 * @private
 * @type {mx.rpc.xml.QualifiedResourceManager}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_importsManager;


/**
 * @private
 * @type {mx.logging.ILogger}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__log;


/**
 * @private
 * @type {Object}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_namespaces;


/**
 * @private
 * @type {mx.rpc.xml.SchemaConstants}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__schemaConstants;


/**
 * @private
 * @type {mx.rpc.xml.SchemaManager}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__schemaManager;


/**
 * @private
 * @type {Object}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL_serviceMap;


/**
 * @private
 * @type {mx.rpc.soap.SOAPConstants}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__soapConstants;


/**
 * @private
 * @type {Namespace}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__targetNamespace;


/**
 * @private
 * @type {mx.rpc.wsdl.WSDLConstants}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__wsdlConstants;


/**
 * @private
 * @type {XML}
 */
mx.rpc.wsdl.WSDL.prototype.mx_rpc_wsdl_WSDL__xml;


mx.rpc.wsdl.WSDL.prototype.get__schemaManager = function() {
  if (this.mx_rpc_wsdl_WSDL__schemaManager == null) {
    this.mx_rpc_wsdl_WSDL__schemaManager = new mx.rpc.xml.SchemaManager();
    this.mx_rpc_wsdl_WSDL__schemaManager.schemaConstants = this.schemaConstants;
  }
  return this.mx_rpc_wsdl_WSDL__schemaManager;
};


mx.rpc.wsdl.WSDL.prototype.get__schemaConstants = function() {
  if (this.mx_rpc_wsdl_WSDL__schemaConstants == null)
    this.mx_rpc_wsdl_WSDL__schemaConstants = mx.rpc.xml.SchemaConstants.getConstants(this.xml);
  return this.mx_rpc_wsdl_WSDL__schemaConstants;
};


mx.rpc.wsdl.WSDL.prototype.get__soapConstants = function() {
  if (this.mx_rpc_wsdl_WSDL__soapConstants == null)
    this.mx_rpc_wsdl_WSDL__soapConstants = mx.rpc.soap.SOAPConstants.getConstants(this.xml);
  return this.mx_rpc_wsdl_WSDL__soapConstants;
};


mx.rpc.wsdl.WSDL.prototype.get__targetNamespace = function() {
  return this.mx_rpc_wsdl_WSDL__targetNamespace;
};


mx.rpc.wsdl.WSDL.prototype.get__wsdlConstants = function() {
  if (this.mx_rpc_wsdl_WSDL__wsdlConstants == null)
    this.mx_rpc_wsdl_WSDL__wsdlConstants = mx.rpc.wsdl.WSDLConstants.getConstants(this.xml);
  return this.mx_rpc_wsdl_WSDL__wsdlConstants;
};


mx.rpc.wsdl.WSDL.prototype.get__xml = function() {
  return this.mx_rpc_wsdl_WSDL__xml;
};


Object.defineProperties(mx.rpc.wsdl.WSDL.prototype, /** @lends {mx.rpc.wsdl.WSDL.prototype} */ {
/**
  * @export
  * @type {mx.rpc.xml.SchemaManager} */
schemaManager: {
get: mx.rpc.wsdl.WSDL.prototype.get__schemaManager},
/**
  * @export
  * @type {mx.rpc.xml.SchemaConstants} */
schemaConstants: {
get: mx.rpc.wsdl.WSDL.prototype.get__schemaConstants},
/**
  * @export
  * @type {mx.rpc.soap.SOAPConstants} */
soapConstants: {
get: mx.rpc.wsdl.WSDL.prototype.get__soapConstants},
/**
  * @export
  * @type {Namespace} */
targetNamespace: {
get: mx.rpc.wsdl.WSDL.prototype.get__targetNamespace},
/**
  * @export
  * @type {mx.rpc.wsdl.WSDLConstants} */
wsdlConstants: {
get: mx.rpc.wsdl.WSDL.prototype.get__wsdlConstants},
/**
  * @export
  * @type {XML} */
xml: {
get: mx.rpc.wsdl.WSDL.prototype.get__xml}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.rpc.wsdl.WSDL.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'WSDL', qName: 'mx.rpc.wsdl.WSDL', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.rpc.wsdl.WSDL.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'schemaManager': { type: 'mx.rpc.xml.SchemaManager', access: 'readonly', declaredBy: 'mx.rpc.wsdl.WSDL'},
        'schemaConstants': { type: 'mx.rpc.xml.SchemaConstants', access: 'readonly', declaredBy: 'mx.rpc.wsdl.WSDL'},
        'soapConstants': { type: 'mx.rpc.soap.SOAPConstants', access: 'readonly', declaredBy: 'mx.rpc.wsdl.WSDL'},
        'targetNamespace': { type: 'Namespace', access: 'readonly', declaredBy: 'mx.rpc.wsdl.WSDL'},
        'wsdlConstants': { type: 'mx.rpc.wsdl.WSDLConstants', access: 'readonly', declaredBy: 'mx.rpc.wsdl.WSDL'},
        'xml': { type: 'XML', access: 'readonly', declaredBy: 'mx.rpc.wsdl.WSDL'}
      };
    },
    methods: function () {
      return {
        'WSDL': { type: '', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'XML', false ,'mx.rpc.xml.SchemaManager', true ]; }},
        'addImport': { type: 'void', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'Namespace', false ,'mx.rpc.wsdl.WSDL', false ]; }},
        'addSchema': { type: 'void', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'mx.rpc.xml.Schema', false ]; }},
        'getOperation': { type: 'mx.rpc.wsdl.WSDLOperation', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'String', false ,'String', true ,'String', true ]; }},
        'getPort': { type: 'mx.rpc.wsdl.WSDLPort', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'String', true ,'String', true ]; }},
        'getService': { type: 'mx.rpc.wsdl.WSDLService', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'String', true ,'String', true ]; }},
        'getTypes': { type: 'XML', declaredBy: 'mx.rpc.wsdl.WSDL', parameters: function () { return [ 'Namespace', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.rpc.wsdl.WSDL.prototype.ROYALE_COMPILE_FLAGS = 26;
