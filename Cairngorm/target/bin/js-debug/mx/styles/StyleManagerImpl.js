/**
 * Generated by Apache Royale Compiler from mx/styles/StyleManagerImpl.as
 * mx.styles.StyleManagerImpl
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('mx.styles.StyleManagerImpl');
/* Royale Dependency List: mx.core.IFlexModuleFactory,mx.core.mx_internal,mx.managers.SystemManagerGlobals,mx.modules.IModuleInfo,mx.styles.CSSStyleDeclaration,mx.styles.StyleManager,org.apache.royale.utils.Language,XML*/
goog.provide('mx.styles.StyleManagerImpl.CSSClass');
goog.provide('mx.styles.StyleManagerImpl.CSSDataType');
goog.provide('mx.styles.StyleManagerImpl.CSSFactory');
goog.provide('mx.styles.StyleManagerImpl.StyleEventDispatcher');

goog.require('mx.styles.IStyleManager2');
goog.require('org.apache.royale.events.EventDispatcher');



/**
 *  @asprivate
 * 
 *  @asparam moduleFactory The module factory that is creating this instance. May not be null.
 * @constructor
 * @extends {org.apache.royale.events.EventDispatcher}
 * @implements {mx.styles.IStyleManager2}
 * @param {mx.core.IFlexModuleFactory=} moduleFactory
 */
mx.styles.StyleManagerImpl = function(moduleFactory) {
  moduleFactory = typeof moduleFactory !== 'undefined' ? moduleFactory : null;
  
  this.mx_styles_StyleManagerImpl_inheritingTextFormatStyles = {align:true, bold:true, color:true, font:true, indent:true, italic:true, size:true};
  this.mx_styles_StyleManagerImpl_sizeInvalidatingStyles = {alignmentBaseline:true, baselineShift:true, blockProgression:true, borderStyle:true, borderThickness:true, breakOpportunity:true, cffHinting:true, columnCount:true, columnGap:true, columnWidth:true, digitCase:true, digitWidth:true, direction:true, dominantBaseline:true, firstBaselineOffset:true, fontAntiAliasType:true, fontFamily:true, fontGridFitType:true, fontLookup:true, fontSharpness:true, fontSize:true, fontStyle:true, fontThickness:true, fontWeight:true, headerHeight:true, horizontalAlign:true, horizontalGap:true, justificationRule:true, justificationStyle:true, kerning:true, leading:true, leadingModel:true, letterSpacing:true, ligatureLevel:true, lineBreak:true, lineHeight:true, lineThrough:true, listAutoPadding:true, listStylePosition:true, listStyleType:true, locale:true, marginBottom:true, marginLeft:true, marginRight:true, marginTop:true, paddingBottom:true, paddingLeft:true, paddingRight:true, paddingTop:true, paragraphEndIndent:true, paragraphStartIndent:true, paragraphSpaceAfter:true, paragraphSpaceBefore:true, renderingMode:true, strokeWidth:true, tabHeight:true, tabWidth:true, tabStops:true, textAlign:true, textAlignLast:true, textDecoration:true, textIndent:true, textJustify:true, textRotation:true, tracking:true, trackingLeft:true, trackingRight:true, typographicCase:true, verticalAlign:true, verticalGap:true, wordSpacing:true, whitespaceCollapse:true};
  this.mx_styles_StyleManagerImpl_parentSizeInvalidatingStyles = {baseline:true, bottom:true, horizontalCenter:true, left:true, right:true, top:true, verticalCenter:true};
  this.mx_styles_StyleManagerImpl_parentDisplayListInvalidatingStyles = {baseline:true, bottom:true, horizontalCenter:true, left:true, right:true, top:true, verticalCenter:true};
  this.mx_styles_StyleManagerImpl_colorNames = {transparent:"transparent", black:0x000000, blue:0x0000FF, green:0x008000, gray:0x808080, silver:0xC0C0C0, lime:0x00FF00, olive:0x808000, white:0xFFFFFF, yellow:0xFFFF00, maroon:0x800000, navy:0x000080, red:0xFF0000, purple:0x800080, teal:0x008080, fuchsia:0xFF00FF, aqua:0x00FFFF, magenta:0xFF00FF, cyan:0x00FFFF, orange:0xFFA500, darkgrey:0xA9A9A9, brown:0xA52A2A, tan:0xD2B48C, lightgrey:0xD3D3D3, darkgreen:0x006400, halogreen:0x80FF4D, haloblue:0x009DFF, haloorange:0xFFB600, halosilver:0xAECAD9};
  this.mx_styles_StyleManagerImpl__selectors = {};
  this.mx_styles_StyleManagerImpl_styleModules = {};
  this.mx_styles_StyleManagerImpl__subjects = {};
  this.mx_styles_StyleManagerImpl__inheritingStyles = {};
  mx.styles.StyleManagerImpl.base(this, 'constructor');
  if (!moduleFactory)
    return;
  this.mx_styles_StyleManagerImpl_moduleFactory = moduleFactory;
};
goog.inherits(mx.styles.StyleManagerImpl, org.apache.royale.events.EventDispatcher);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.styles.StyleManagerImpl', mx.styles.StyleManagerImpl);


/**
 * @private
 * @type {mx.styles.IStyleManager2}
 */
mx.styles.StyleManagerImpl.instance;


/**
 *  @asprivate
 * @export
 * @param {mx.core.IFlexModuleFactory} fbs
 */
mx.styles.StyleManagerImpl.init = function(fbs) {
  var /** @type {string} */ styleDataClassName = org.apache.royale.utils.Language.string(fbs.info()["styleDataClassName"]);
  if (styleDataClassName) {
    var /** @type {mx.styles.StyleManagerImpl} */ sm = org.apache.royale.utils.Language.as(fbs.getImplementation("mx.styles::IStyleManager2"), mx.styles.StyleManagerImpl);
    if (!sm)
      sm = new mx.styles.StyleManagerImpl(fbs);
    var /** @type {Object} */ styleDataClass = fbs.info()["currentDomain"].getDefinition(styleDataClassName);
    var /** @type {Array} */ styleNames = styleDataClass["inheritingStyles"];
    var foreachiter0_target = styleNames;
    for (var foreachiter0 in foreachiter0_target) 
    {
    var s = foreachiter0_target[foreachiter0];
    {
      sm.registerInheritingStyle(s);
    }}
    
    mx.styles.StyleManagerImpl.generateCSSStyleDeclarations(sm, styleDataClass["factoryFunctions"], styleDataClass["data"]);
    sm.initProtoChainRoots();
  }
};


/**
 * @export
 * @param {mx.styles.StyleManagerImpl} styleManager
 * @param {Object} factoryFunctions
 * @param {Array} data
 * @param {Array=} newSelectors
 * @param {Object=} overrideMap
 */
mx.styles.StyleManagerImpl.generateCSSStyleDeclarations = function(styleManager, factoryFunctions, data, newSelectors, overrideMap) {
  newSelectors = typeof newSelectors !== 'undefined' ? newSelectors : null;
  overrideMap = typeof overrideMap !== 'undefined' ? overrideMap : null;
  org.apache.royale.utils.Language.trace("generateCSSStyleDeclarations not implemented");
};


mx.styles.StyleManagerImpl.get__propList1 = function() {
  var value = new (org.apache.royale.utils.Language.synthVector('String'))();
  Object.defineProperty(mx.styles.StyleManagerImpl, 'propList1', { value: value, writable: true });
  return value;
};
mx.styles.StyleManagerImpl.set__propList1 = function(value) {
  Object.defineProperty(mx.styles.StyleManagerImpl, 'propList1', { value: value, writable: true });
};
Object.defineProperties(mx.styles.StyleManagerImpl, /** @lends {mx.styles.StyleManagerImpl} */ {
/**
 * @private
 * @type {Array.<string>}
 */
propList1: {
  get: mx.styles.StyleManagerImpl.get__propList1,
  set: mx.styles.StyleManagerImpl.set__propList1,
  configurable: true}});


mx.styles.StyleManagerImpl.get__propList2 = function() {
  var value = new (org.apache.royale.utils.Language.synthVector('String'))();
  Object.defineProperty(mx.styles.StyleManagerImpl, 'propList2', { value: value, writable: true });
  return value;
};
mx.styles.StyleManagerImpl.set__propList2 = function(value) {
  Object.defineProperty(mx.styles.StyleManagerImpl, 'propList2', { value: value, writable: true });
};
Object.defineProperties(mx.styles.StyleManagerImpl, /** @lends {mx.styles.StyleManagerImpl} */ {
/**
 * @private
 * @type {Array.<string>}
 */
propList2: {
  get: mx.styles.StyleManagerImpl.get__propList2,
  set: mx.styles.StyleManagerImpl.set__propList2,
  configurable: true}});


/**
 *  @asprivate
 * @private
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {number}
 */
mx.styles.StyleManagerImpl.compareFactories = function(obj1, obj2) {
  mx.styles.StyleManagerImpl.propList1[org.apache.royale.utils.Language.SYNTH_TAG_FIELD].length = mx.styles.StyleManagerImpl.propList2[org.apache.royale.utils.Language.SYNTH_TAG_FIELD].length = 0;
  for (var /** @type {string} */ p in obj1)
    mx.styles.StyleManagerImpl.propList1.push(p);
  for (p in obj2)
    mx.styles.StyleManagerImpl.propList2.push(p);
  if (mx.styles.StyleManagerImpl.propList1.length != mx.styles.StyleManagerImpl.propList2.length)
    return 1;
  var foreachiter1_target = mx.styles.StyleManagerImpl.propList1;
  for (var foreachiter1 in foreachiter1_target) 
  {
  p = foreachiter1_target[foreachiter1];
  {
    if (obj1[p] !== obj2[p])
      return 1;
  }}
  
  return 0;
};


/**
 *  @asprivate
 * @export
 * @return {mx.styles.IStyleManager2}
 */
mx.styles.StyleManagerImpl.getInstance = function() {
  if (!mx.styles.StyleManagerImpl.instance) {
    mx.styles.StyleManagerImpl.instance = org.apache.royale.utils.Language.as(org.apache.royale.utils.Language.as(mx.managers.SystemManagerGlobals.topLevelSystemManagers[0], mx.core.IFlexModuleFactory, true).getImplementation("mx.styles::IStyleManager2"), mx.styles.IStyleManager2, true);
    if (!mx.styles.StyleManagerImpl.instance)
      mx.styles.StyleManagerImpl.instance = new mx.styles.StyleManagerImpl(mx.managers.SystemManagerGlobals.topLevelSystemManagers[0]);
  }
  return mx.styles.StyleManagerImpl.instance;
};


/**
 * @private
 * @type {number}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_selectorIndex = 0;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_inheritingTextFormatStyles;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_sizeInvalidatingStyles;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_parentSizeInvalidatingStyles;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_parentDisplayListInvalidatingStyles;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_colorNames;


/**
 * @private
 * @type {boolean}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__hasAdvancedSelectors;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__pseudoCSSStates;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__selectors;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_styleModules;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__subjects;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_mergedInheritingStylesCache;


/**
 * @private
 * @type {mx.core.IFlexModuleFactory}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_moduleFactory;


/**
 * @private
 * @type {mx.styles.IStyleManager2}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__parent;


/**
 * @private
 * @type {boolean}
 */
mx.styles.StyleManagerImpl._qualifiedTypeSelectors = true;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__stylesRoot;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__inheritingStyles;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__typeHierarchyCache;


/**
 * @private
 * @type {Object}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl__typeSelectorCache;


/**
 *  @asprivate
 *  This method is called by code autogenerated by the MXML compiler,
 *  after StyleManager.styles is popuplated with CSSStyleDeclarations.
 * @export
 */
mx.styles.StyleManagerImpl.prototype.initProtoChainRoots = function() {
  org.apache.royale.utils.Language.trace("initProtoChainRoots not implemented");
};


/**
 *  Determines whether any of the selectors registered with the style
 *  manager have been advanced selectors (descendant selector, id selector,
 *  non-global class selector, pseudo selector).
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.hasAdvancedSelectors = function() {
  if (this.mx_styles_StyleManagerImpl__hasAdvancedSelectors)
    return true;
  return false;
};


/**
 * @asprivate
 * Determines whether at least one pseudo-condition has been specified for
 * the given state.
 * @export
 * @param {string} cssState
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.hasPseudoCondition = function(cssState) {
  if (this.mx_styles_StyleManagerImpl__pseudoCSSStates != null && this.mx_styles_StyleManagerImpl__pseudoCSSStates[cssState] != null)
    return true;
  return false;
};


/**
 * @private
 * @type {Array}
 */
mx.styles.StyleManagerImpl.propNames = ["class", "id", "pseudo", "unconditional"];


/**
 *  Retrieve all style declarations applicable to this subject. The subject
 *  is the right most simple type selector in a selector chain. Returns a 
 *  map of selectors with four properties: class for class selectors,
 *  id for id selectors, pseudo for pseudo selectors and unconditional
 *  for selectors without conditions
 * 
 * 
 *  @asparam subject The subject of the style declaration's selector.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 10
 *  @playerversion AIR 1.5
 *  @productversion Flex 4
 * @export
 * @param {string} subject
 * @return {Object}
 */
mx.styles.StyleManagerImpl.prototype.getStyleDeclarations = function(subject) {
  org.apache.royale.utils.Language.trace("getStyleDeclarations not implemented");
  return null;
};


/**
 * @private
 * @param {*} element
 * @param {number} index
 * @param {Array} arr
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.mx_styles_StyleManagerImpl_isUnique = function(element, index, arr) {
  return (arr.indexOf(element) >= 0);
};


/**
 *  Gets the CSSStyleDeclaration object that stores the rules
 *  for the specified CSS selector.
 *
 *  <p>If the <code>selector</code> parameter starts with a period (.),
 *  the returned CSSStyleDeclaration is a class selector and applies only to those instances
 *  whose <code>styleName</code> property specifies that selector
 *  (not including the period).
 *  For example, the class selector <code>".bigMargins"</code>
 *  applies to any UIComponent whose <code>styleName</code>
 *  is <code>"bigMargins"</code>.</p>
 *
 *  <p>If the <code>selector</code> parameter does not start with a period,
 *  the returned CSSStyleDeclaration is a type selector and applies to all instances
 *  of that type.
 *  For example, the type selector <code>"Button"</code>
 *  applies to all instances of Button and its subclasses.</p>
 *
 *  <p>The <code>global</code> selector is similar to a type selector
 *  and does not start with a period.</p>
 *
 *  @asparam selector The name of the CSS selector.
 *
 *  @asreturn The style declaration whose name matches the <code>selector</code> property.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} selector
 * @return {mx.styles.CSSStyleDeclaration}
 */
mx.styles.StyleManagerImpl.prototype.getStyleDeclaration = function(selector) {
  if (this.mx_styles_StyleManagerImpl__selectors[selector] == null) {
    var /** @type {mx.styles.CSSStyleDeclaration} */ styles = new mx.styles.CSSStyleDeclaration();
    styles.name = selector;
    this.mx_styles_StyleManagerImpl__selectors[selector] = styles;
  }
  return this.mx_styles_StyleManagerImpl__selectors[selector];
};


/** 
 * Gets a CSSStyleDeclaration object that stores the rules 
 * for the specified CSS selector. The CSSStyleDeclaration object is the created by merging
 * the properties of the specified CSS selector of this style manager with all of the parent
 * style managers.
 * 
 * <p>
 * If this style manager contains a style declaration for the given selector, its style properties
 * will be updated with properties from the parent style manager's merged style declaration. If
 * this style manager does not have a style declaration for a given selector, the parent's merged
 * style declaration will be set into this style manager depending on the value of the <code>
 * setSelector</code> parameter.
 * </p>
 * 
 * <p>If the <code>selector</code> parameter starts with a period (.), 
 * the returned CSSStyleDeclaration is a class selector and applies only to those instances 
 * whose <code>styleName</code> property specifies that selector 
 * (not including the period). 
 * For example, the class selector <code>".bigMargins"</code> 
 * applies to any UIComponent whose <code>styleName</code> 
 * is <code>"bigMargins"</code>.</p> 
 * 
 * <p>If the <code>selector</code> parameter does not start with a period, 
 * the returned CSSStyleDeclaration is a type selector and applies to all instances 
 * of that type. 
 * For example, the type selector <code>"Button"</code> 
 * applies to all instances of Button and its subclasses.</p> 
 * 
 * <p>The <code>global</code> selector is similar to a type selector 
 * and does not start with a period.</p> 
 * 
 * @asparam selector The name of the CSS selector. 
 * @asparam localOnly Controls whether the returned style declaration is the result of merging  
 * the properties of this and any parent style managers or if the style declaration is only 
 * from this style manager. 
 * 
 * @asreturn The style declaration whose name matches the <code>selector</code> property. 
 *  
 * @langversion 3.0 
 * @playerversion Flash 9 
 * @playerversion AIR 1.1 
 * @productversion Flex 4 
 * @export
 * @param {string} selector
 * @return {mx.styles.CSSStyleDeclaration}
 */
mx.styles.StyleManagerImpl.prototype.getMergedStyleDeclaration = function(selector) {
  org.apache.royale.utils.Language.trace("getMergedStyleDeclaration not implemented");
  return null;
};


/**
 *  Sets the CSSStyleDeclaration object that stores the rules
 *  for the specified CSS selector.
 *
 *  <p>If the <code>selector</code> parameter starts with a period (.),
 *  the specified selector is a class selector and applies only to those instances
 *  whose <code>styleName</code> property specifies that selector
 *  (not including the period).
 *  For example, the class selector <code>".bigMargins"</code>
 *  applies to any UIComponent whose <code>styleName</code>
 *  is <code>"bigMargins"</code>.</p>
 *
 *  <p>If the <code>selector</code> parameter does not start with a period,
 *  the specified selector is a "type selector" and applies to all instances
 *  of that type.
 *  For example, the type selector <code>"Button"</code>
 *  applies to all instances of Button and its subclasses.</p>
 *
 *  <p>The <code>global</code> selector is similar to a type selector
 *  and does not start with a period.</p>
 *
 *  <p>Note that the provided selector will update the selector and subject
 *  of the styleDeclaration to keep them in sync.</p>
 * 
 *  @asparam selector The name of the CSS selector.
 *  @asparam styleDeclaration The new style declaration.
 *  @asparam update Set to <code>true</code> to force an immediate update of the styles.
 *  Set to <code>false</code> to avoid an immediate update of the styles in the application.
 *  The styles will be updated the next time this method or the <code>clearStyleDeclaration()</code> method
 *  is called with the <code>update</code> property set to <code>true</code>.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} selector
 * @param {mx.styles.CSSStyleDeclaration} styleDeclaration
 * @param {boolean} update
 */
mx.styles.StyleManagerImpl.prototype.setStyleDeclaration = function(selector, styleDeclaration, update) {
  this.mx_styles_StyleManagerImpl__selectors[selector] = styleDeclaration;
};


/**
 *  Clears the CSSStyleDeclaration object that stores the rules
 *  for the specified CSS selector.
 *
 *  <p>If the specified selector is a class selector (for example, ".bigMargins" or ".myStyle"),
 *  you must be sure to start the
 *  <code>selector</code> property with a period (.).</p>
 *
 *  <p>If the specified selector is a type selector (for example, "Button"), do not start the
 *  <code>selector</code> property with a period.</p>
 *
 *  <p>The <code>global</code> selector is similar to a type selector
 *  and does not start with a period.</p>
 *
 *  @asparam selector The name of the CSS selector to clear.
 *  @asparam update Set to <code>true</code> to force an immediate update of the styles.
 *  Set to <code>false</code> to avoid an immediate update of the styles in the application.
 *  The styles will be updated the next time this method or the <code>setStyleDeclaration()</code> method is
 *  called with the <code>update</code> property set to <code>true</code>.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} selector
 * @param {boolean} update
 */
mx.styles.StyleManagerImpl.prototype.clearStyleDeclaration = function(selector, update) {
  org.apache.royale.utils.Language.trace("clearStyleDeclaration not implemented");
};


/**
 *  @asprivate
 *  After an entire selector is added, replaced, or removed,
 *  this method updates all the DisplayList trees.
 * @export
 */
mx.styles.StyleManagerImpl.prototype.styleDeclarationsChanged = function() {
  org.apache.royale.utils.Language.trace("styleDeclarationsChanged not implemented");
};


/**
 *  Adds to the list of styles that can inherit values
 *  from their parents.
 *
 *  <p><b>Note:</b> Ensure that you avoid using duplicate style names, as name
 *  collisions can result in decreased performance if a style that is
 *  already used becomes inheriting.</p>
 *
 *  @asparam styleName The name of the style that is added to the list of styles that can inherit values.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 */
mx.styles.StyleManagerImpl.prototype.registerInheritingStyle = function(styleName) {
  if (this.mx_styles_StyleManagerImpl__inheritingStyles[styleName] != true) {
    this.mx_styles_StyleManagerImpl__inheritingStyles[styleName] = true;
    this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache = null;
  }
};


/**
 *  Tests to see if a style is inheriting.
 *
 *  @asparam styleName The name of the style that you test to see if it is inheriting.
 *
 *  @asreturn Returns <code>true</code> if the specified style is inheriting.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isInheritingStyle = function(styleName) {
  if (this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache)
    return this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache[styleName] == true;
  if (this.mx_styles_StyleManagerImpl__inheritingStyles[styleName] == true)
    return true;
  return false;
};


/**
 *  Test to see if a TextFormat style is inheriting.
 *
 *  @asparam styleName The name of the style that you test to see if it is inheriting.
 *
 *  @asreturn Returns <code>true</code> if the specified TextFormat style
 *  is inheriting.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isInheritingTextFormatStyle = function(styleName) {
  if (this.mx_styles_StyleManagerImpl_inheritingTextFormatStyles[styleName] == true)
    return true;
  return false;
};


/**
 *  Adds to the list of styles which may affect the measured size
 *  of the component.
 *  When one of these styles is set with <code>setStyle()</code>,
 *  the <code>invalidateSize()</code> method is automatically called on the component
 *  to make its measured size get recalculated later.
 *
 *  @asparam styleName The name of the style that you add to the list.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 */
mx.styles.StyleManagerImpl.prototype.registerSizeInvalidatingStyle = function(styleName) {
  this.mx_styles_StyleManagerImpl_sizeInvalidatingStyles[styleName] = true;
};


/**
 *  Tests to see if a style changes the size of a component.
 *
 *  <p>When one of these styles is set with the <code>setStyle()</code> method,
 *  the <code>invalidateSize()</code> method is automatically called on the component
 *  to make its measured size get recalculated later.</p>
 *
 *  @asparam styleName The name of the style to test.
 *
 *  @asreturn Returns <code>true</code> if the specified style is one
 *  which may affect the measured size of the component.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isSizeInvalidatingStyle = function(styleName) {
  if (this.mx_styles_StyleManagerImpl_sizeInvalidatingStyles[styleName] == true)
    return true;
  return false;
};


/**
 *  Adds to the list of styles which may affect the measured size
 *  of the component's parent container.
 *  <p>When one of these styles is set with <code>setStyle()</code>,
 *  the <code>invalidateSize()</code> method is automatically called on the component's
 *  parent container to make its measured size get recalculated
 *  later.</p>
 *
 *  @asparam styleName The name of the style to register.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 */
mx.styles.StyleManagerImpl.prototype.registerParentSizeInvalidatingStyle = function(styleName) {
  this.mx_styles_StyleManagerImpl_parentSizeInvalidatingStyles[styleName] = true;
};


/**
 *  Tests to see if the style changes the size of the component's parent container.
 *
 *  <p>When one of these styles is set with <code>setStyle()</code>,
 *  the <code>invalidateSize()</code> method is automatically called on the component's
 *  parent container to make its measured size get recalculated
 *  later.</p>
 *
 *  @asparam styleName The name of the style to test.
 *
 *  @asreturn Returns <code>true</code> if the specified style is one
 *  which may affect the measured size of the component's
 *  parent container.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isParentSizeInvalidatingStyle = function(styleName) {
  if (this.mx_styles_StyleManagerImpl_parentSizeInvalidatingStyles[styleName] == true)
    return true;
  return false;
};


/**
 *  Adds to the list of styles which may affect the appearance
 *  or layout of the component's parent container.
 *  When one of these styles is set with <code>setStyle()</code>,
 *  the <code>invalidateDisplayList()</code> method is auomatically called on the component's
 *  parent container to make it redraw and/or relayout its children.
 *
 *  @asparam styleName The name of the style to register.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 */
mx.styles.StyleManagerImpl.prototype.registerParentDisplayListInvalidatingStyle = function(styleName) {
  this.mx_styles_StyleManagerImpl_parentDisplayListInvalidatingStyles[styleName] = true;
};


/**
 *  Tests to see if this style affects the component's parent container in
 *  such a way as to require that the parent container redraws itself when this style changes.
 *
 *  <p>When one of these styles is set with <code>setStyle()</code>,
 *  the <code>invalidateDisplayList()</code> method is auomatically called on the component's
 *  parent container to make it redraw and/or relayout its children.</p>
 *
 *  @asparam styleName The name of the style to test.
 *
 *  @asreturn Returns <code>true</code> if the specified style is one
 *  which may affect the appearance or layout of the component's
 *  parent container.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} styleName
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isParentDisplayListInvalidatingStyle = function(styleName) {
  if (this.mx_styles_StyleManagerImpl_parentDisplayListInvalidatingStyles[styleName] == true)
    return true;
  return false;
};


/**
 *  Adds a color name to the list of aliases for colors.
 *
 *  @asparam colorName The name of the color to add to the list; for example, "blue".
 *  If you later access this color name, the value is not case-sensitive.
 *
 *  @asparam colorValue Color value, for example, 0x0000FF.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} colorName
 * @param {number} colorValue
 */
mx.styles.StyleManagerImpl.prototype.registerColorName = function(colorName, colorValue) {
  this.mx_styles_StyleManagerImpl_colorNames[colorName.toLowerCase()] = colorValue;
};


/**
 *  Tests to see if the given String is an alias for a color value. For example,
 *  by default, the String "blue" is an alias for 0x0000FF.
 *
 *  @asparam colorName The color name to test. This parameter is not case-sensitive.
 *
 *  @asreturn Returns <code>true</code> if <code>colorName</code> is an alias
 *  for a color.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {string} colorName
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isColorName = function(colorName) {
  if (this.mx_styles_StyleManagerImpl_colorNames[colorName.toLowerCase()] !== undefined)
    return true;
  return false;
};


/**
 *  Returns the numeric RGB color value that corresponds to the
 *  specified color string.
 *  The color string can be either a case-insensitive color name
 *  such as <code>"red"</code>, <code>"Blue"</code>, or
 *  <code>"haloGreen"</code>, a hexadecimal value such as 0xFF0000, or a #-hexadecimal String
 *  such as <code>"#FF0000"</code>.
 *
 *  <p>This method returns a uint, such as 4521830, that represents a color. You can convert
 *  this uint to a hexadecimal value by passing the numeric base (in this case, 16), to
 *  the uint class's <code>toString()</code> method, as the following example shows:</p>
 *  <pre>
 *  import mx.styles.StyleManager;
 *  private function getNewColorName():void {
 *      StyleManager.registerColorName("soylentGreen",0x44FF66);
 *      trace(StyleManager.getColorName("soylentGreen").toString(16));
 *  }
 *  </pre>
 *
 *  @asparam colorName The color name.
 *
 *  @asreturn Returns a uint that represents the color value or <code>NOT_A_COLOR</code>
 *  if the value of the <code>colorName</code> property is not an alias for a color.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Object} colorName
 * @return {number}
 */
mx.styles.StyleManagerImpl.prototype.getColorName = function(colorName) {
  var /** @type {number} */ n;
  if (org.apache.royale.utils.Language.is(colorName, String)) {
    if (colorName.charAt(0) == "#") {
      n = Number("0x" + colorName.slice(1));
      return isNaN(n) ? mx.styles.StyleManager.NOT_A_COLOR : org.apache.royale.utils.Language.uint(n);
    }
    if (colorName.charAt(1) == "x" && colorName.charAt(0) == '0') {
      n = Number(colorName);
      return isNaN(n) ? mx.styles.StyleManager.NOT_A_COLOR : org.apache.royale.utils.Language.uint(n);
    }
    var /** @type {*} */ c = this.mx_styles_StyleManagerImpl_colorNames[colorName.toLowerCase()];
    if (c === undefined)
      return mx.styles.StyleManager.NOT_A_COLOR;
    return org.apache.royale.utils.Language.uint(c);
  }
  return org.apache.royale.utils.Language.uint(colorName);
};


/**
 *  Converts each element of the colors Array from a color name
 *  to a numeric RGB color value.
 *  Each color String can be either a case-insensitive color name
 *  such as <code>"red"</code>, <code>"Blue"</code>, or
 *  <code>"haloGreen"</code>, a hexadecimal value such as 0xFF0000, or a #-hexadecimal String
 *  such as <code>"#FF0000"</code>..
 *
 *  @asparam colors An Array of color names.
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {Array} colors
 */
mx.styles.StyleManagerImpl.prototype.getColorNames = function(colors) {
  if (!colors)
    return;
  var /** @type {number} */ n = (colors.length) >> 0;
  for (var /** @type {number} */ i = 0; i < n; i++) {
    if ((colors[i] != null) && isNaN(colors[i])) {
      var /** @type {number} */ colorNumber = this.getColorName(colors[i]);
      if (colorNumber != mx.styles.StyleManager.NOT_A_COLOR)
        colors[i] = colorNumber;
    }
  }
};


/**
 *  Determines if a specified parameter is a valid style property. For example:
 *
 *  <pre>
 *  trace(StyleManager.isValidStyleValue(myButton.getStyle("color")).toString());
 *  </pre>
 *
 *  <p>This can be useful because some styles can be set to values
 *  such as 0, <code>NaN</code>,
 *  the empty String (<code>""</code>), or <code>null</code>, which can
 *  cause an <code>if (value)</code> test to fail.</p>
 *
 *  @asparam value The style property to test.
 *
 *  @asreturn If you pass the value returned by a <code>getStyle()</code> method call
 *  to this method, it returns <code>true</code> if the style
 *  was set and <code>false</code> if it was not set.
 *
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @export
 * @param {*} value
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.isValidStyleValue = function(value) {
  if (value !== undefined)
    return true;
  return false;
};


/**
 *  @asprivate
 * @export
 * @param {string} value
 * @return {boolean}
 */
mx.styles.StyleManagerImpl.prototype.acceptMediaList = function(value) {
  return false;
};


mx.styles.StyleManagerImpl.prototype.get__parent = function() {
  return this.mx_styles_StyleManagerImpl__parent;
};


mx.styles.StyleManagerImpl.prototype.get__qualifiedTypeSelectors = function() {
  if (mx.styles.StyleManagerImpl._qualifiedTypeSelectors)
    return mx.styles.StyleManagerImpl._qualifiedTypeSelectors;
  return false;
};


mx.styles.StyleManagerImpl.prototype.set__qualifiedTypeSelectors = function(value) {
  mx.styles.StyleManagerImpl._qualifiedTypeSelectors = value;
};


mx.styles.StyleManagerImpl.prototype.get__stylesRoot = function() {
  return this.mx_styles_StyleManagerImpl__stylesRoot;
};


mx.styles.StyleManagerImpl.prototype.set__stylesRoot = function(value) {
  this.mx_styles_StyleManagerImpl__stylesRoot = value;
};


mx.styles.StyleManagerImpl.prototype.get__inheritingStyles = function() {
  if (this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache)
    return this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache;
  var /** @type {Object} */ mergedStyles = this.mx_styles_StyleManagerImpl__inheritingStyles;
  this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache = mergedStyles;
  return mergedStyles;
};


mx.styles.StyleManagerImpl.prototype.set__inheritingStyles = function(value) {
  this.mx_styles_StyleManagerImpl__inheritingStyles = value;
  this.mx_styles_StyleManagerImpl_mergedInheritingStylesCache = null;
};


mx.styles.StyleManagerImpl.prototype.get__typeHierarchyCache = function() {
  if (this.mx_styles_StyleManagerImpl__typeHierarchyCache == null)
    this.mx_styles_StyleManagerImpl__typeHierarchyCache = {};
  return this.mx_styles_StyleManagerImpl__typeHierarchyCache;
};


mx.styles.StyleManagerImpl.prototype.set__typeHierarchyCache = function(value) {
  this.mx_styles_StyleManagerImpl__typeHierarchyCache = value;
};


mx.styles.StyleManagerImpl.prototype.get__typeSelectorCache = function() {
  if (this.mx_styles_StyleManagerImpl__typeSelectorCache == null)
    this.mx_styles_StyleManagerImpl__typeSelectorCache = {};
  return this.mx_styles_StyleManagerImpl__typeSelectorCache;
};


mx.styles.StyleManagerImpl.prototype.set__typeSelectorCache = function(value) {
  this.mx_styles_StyleManagerImpl__typeSelectorCache = value;
};


mx.styles.StyleManagerImpl.prototype.get__selectors = function() {
  var /** @type {Array} */ theSelectors = [];
  for (var /** @type {string} */ i in this.mx_styles_StyleManagerImpl__selectors)
    theSelectors.push(i);
  return theSelectors;
};


Object.defineProperties(mx.styles.StyleManagerImpl.prototype, /** @lends {mx.styles.StyleManagerImpl.prototype} */ {
/**
  * @export
  * @type {mx.styles.IStyleManager2} */
parent: {
get: mx.styles.StyleManagerImpl.prototype.get__parent},
/**
  * @export
  * @type {boolean} */
qualifiedTypeSelectors: {
get: mx.styles.StyleManagerImpl.prototype.get__qualifiedTypeSelectors,
set: mx.styles.StyleManagerImpl.prototype.set__qualifiedTypeSelectors},
/**
  * @export
  * @type {Object} */
stylesRoot: {
get: mx.styles.StyleManagerImpl.prototype.get__stylesRoot,
set: mx.styles.StyleManagerImpl.prototype.set__stylesRoot},
/**
  * @export
  * @type {Object} */
inheritingStyles: {
get: mx.styles.StyleManagerImpl.prototype.get__inheritingStyles,
set: mx.styles.StyleManagerImpl.prototype.set__inheritingStyles},
/**
  * @export
  * @type {Object} */
typeHierarchyCache: {
get: mx.styles.StyleManagerImpl.prototype.get__typeHierarchyCache,
set: mx.styles.StyleManagerImpl.prototype.set__typeHierarchyCache},
/**
  * @export
  * @type {Object} */
typeSelectorCache: {
get: mx.styles.StyleManagerImpl.prototype.get__typeSelectorCache,
set: mx.styles.StyleManagerImpl.prototype.set__typeSelectorCache},
/**
  * @export
  * @type {Array} */
selectors: {
get: mx.styles.StyleManagerImpl.prototype.get__selectors}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.styles.StyleManagerImpl.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'StyleManagerImpl', qName: 'mx.styles.StyleManagerImpl', kind: 'class' }], interfaces: [mx.styles.IStyleManager2] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.styles.StyleManagerImpl.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'parent': { type: 'mx.styles.IStyleManager2', access: 'readonly', declaredBy: 'mx.styles.StyleManagerImpl'},
        'qualifiedTypeSelectors': { type: 'Boolean', access: 'readwrite', declaredBy: 'mx.styles.StyleManagerImpl'},
        'stylesRoot': { type: 'Object', access: 'readwrite', declaredBy: 'mx.styles.StyleManagerImpl'},
        'inheritingStyles': { type: 'Object', access: 'readwrite', declaredBy: 'mx.styles.StyleManagerImpl'},
        'typeHierarchyCache': { type: 'Object', access: 'readwrite', declaredBy: 'mx.styles.StyleManagerImpl'},
        'typeSelectorCache': { type: 'Object', access: 'readwrite', declaredBy: 'mx.styles.StyleManagerImpl'},
        'selectors': { type: 'Array', access: 'readonly', declaredBy: 'mx.styles.StyleManagerImpl'}
      };
    },
    methods: function () {
      return {
        '|init': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'mx.core.IFlexModuleFactory', false ]; }},
        '|generateCSSStyleDeclarations': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'mx.styles.StyleManagerImpl', false ,'Object', false ,'Array', false ,'Array', true ,'Object', true ]; }},
        '|getInstance': { type: 'mx.styles.IStyleManager2', declaredBy: 'mx.styles.StyleManagerImpl'},
        'StyleManagerImpl': { type: '', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'mx.core.IFlexModuleFactory', true ]; }},
        'initProtoChainRoots': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl'},
        'hasAdvancedSelectors': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl'},
        'hasPseudoCondition': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'getStyleDeclarations': { type: 'Object', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'getStyleDeclaration': { type: 'mx.styles.CSSStyleDeclaration', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'getMergedStyleDeclaration': { type: 'mx.styles.CSSStyleDeclaration', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'setStyleDeclaration': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ,'mx.styles.CSSStyleDeclaration', false ,'Boolean', false ]; }},
        'clearStyleDeclaration': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ,'Boolean', false ]; }},
        'styleDeclarationsChanged': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl'},
        'registerInheritingStyle': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'isInheritingStyle': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'isInheritingTextFormatStyle': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'registerSizeInvalidatingStyle': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'isSizeInvalidatingStyle': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'registerParentSizeInvalidatingStyle': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'isParentSizeInvalidatingStyle': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'registerParentDisplayListInvalidatingStyle': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'isParentDisplayListInvalidatingStyle': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'registerColorName': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ,'uint', false ]; }},
        'isColorName': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }},
        'getColorName': { type: 'uint', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'Object', false ]; }},
        'getColorNames': { type: 'void', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'Array', false ]; }},
        'isValidStyleValue': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ '*', false ]; }},
        'acceptMediaList': { type: 'Boolean', declaredBy: 'mx.styles.StyleManagerImpl', parameters: function () { return [ 'String', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 *  Constructor
 *  
 *  @langversion 3.0
 *  @playerversion Flash 9
 *  @playerversion AIR 1.1
 *  @productversion Flex 3
 * @constructor
 * @extends {org.apache.royale.events.EventDispatcher}
 * @param {mx.modules.IModuleInfo} moduleInfo
 */
mx.styles.StyleManagerImpl.StyleEventDispatcher = function(moduleInfo) {
  mx.styles.StyleManagerImpl.StyleEventDispatcher.base(this, 'constructor');
};
goog.inherits(mx.styles.StyleManagerImpl.StyleEventDispatcher, org.apache.royale.events.EventDispatcher);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.styles.StyleManagerImpl.StyleEventDispatcher', mx.styles.StyleManagerImpl.StyleEventDispatcher);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.styles.StyleManagerImpl.StyleEventDispatcher.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'StyleEventDispatcher', qName: 'mx.styles.StyleManagerImpl.StyleEventDispatcher', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.styles.StyleManagerImpl.StyleEventDispatcher.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'StyleEventDispatcher': { type: '', declaredBy: 'mx.styles.StyleManagerImpl.StyleEventDispatcher', parameters: function () { return [ 'mx.modules.IModuleInfo', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.StyleEventDispatcher.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 * @constructor
 */
mx.styles.StyleManagerImpl.CSSClass = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.styles.StyleManagerImpl.CSSClass', mx.styles.StyleManagerImpl.CSSClass);


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSClass.CSSSelector = 0;


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSClass.CSSCondition = 1;


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSClass.CSSStyleDeclaration = 2;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.styles.StyleManagerImpl.CSSClass.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'CSSClass', qName: 'mx.styles.StyleManagerImpl.CSSClass', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.styles.StyleManagerImpl.CSSClass.prototype.ROYALE_REFLECTION_INFO = function () {
  return {};
};
/**
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSClass.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 * @constructor
 */
mx.styles.StyleManagerImpl.CSSFactory = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.styles.StyleManagerImpl.CSSFactory', mx.styles.StyleManagerImpl.CSSFactory);


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSFactory.DefaultFactory = 0;


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSFactory.Factory = 1;


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSFactory.Override = 2;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.styles.StyleManagerImpl.CSSFactory.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'CSSFactory', qName: 'mx.styles.StyleManagerImpl.CSSFactory', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.styles.StyleManagerImpl.CSSFactory.prototype.ROYALE_REFLECTION_INFO = function () {
  return {};
};
/**
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSFactory.prototype.ROYALE_COMPILE_FLAGS = 26;



/**
 * @constructor
 */
mx.styles.StyleManagerImpl.CSSDataType = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('mx.styles.StyleManagerImpl.CSSDataType', mx.styles.StyleManagerImpl.CSSDataType);


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSDataType.Native = 0;


/**
 * @export
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSDataType.Definition = 1;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
mx.styles.StyleManagerImpl.CSSDataType.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'CSSDataType', qName: 'mx.styles.StyleManagerImpl.CSSDataType', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
mx.styles.StyleManagerImpl.CSSDataType.prototype.ROYALE_REFLECTION_INFO = function () {
  return {};
};
/**
 * @const
 * @type {number}
 */
mx.styles.StyleManagerImpl.CSSDataType.prototype.ROYALE_COMPILE_FLAGS = 26;
